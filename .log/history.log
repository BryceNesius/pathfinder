--[ 2022.10.25.13.59.34.788.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.10.25.13.59.34.795.0 ]--
InitTree:
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2022.10.25.13.59.34.795.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.10.25.13.59.34.795.2 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        public PFNode(Coord loc, PFNode fromNode) { }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            return 0;
        }

        // returns if this PFNode is still valid
        public boolean isValid() {
            return false;
        }

        // invalidates the PFNode
        public void invalidate() {
        }

        // returns if the PFNode has been used
        public boolean isUsed() {
            return true;
        }

        // uses the PFNode
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
    }

    public void setPathStart(Coord loc) {
    }

    public Coord getPathStart() {
        return null;
    }

    public void setPathEnd(Coord loc) {
    }

    public Coord getPathEnd() {
        return null;
    }

    public void setHeuristic(float v) {
    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {
    }

    public void computePath() {
    }

    public boolean foundPath() {
        return false;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }
}

--[ 2022.10.25.13.59.34.795.3 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.10.25.13.59.34.796.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[2];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.10.25.13.59.34.796.1 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.10.25.13.59.34.796.2 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.10.25.13.59.34.796.3 ]--
InitFile: /.cos265


--[ 2022.10.25.13.59.34.796.4 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.10.25.13.59.34.796.5 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2022.10.25.13.59.40.000.0 ]--
UpdateTree (AD): 1 0
+ /.idea/.gitignore

--[ 2022.10.25.14.00.28.556.0 ]--
DisposeComponent
--[ 2022.10.25.14.00.33.738.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.10.25.14.00.33.773.0 ]--
InitTree:
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2022.10.25.14.00.33.774.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.10.25.14.00.33.774.1 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        public PFNode(Coord loc, PFNode fromNode) { }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            return 0;
        }

        // returns if this PFNode is still valid
        public boolean isValid() {
            return false;
        }

        // invalidates the PFNode
        public void invalidate() {
        }

        // returns if the PFNode has been used
        public boolean isUsed() {
            return true;
        }

        // uses the PFNode
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
    }

    public void setPathStart(Coord loc) {
    }

    public Coord getPathStart() {
        return null;
    }

    public void setPathEnd(Coord loc) {
    }

    public Coord getPathEnd() {
        return null;
    }

    public void setHeuristic(float v) {
    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {
    }

    public void computePath() {
    }

    public boolean foundPath() {
        return false;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }
}

--[ 2022.10.25.14.00.33.775.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.10.25.14.00.33.775.1 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[2];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.10.25.14.00.33.776.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.10.25.14.00.33.777.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.10.25.14.00.33.777.1 ]--
InitFile: /.cos265


--[ 2022.10.25.14.00.33.777.2 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.10.25.14.00.33.777.3 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2022.10.25.14.09.02.827.0 ]--
:/src/Pathfinder.java
+ 13      
--[ 2022.10.25.14.09.02.836.0 ]--
r 13      *
--[ 2022.10.25.14.09.02.850.0 ]--
r 13      * 
--[ 2022.10.25.14.09.02.932.0 ]--
+ 14      
--[ 2022.10.25.14.09.02.936.0 ]--
r 14      *
--[ 2022.10.25.14.09.02.940.0 ]--
r 14      * 
--[ 2022.10.25.14.09.05.330.0 ]--
r 14      * 1
--[ 2022.10.25.14.09.05.365.0 ]--
r 14      * 1.
--[ 2022.10.25.14.09.05.524.0 ]--
r 14      * 1. 
--[ 2022.10.25.14.09.07.274.0 ]--
r 14      * 1. i
--[ 2022.10.25.14.09.07.339.0 ]--
r 14      * 1. id
--[ 2022.10.25.14.09.07.490.0 ]--
r 14      * 1. ide
--[ 2022.10.25.14.09.07.568.0 ]--
r 14      * 1. iden
--[ 2022.10.25.14.09.07.715.0 ]--
r 14      * 1. ident
--[ 2022.10.25.14.09.07.772.0 ]--
r 14      * 1. identi
--[ 2022.10.25.14.09.07.935.0 ]--
r 14      * 1. identif
--[ 2022.10.25.14.09.08.019.0 ]--
r 14      * 1. identify
--[ 2022.10.25.14.09.08.159.0 ]--
r 14      * 1. identify 
--[ 2022.10.25.14.09.09.362.0 ]--
r 14      * 1. identify p
--[ 2022.10.25.14.09.09.431.0 ]--
r 14      * 1. identify po
--[ 2022.10.25.14.09.09.577.0 ]--
r 14      * 1. identify pos
--[ 2022.10.25.14.09.09.675.0 ]--
r 14      * 1. identify poss
--[ 2022.10.25.14.09.09.758.0 ]--
r 14      * 1. identify possi
--[ 2022.10.25.14.09.10.001.0 ]--
r 14      * 1. identify possib
--[ 2022.10.25.14.09.10.055.0 ]--
r 14      * 1. identify possibl
--[ 2022.10.25.14.09.10.333.0 ]--
r 14      * 1. identify possibly
--[ 2022.10.25.14.09.10.513.0 ]--
r 14      * 1. identify possibly 
--[ 2022.10.25.14.09.10.782.0 ]--
r 14      * 1. identify possibly p
--[ 2022.10.25.14.09.10.862.0 ]--
r 14      * 1. identify possibly pa
--[ 2022.10.25.14.09.10.947.0 ]--
r 14      * 1. identify possibly pat
--[ 2022.10.25.14.09.11.026.0 ]--
r 14      * 1. identify possibly path
--[ 2022.10.25.14.09.11.155.0 ]--
r 14      * 1. identify possibly paths
--[ 2022.10.25.14.09.11.416.0 ]--
r 14      * 1. identify possibly path
--[ 2022.10.25.14.09.11.560.0 ]--
r 14      * 1. identify possibly pat
--[ 2022.10.25.14.09.11.713.0 ]--
r 14      * 1. identify possibly pa
--[ 2022.10.25.14.09.11.873.0 ]--
r 14      * 1. identify possibly p
--[ 2022.10.25.14.09.12.036.0 ]--
r 14      * 1. identify possibly 
--[ 2022.10.25.14.09.12.213.0 ]--
r 14      * 1. identify possibly
--[ 2022.10.25.14.09.12.368.0 ]--
r 14      * 1. identify possibl
--[ 2022.10.25.14.09.12.492.0 ]--
r 14      * 1. identify possible
--[ 2022.10.25.14.09.12.596.0 ]--
r 14      * 1. identify possible 
--[ 2022.10.25.14.09.12.694.0 ]--
r 14      * 1. identify possible p
--[ 2022.10.25.14.09.12.805.0 ]--
r 14      * 1. identify possible pa
--[ 2022.10.25.14.09.12.862.0 ]--
r 14      * 1. identify possible pat
--[ 2022.10.25.14.09.12.957.0 ]--
r 14      * 1. identify possible path
--[ 2022.10.25.14.09.13.068.0 ]--
r 14      * 1. identify possible paths
--[ 2022.10.25.14.09.15.068.0 ]--
+ 15      
--[ 2022.10.25.14.09.15.074.0 ]--
r 15      *
--[ 2022.10.25.14.09.15.080.0 ]--
r 15      * 
--[ 2022.10.25.14.09.15.806.0 ]--
r 15      * 2
--[ 2022.10.25.14.09.15.884.0 ]--
r 15      * 2.
--[ 2022.10.25.14.09.16.021.0 ]--
r 15      * 2. 
--[ 2022.10.25.14.09.16.186.0 ]--
r 15      * 2. a
--[ 2022.10.25.14.09.16.355.0 ]--
r 15      * 2. ad
--[ 2022.10.25.14.09.16.471.0 ]--
r 15      * 2. add
--[ 2022.10.25.14.09.16.540.0 ]--
r 15      * 2. add 
--[ 2022.10.25.14.09.16.640.0 ]--
r 15      * 2. add t
--[ 2022.10.25.14.09.16.703.0 ]--
r 15      * 2. add th
--[ 2022.10.25.14.09.16.779.0 ]--
r 15      * 2. add the
--[ 2022.10.25.14.09.16.932.0 ]--
r 15      * 2. add them
--[ 2022.10.25.14.09.17.020.0 ]--
r 15      * 2. add them 
--[ 2022.10.25.14.09.17.178.0 ]--
r 15      * 2. add them t
--[ 2022.10.25.14.09.17.269.0 ]--
r 15      * 2. add them to
--[ 2022.10.25.14.09.17.350.0 ]--
r 15      * 2. add them to 
--[ 2022.10.25.14.09.17.443.0 ]--
r 15      * 2. add them to t
--[ 2022.10.25.14.09.17.502.0 ]--
r 15      * 2. add them to th
--[ 2022.10.25.14.09.17.613.0 ]--
r 15      * 2. add them to the
--[ 2022.10.25.14.09.17.670.0 ]--
r 15      * 2. add them to the 
--[ 2022.10.25.14.09.18.838.0 ]--
r 15      * 2. add them to the Q
--[ 2022.10.25.14.09.19.536.0 ]--
r 15      * 2. add them to the 
--[ 2022.10.25.14.09.19.762.0 ]--
r 15      * 2. add them to the P
--[ 2022.10.25.14.09.19.904.0 ]--
r 15      * 2. add them to the Pr
--[ 2022.10.25.14.09.20.001.0 ]--
r 15      * 2. add them to the Pro
--[ 2022.10.25.14.09.21.595.0 ]--
r 15      * 2. add them to the Pr
--[ 2022.10.25.14.09.21.716.0 ]--
r 15      * 2. add them to the Pri
--[ 2022.10.25.14.09.21.864.0 ]--
r 15      * 2. add them to the Prio
--[ 2022.10.25.14.09.22.677.0 ]--
r 15      * 2. add them to the Prior
--[ 2022.10.25.14.09.22.735.0 ]--
r 15      * 2. add them to the Priori
--[ 2022.10.25.14.09.22.869.0 ]--
r 15      * 2. add them to the Priorit
--[ 2022.10.25.14.09.22.942.0 ]--
r 15      * 2. add them to the Priority
--[ 2022.10.25.14.09.23.072.0 ]--
r 15      * 2. add them to the Priority 
--[ 2022.10.25.14.09.23.782.0 ]--
r 15      * 2. add them to the Priority
--[ 2022.10.25.14.09.24.001.0 ]--
r 15      * 2. add them to the PriorityQ
--[ 2022.10.25.14.09.24.169.0 ]--
r 15      * 2. add them to the PriorityQu
--[ 2022.10.25.14.09.25.065.0 ]--
r 15      * 2. add them to the PriorityQ
--[ 2022.10.25.14.09.26.086.0 ]--
+ 16      
--[ 2022.10.25.14.09.26.092.0 ]--
r 16      *
--[ 2022.10.25.14.09.26.098.0 ]--
r 16      * 
--[ 2022.10.25.14.09.27.529.0 ]--
r 16      * 3
--[ 2022.10.25.14.09.27.593.0 ]--
r 16      * 3.
--[ 2022.10.25.14.09.27.704.0 ]--
r 16      * 3. 
--[ 2022.10.25.14.34.52.836.0 ]--
r 13      *
r 16      * 3.
--[ 2022.10.25.14.35.49.011.0 ]--
UpdateTree (AD): 24 0
+ /out/production/P04_Pathfinding/.donotlog
+ /out/production/P04_Pathfinding/algs4.jar
+ /out/production/P04_Pathfinding/stdlib.jar
+ /out/production/P04_Pathfinding/Coord.class
+ /out/production/P04_Pathfinding/png2emap.py
+ /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/ramp.png.emap
+ /out/production/P04_Pathfinding/Terrain.class
+ /out/production/P04_Pathfinding/ramp2.png.emap
+ /out/production/P04_Pathfinding/ramp3.png.emap
+ /out/production/P04_Pathfinding/mazeAB.png.emap
+ /out/production/P04_Pathfinding/usa128.png.emap
+ /out/production/P04_Pathfinding/usa256.png.emap
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/usa1024.png.emap
+ /out/production/P04_Pathfinding/maze32_0.png.emap
+ /out/production/P04_Pathfinding/maze32_1.png.emap
+ /out/production/P04_Pathfinding/maze232_0.png.emap
+ /out/production/P04_Pathfinding/maze320_0.png.emap
+ /out/production/P04_Pathfinding/mazeBrain.png.emap
+ /out/production/P04_Pathfinding/TerrainEditor.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/PathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2022.10.25.14.35.49.011.1 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.10.25.14.59.28.082.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.10.25.15.00.51.943.0 ]--
:/src/Walker.java
r 16         return t;
--[ 2022.10.25.15.00.52.040.0 ]--
r 16         return th;
--[ 2022.10.25.15.00.52.092.0 ]--
r 16         return thi;
--[ 2022.10.25.15.00.52.236.0 ]--
r 16         return this;
--[ 2022.10.25.15.00.52.406.0 ]--
r 16         return this.;
--[ 2022.10.25.15.00.54.056.0 ]--
r 16         return this.c;
--[ 2022.10.25.15.00.54.146.0 ]--
r 16         return this.cu;
--[ 2022.10.25.15.00.54.943.0 ]--
r 16         return this.c;
--[ 2022.10.25.15.00.55.144.0 ]--
r 16         return this.;
--[ 2022.10.25.15.00.57.434.0 ]--
r 16         return this.C;
--[ 2022.10.25.15.00.58.276.0 ]--
r 16         return this.;
--[ 2022.10.25.15.00.58.400.0 ]--
r 16         return this.c;
--[ 2022.10.25.15.00.58.508.0 ]--
r 16         return this.co;
--[ 2022.10.25.15.00.59.260.0 ]--
r 16         return this.c;
--[ 2022.10.25.15.01.01.002.0 ]--
r 16         return this.;
--[ 2022.10.25.15.01.01.177.0 ]--
r 16         return this;
--[ 2022.10.25.15.01.01.664.0 ]--
r 16         return thi;
--[ 2022.10.25.15.01.01.817.0 ]--
r 16         return th;
--[ 2022.10.25.15.01.01.996.0 ]--
r 16         return t;
--[ 2022.10.25.15.01.02.143.0 ]--
r 16         return ;
--[ 2022.10.25.15.01.02.238.0 ]--
r 16         return n;
--[ 2022.10.25.15.01.02.495.0 ]--
r 16         return nu;
--[ 2022.10.25.15.01.02.593.0 ]--
r 16         return nul;
--[ 2022.10.25.15.01.02.824.0 ]--
r 16         return null;
--[ 2022.10.25.15.02.04.804.0 ]--
:/src/Pathfinder.java
r 16      * 3. 
--[ 2022.10.25.15.02.09.357.0 ]--
r 16      * 3. D
--[ 2022.10.25.15.02.09.552.0 ]--
r 16      * 3. Dt
--[ 2022.10.25.15.02.09.687.0 ]--
r 16      * 3. Dte
--[ 2022.10.25.15.02.09.794.0 ]--
r 16      * 3. Dter
--[ 2022.10.25.15.02.10.232.0 ]--
r 16      * 3. Dte
--[ 2022.10.25.15.02.10.415.0 ]--
r 16      * 3. Dt
--[ 2022.10.25.15.02.10.558.0 ]--
r 16      * 3. D
--[ 2022.10.25.15.02.10.934.0 ]--
r 16      * 3. De
--[ 2022.10.25.15.02.11.083.0 ]--
r 16      * 3. Det
--[ 2022.10.25.15.02.11.167.0 ]--
r 16      * 3. Dete
--[ 2022.10.25.15.02.11.247.0 ]--
r 16      * 3. Deter
--[ 2022.10.25.15.02.11.402.0 ]--
r 16      * 3. Determ
--[ 2022.10.25.15.02.11.540.0 ]--
r 16      * 3. Determi
--[ 2022.10.25.15.02.11.629.0 ]--
r 16      * 3. Determin
--[ 2022.10.25.15.02.11.700.0 ]--
r 16      * 3. Determine
--[ 2022.10.25.15.02.11.820.0 ]--
r 16      * 3. Determine 
--[ 2022.10.25.15.02.12.025.0 ]--
r 16      * 3. Determine c
--[ 2022.10.25.15.02.12.106.0 ]--
r 16      * 3. Determine co
--[ 2022.10.25.15.02.12.204.0 ]--
r 16      * 3. Determine cos
--[ 2022.10.25.15.02.12.323.0 ]--
r 16      * 3. Determine cost
--[ 2022.10.25.15.02.14.405.0 ]--
r 16      * 3. Determine cost 
--[ 2022.10.25.15.02.14.550.0 ]--
r 16      * 3. Determine cost t
--[ 2022.10.25.15.02.14.582.0 ]--
r 16      * 3. Determine cost to
--[ 2022.10.25.15.02.14.690.0 ]--
r 16      * 3. Determine cost to 
--[ 2022.10.25.15.02.14.807.0 ]--
r 16      * 3. Determine cost to m
--[ 2022.10.25.15.02.14.921.0 ]--
r 16      * 3. Determine cost to mo
--[ 2022.10.25.15.02.14.994.0 ]--
r 16      * 3. Determine cost to mov
--[ 2022.10.25.15.02.15.139.0 ]--
r 16      * 3. Determine cost to move
--[ 2022.10.25.15.02.19.225.0 ]--
r 16      * 3. 
--[ 2022.10.25.15.02.20.661.0 ]--
+ 15      
--[ 2022.10.25.15.02.20.664.0 ]--
r 15      *
--[ 2022.10.25.15.02.20.668.0 ]--
r 15      * 
--[ 2022.10.25.15.02.22.613.0 ]--
r 15      * 2
--[ 2022.10.25.15.02.22.865.0 ]--
r 15      * 2.
--[ 2022.10.25.15.02.23.006.0 ]--
r 15      * 2. 
--[ 2022.10.25.15.02.23.477.0 ]--
r 15      * 2. Determine cost to move
--[ 2022.10.25.15.02.25.239.0 ]--
r 16      * . add them to the PriorityQ
--[ 2022.10.25.15.02.25.553.0 ]--
r 16      * 3. add them to the PriorityQ
--[ 2022.10.25.15.02.28.368.0 ]--
r 17      * 3 
--[ 2022.10.25.15.02.28.518.0 ]--
r 17      *  
--[ 2022.10.25.15.02.28.795.0 ]--
r 17      * 4 
--[ 2022.10.25.15.02.29.039.0 ]--
r 17      * 4. 
--[ 2022.10.25.15.02.29.237.0 ]--
r 17      * 4.  
--[ 2022.10.25.15.02.30.485.0 ]--
r 17      * 4. p 
--[ 2022.10.25.15.02.30.595.0 ]--
r 17      * 4. po 
--[ 2022.10.25.15.02.30.679.0 ]--
r 17      * 4. pop 
--[ 2022.10.25.15.02.30.791.0 ]--
r 17      * 4. popo 
--[ 2022.10.25.15.02.30.878.0 ]--
r 17      * 4. popo  
--[ 2022.10.25.15.02.31.361.0 ]--
r 17      * 4. popo 
--[ 2022.10.25.15.02.31.530.0 ]--
r 17      * 4. pop 
--[ 2022.10.25.15.02.31.698.0 ]--
r 17      * 4. po 
--[ 2022.10.25.15.02.31.857.0 ]--
r 17      * 4. p 
--[ 2022.10.25.15.02.32.021.0 ]--
r 17      * 4.  
--[ 2022.10.25.15.02.32.068.0 ]--
r 17      * 4. d 
--[ 2022.10.25.15.02.32.218.0 ]--
r 17      * 4. de 
--[ 2022.10.25.15.02.32.367.0 ]--
r 17      * 4. deq 
--[ 2022.10.25.15.02.32.452.0 ]--
r 17      * 4. dequ 
--[ 2022.10.25.15.02.32.589.0 ]--
r 17      * 4. deque 
--[ 2022.10.25.15.02.32.750.0 ]--
r 17      * 4. dequeu 
--[ 2022.10.25.15.02.33.353.0 ]--
r 17      * 4. dequeue 
--[ 2022.10.25.15.02.33.577.0 ]--
r 17      * 4. dequeue  
--[ 2022.10.25.15.02.33.956.0 ]--
r 17      * 4. dequeue t 
--[ 2022.10.25.15.02.34.047.0 ]--
r 17      * 4. dequeue to 
--[ 2022.10.25.15.02.34.177.0 ]--
r 17      * 4. dequeue top 
--[ 2022.10.25.15.02.34.376.0 ]--
r 17      * 4. dequeue top  
--[ 2022.10.25.15.02.35.921.0 ]--
r 17      * 4. dequeue top a 
--[ 2022.10.25.15.02.36.104.0 ]--
r 17      * 4. dequeue top ad 
--[ 2022.10.25.15.02.36.185.0 ]--
r 17      * 4. dequeue top adn 
--[ 2022.10.25.15.02.36.569.0 ]--
r 17      * 4. dequeue top ad 
--[ 2022.10.25.15.02.36.732.0 ]--
r 17      * 4. dequeue top a 
--[ 2022.10.25.15.02.36.820.0 ]--
r 17      * 4. dequeue top an 
--[ 2022.10.25.15.02.36.870.0 ]--
r 17      * 4. dequeue top and 
--[ 2022.10.25.15.02.36.969.0 ]--
r 17      * 4. dequeue top and  
--[ 2022.10.25.15.02.37.872.0 ]--
r 17      * 4. dequeue top and c 
--[ 2022.10.25.15.02.37.977.0 ]--
r 17      * 4. dequeue top and co 
--[ 2022.10.25.15.02.38.020.0 ]--
r 17      * 4. dequeue top and com 
--[ 2022.10.25.15.02.38.129.0 ]--
r 17      * 4. dequeue top and comp 
--[ 2022.10.25.15.02.38.243.0 ]--
r 17      * 4. dequeue top and compa 
--[ 2022.10.25.15.02.38.352.0 ]--
r 17      * 4. dequeue top and compar 
--[ 2022.10.25.15.02.38.439.0 ]--
r 17      * 4. dequeue top and compare 
--[ 2022.10.25.15.02.38.607.0 ]--
r 17      * 4. dequeue top and compare  
--[ 2022.10.25.15.02.40.024.0 ]--
r 17      * 4. dequeue top and compare s 
--[ 2022.10.25.15.02.40.171.0 ]--
r 17      * 4. dequeue top and compare su 
--[ 2022.10.25.15.02.40.275.0 ]--
r 17      * 4. dequeue top and compare sur 
--[ 2022.10.25.15.02.40.409.0 ]--
r 17      * 4. dequeue top and compare surr 
--[ 2022.10.25.15.02.40.930.0 ]--
r 17      * 4. dequeue top and compare sur 
--[ 2022.10.25.15.02.41.069.0 ]--
r 17      * 4. dequeue top and compare su 
--[ 2022.10.25.15.02.41.226.0 ]--
r 17      * 4. dequeue top and compare s 
--[ 2022.10.25.15.02.41.384.0 ]--
r 17      * 4. dequeue top and compare  
--[ 2022.10.25.15.02.41.530.0 ]--
r 17      * 4. dequeue top and compare 
--[ 2022.10.25.15.02.41.696.0 ]--
r 17      * 4. dequeue top and compar 
--[ 2022.10.25.15.02.41.874.0 ]--
r 17      * 4. dequeue top and compa 
--[ 2022.10.25.15.02.42.055.0 ]--
r 17      * 4. dequeue top and comp 
--[ 2022.10.25.15.02.42.236.0 ]--
r 17      * 4. dequeue top and com 
--[ 2022.10.25.15.02.42.421.0 ]--
r 17      * 4. dequeue top and co 
--[ 2022.10.25.15.02.43.081.0 ]--
r 17      * 4. dequeue top and c 
--[ 2022.10.25.15.02.43.588.0 ]--
r 17      * 4. dequeue top and  
--[ 2022.10.25.15.02.44.039.0 ]--
r 17      * 4. dequeue top and g 
--[ 2022.10.25.15.02.44.098.0 ]--
r 17      * 4. dequeue top and go 
--[ 2022.10.25.15.02.44.208.0 ]--
r 17      * 4. dequeue top and go  
--[ 2022.10.25.15.02.44.367.0 ]--
r 17      * 4. dequeue top and go b 
--[ 2022.10.25.15.02.44.485.0 ]--
r 17      * 4. dequeue top and go ba 
--[ 2022.10.25.15.02.44.620.0 ]--
r 17      * 4. dequeue top and go bac 
--[ 2022.10.25.15.02.44.720.0 ]--
r 17      * 4. dequeue top and go back 
--[ 2022.10.25.15.02.44.841.0 ]--
r 17      * 4. dequeue top and go back  
--[ 2022.10.25.15.02.44.888.0 ]--
r 17      * 4. dequeue top and go back t 
--[ 2022.10.25.15.02.45.024.0 ]--
r 17      * 4. dequeue top and go back to 
--[ 2022.10.25.15.02.45.066.0 ]--
r 17      * 4. dequeue top and go back to  
--[ 2022.10.25.15.02.45.617.0 ]--
r 17      * 4. dequeue top and go back to s 
--[ 2022.10.25.15.02.45.709.0 ]--
r 17      * 4. dequeue top and go back to st 
--[ 2022.10.25.15.02.45.818.0 ]--
r 17      * 4. dequeue top and go back to ste 
--[ 2022.10.25.15.02.45.906.0 ]--
r 17      * 4. dequeue top and go back to step 
--[ 2022.10.25.15.02.46.008.0 ]--
r 17      * 4. dequeue top and go back to step  
--[ 2022.10.25.15.02.46.520.0 ]--
r 17      * 4. dequeue top and go back to step 1 
--[ 2022.10.25.15.03.24.036.0 ]--
r 17      * 4. dequeue top and go back to step 1
--[ 2022.10.25.15.04.00.557.0 ]--
+ 26             
--[ 2022.10.25.15.04.04.983.0 ]--
r 26             i
--[ 2022.10.25.15.04.05.191.0 ]--
r 26             if
--[ 2022.10.25.15.04.06.932.0 ]--
r 26             if ()
--[ 2022.10.25.15.04.08.305.0 ]--
r 26             if (t)
--[ 2022.10.25.15.04.08.392.0 ]--
r 26             if (th)
--[ 2022.10.25.15.04.08.482.0 ]--
r 26             if (thi)
--[ 2022.10.25.15.04.08.536.0 ]--
r 26             if (this)
--[ 2022.10.25.15.04.11.015.0 ]--
r 26             if (this )
--[ 2022.10.25.15.04.13.235.0 ]--
r 26             if (this <)
--[ 2022.10.25.15.04.13.722.0 ]--
r 26             if (this < )
--[ 2022.10.25.15.04.13.967.0 ]--
r 26             if (this < t)
--[ 2022.10.25.15.04.14.054.0 ]--
r 26             if (this < th)
--[ 2022.10.25.15.04.14.115.0 ]--
r 26             if (this < tha)
--[ 2022.10.25.15.04.14.187.0 ]--
r 26             if (this < that)
--[ 2022.10.25.15.04.14.882.0 ]--
r 26             if (this < tha)
--[ 2022.10.25.15.04.15.618.0 ]--
r 26             if (this < th)
--[ 2022.10.25.15.04.15.779.0 ]--
r 26             if (this < t)
--[ 2022.10.25.15.04.15.957.0 ]--
r 26             if (this < )
--[ 2022.10.25.15.04.16.114.0 ]--
r 26             if (this <)
--[ 2022.10.25.15.04.16.290.0 ]--
r 26             if (this )
--[ 2022.10.25.15.04.16.441.0 ]--
r 26             if (this)
--[ 2022.10.25.15.04.16.625.0 ]--
r 26             if (thi)
--[ 2022.10.25.15.04.16.788.0 ]--
r 26             if (th)
--[ 2022.10.25.15.04.16.961.0 ]--
r 26             if (t)
--[ 2022.10.25.15.04.17.121.0 ]--
r 26             if ()
--[ 2022.10.25.15.04.17.406.0 ]--
r 26             if (t)
--[ 2022.10.25.15.04.17.505.0 ]--
r 26             if (th)
--[ 2022.10.25.15.04.17.924.0 ]--
r 26             if (t)
--[ 2022.10.25.15.04.18.399.0 ]--
r 26             if (tt)
--[ 2022.10.25.15.04.18.439.0 ]--
r 26             if (tth)
--[ 2022.10.25.15.04.18.541.0 ]--
r 26             if (tthi)
--[ 2022.10.25.15.04.18.611.0 ]--
r 26             if (tthis)
--[ 2022.10.25.15.04.18.720.0 ]--
r 26             if (tthis )
--[ 2022.10.25.15.04.19.026.0 ]--
r 26             if (tthis)
--[ 2022.10.25.15.04.19.172.0 ]--
r 26             if (tthi)
--[ 2022.10.25.15.04.19.323.0 ]--
r 26             if (tth)
--[ 2022.10.25.15.04.19.500.0 ]--
r 26             if (tt)
--[ 2022.10.25.15.04.19.658.0 ]--
r 26             if (t)
--[ 2022.10.25.15.04.19.756.0 ]--
r 26             if (th)
--[ 2022.10.25.15.04.19.815.0 ]--
r 26             if (thi)
--[ 2022.10.25.15.04.19.923.0 ]--
r 26             if (this)
--[ 2022.10.25.15.04.20.039.0 ]--
r 26             if (this )
--[ 2022.10.25.15.04.20.420.0 ]--
r 26             if (this >)
--[ 2022.10.25.15.04.20.586.0 ]--
r 26             if (this > )
--[ 2022.10.25.15.04.20.849.0 ]--
r 26             if (this > t)
--[ 2022.10.25.15.04.20.943.0 ]--
r 26             if (this > th)
--[ 2022.10.25.15.04.20.967.0 ]--
r 26             if (this > tha)
--[ 2022.10.25.15.04.21.083.0 ]--
r 26             if (this > that)
--[ 2022.10.25.15.04.25.316.0 ]--
r 26             if (this > that.getCost)
--[ 2022.10.25.15.04.25.329.0 ]--
r 26             if (this > that;)
--[ 2022.10.25.15.04.25.337.0 ]--
r 26             if (this > that.getCost)
--[ 2022.10.25.15.04.25.347.0 ]--
r 26             if (this > that.getCost())
--[ 2022.10.25.15.04.28.590.0 ]--
r 26             if (this. > that.getCost())
--[ 2022.10.25.15.04.29.344.0 ]--
r 26             if (this.g > that.getCost())
--[ 2022.10.25.15.04.29.429.0 ]--
r 26             if (this.ge > that.getCost())
--[ 2022.10.25.15.04.29.557.0 ]--
r 26             if (this.get > that.getCost())
--[ 2022.10.25.15.04.29.910.0 ]--
r 26             if (this.getCost > that.getCost())
--[ 2022.10.25.15.04.29.917.0 ]--
r 26             if (this.getCost() > that.getCost())
--[ 2022.10.25.15.05.04.533.0 ]--
r 26             if (this.getCost() > that.getCost()) 
--[ 2022.10.25.15.05.05.121.0 ]--
r 26             if (this.getCost() > that.getCost()) {
--[ 2022.10.25.15.05.06.543.0 ]--
+ 27 
+ 28 }
--[ 2022.10.25.15.05.06.554.0 ]--
r 28             }
--[ 2022.10.25.15.05.06.572.0 ]--
r 27                 
--[ 2022.10.25.15.05.10.649.0 ]--
r 27                 r
--[ 2022.10.25.15.05.10.712.0 ]--
r 27                 re
--[ 2022.10.25.15.05.10.878.0 ]--
r 27                 ret
--[ 2022.10.25.15.05.10.987.0 ]--
r 27                 retu
--[ 2022.10.25.15.05.11.076.0 ]--
r 27                 retur
--[ 2022.10.25.15.05.11.225.0 ]--
r 27                 return
--[ 2022.10.25.15.05.22.439.0 ]--
- 26
- 26
r 26             
--[ 2022.10.25.15.05.39.790.0 ]--
r 26             i
--[ 2022.10.25.15.05.39.825.0 ]--
r 26             if
--[ 2022.10.25.15.05.40.002.0 ]--
r 26             if ()
--[ 2022.10.25.15.05.40.576.0 ]--
r 26             if (t)
--[ 2022.10.25.15.05.40.641.0 ]--
r 26             if (th)
--[ 2022.10.25.15.05.40.741.0 ]--
r 26             if (thi)
--[ 2022.10.25.15.05.40.788.0 ]--
r 26             if (this)
--[ 2022.10.25.15.05.41.001.0 ]--
r 26             if (this.)
--[ 2022.10.25.15.05.41.974.0 ]--
r 26             if (this.g)
--[ 2022.10.25.15.05.42.071.0 ]--
r 26             if (this.ge)
--[ 2022.10.25.15.05.42.186.0 ]--
r 26             if (this.get)
--[ 2022.10.25.15.05.42.278.0 ]--
r 26             if (this.getCost)
--[ 2022.10.25.15.05.42.282.0 ]--
r 26             if (this.getCost())
--[ 2022.10.25.15.05.46.498.0 ]--
r 26             if (this.getCost() )
--[ 2022.10.25.15.05.46.720.0 ]--
r 26             if (this.getCost() >)
--[ 2022.10.25.15.05.48.182.0 ]--
r 26             if (this.getCost() > )
--[ 2022.10.25.15.05.48.301.0 ]--
r 26             if (this.getCost() > t)
--[ 2022.10.25.15.05.48.383.0 ]--
r 26             if (this.getCost() > th)
--[ 2022.10.25.15.05.48.398.0 ]--
r 26             if (this.getCost() > tha)
--[ 2022.10.25.15.05.48.487.0 ]--
r 26             if (this.getCost() > that)
--[ 2022.10.25.15.05.48.632.0 ]--
r 26             if (this.getCost() > that.)
--[ 2022.10.25.15.05.48.887.0 ]--
r 26             if (this.getCost() > that.g)
--[ 2022.10.25.15.05.48.974.0 ]--
r 26             if (this.getCost() > that.ge)
--[ 2022.10.25.15.05.49.094.0 ]--
r 26             if (this.getCost() > that.get)
--[ 2022.10.25.15.05.49.244.0 ]--
r 26             if (this.getCost() > that.getCost)
--[ 2022.10.25.15.05.49.248.0 ]--
r 26             if (this.getCost() > that.getCost())
--[ 2022.10.25.15.05.51.140.0 ]--
r 26             if (this.getCost() > that.getCost()) 
--[ 2022.10.25.15.05.51.584.0 ]--
r 26             if (this.getCost() > that.getCost()) {
--[ 2022.10.25.15.05.52.219.0 ]--
+ 27 
+ 28 }
--[ 2022.10.25.15.05.52.228.0 ]--
r 28             }
--[ 2022.10.25.15.05.52.245.0 ]--
r 27                 
--[ 2022.10.25.15.05.52.821.0 ]--
r 27                 r
--[ 2022.10.25.15.05.52.920.0 ]--
r 27                 re
--[ 2022.10.25.15.05.53.035.0 ]--
r 27                 ret
--[ 2022.10.25.15.05.53.103.0 ]--
r 27                 retu
--[ 2022.10.25.15.05.53.236.0 ]--
r 27                 retur
--[ 2022.10.25.15.05.53.344.0 ]--
r 27                 return
--[ 2022.10.25.15.05.53.472.0 ]--
r 27                 return 
--[ 2022.10.25.15.05.53.640.0 ]--
r 27                 return t
--[ 2022.10.25.15.05.53.759.0 ]--
r 27                 return th
--[ 2022.10.25.15.05.53.767.0 ]--
r 27                 return tha
--[ 2022.10.25.15.05.53.833.0 ]--
r 27                 return that
--[ 2022.10.25.15.05.56.463.0 ]--
r 27                 return that;
--[ 2022.10.25.15.05.58.802.0 ]--
r 29             return ;
--[ 2022.10.25.15.05.59.036.0 ]--
r 29             return t;
--[ 2022.10.25.15.05.59.124.0 ]--
r 29             return th;
--[ 2022.10.25.15.05.59.201.0 ]--
r 29             return thi;
--[ 2022.10.25.15.05.59.317.0 ]--
r 29             return this;
--[ 2022.10.25.15.06.07.479.0 ]--
r 27                 return 0;
--[ 2022.10.25.15.06.09.421.0 ]--
r 27                 return ;
--[ 2022.10.25.15.06.15.434.0 ]--
r 27                 return 1;
--[ 2022.10.25.15.06.20.257.0 ]--
+ 29             
--[ 2022.10.25.15.06.20.401.0 ]--
r 29             e
--[ 2022.10.25.15.06.20.490.0 ]--
r 29             el
--[ 2022.10.25.15.06.20.602.0 ]--
r 29             els
--[ 2022.10.25.15.06.20.683.0 ]--
r 29             else
--[ 2022.10.25.15.06.21.050.0 ]--
r 29             else 
--[ 2022.10.25.15.06.21.140.0 ]--
r 29             else i
--[ 2022.10.25.15.06.21.167.0 ]--
r 29             else if
--[ 2022.10.25.15.06.21.284.0 ]--
r 29             else if 
--[ 2022.10.25.15.06.22.784.0 ]--
r 29             else if ()
--[ 2022.10.25.15.06.25.389.0 ]--
r 29             else if (t)
--[ 2022.10.25.15.06.25.471.0 ]--
r 29             else if (th)
--[ 2022.10.25.15.06.25.532.0 ]--
r 29             else if (thi)
--[ 2022.10.25.15.06.25.605.0 ]--
r 29             else if (this)
--[ 2022.10.25.15.06.25.777.0 ]--
r 29             else if (this.)
--[ 2022.10.25.15.06.25.973.0 ]--
r 29             else if (this.g)
--[ 2022.10.25.15.06.26.061.0 ]--
r 29             else if (this.ge)
--[ 2022.10.25.15.06.26.220.0 ]--
r 29             else if (this.get)
--[ 2022.10.25.15.06.26.288.0 ]--
r 29             else if (this.getCost)
--[ 2022.10.25.15.06.26.293.0 ]--
r 29             else if (this.getCost())
--[ 2022.10.25.15.06.33.611.0 ]--
r 26             if (this.getCost() >= that.getCost()) {
--[ 2022.10.25.15.06.35.742.0 ]--
r 26             if (this.getCost() > that.getCost()) {
--[ 2022.10.25.15.06.42.948.0 ]--
r 29             else if (this.getCost() )
--[ 2022.10.25.15.06.43.344.0 ]--
r 29             else if (this.getCost() =)
--[ 2022.10.25.15.06.43.651.0 ]--
r 29             else if (this.getCost() ==)
--[ 2022.10.25.15.06.43.891.0 ]--
r 29             else if (this.getCost() == )
--[ 2022.10.25.15.06.44.733.0 ]--
r 29             else if (this.getCost() ==)
--[ 2022.10.25.15.06.44.944.0 ]--
r 29             else if (this.getCost() =)
--[ 2022.10.25.15.06.45.132.0 ]--
r 29             else if (this.getCost() )
--[ 2022.10.25.15.06.45.422.0 ]--
r 29             else if (this.getCost() <)
--[ 2022.10.25.15.06.46.450.0 ]--
r 29             else if (this.getCost() < )
--[ 2022.10.25.15.06.46.731.0 ]--
r 29             else if (this.getCost() < t)
--[ 2022.10.25.15.06.46.809.0 ]--
r 29             else if (this.getCost() < th)
--[ 2022.10.25.15.06.46.864.0 ]--
r 29             else if (this.getCost() < tha)
--[ 2022.10.25.15.06.46.944.0 ]--
r 29             else if (this.getCost() < that)
--[ 2022.10.25.15.06.47.145.0 ]--
r 29             else if (this.getCost() < that.)
--[ 2022.10.25.15.06.47.288.0 ]--
r 29             else if (this.getCost() < that.g)
--[ 2022.10.25.15.06.47.383.0 ]--
r 29             else if (this.getCost() < that.ge)
--[ 2022.10.25.15.06.47.518.0 ]--
r 29             else if (this.getCost() < that.get)
--[ 2022.10.25.15.06.47.706.0 ]--
r 29             else if (this.getCost() < that.getCost)
--[ 2022.10.25.15.06.47.711.0 ]--
r 29             else if (this.getCost() < that.getCost())
--[ 2022.10.25.15.06.49.723.0 ]--
r 29             else if (this.getCost() < that.getCost()) 
--[ 2022.10.25.15.06.49.929.0 ]--
r 29             else if (this.getCost() < that.getCost()) {
--[ 2022.10.25.15.06.50.158.0 ]--
+ 30 
+ 31 }
--[ 2022.10.25.15.06.50.165.0 ]--
r 31             }
--[ 2022.10.25.15.06.50.179.0 ]--
r 30                 
--[ 2022.10.25.15.06.50.927.0 ]--
r 30                 r
--[ 2022.10.25.15.06.51.021.0 ]--
r 30                 re
--[ 2022.10.25.15.06.51.148.0 ]--
r 30                 ret
--[ 2022.10.25.15.06.51.201.0 ]--
r 30                 retu
--[ 2022.10.25.15.06.51.354.0 ]--
r 30                 retur
--[ 2022.10.25.15.06.51.450.0 ]--
r 30                 return
--[ 2022.10.25.15.06.51.623.0 ]--
r 30                 return 
--[ 2022.10.25.15.06.52.330.0 ]--
r 30                 return -
--[ 2022.10.25.15.06.52.474.0 ]--
r 30                 return -1
--[ 2022.10.25.15.06.52.837.0 ]--
r 30                 return -1;
--[ 2022.10.25.15.07.01.238.0 ]--
r 32             return 0;
--[ 2022.10.25.15.08.04.443.0 ]--
+ 43             
--[ 2022.10.25.15.08.05.594.0 ]--
r 43             i
--[ 2022.10.25.15.08.05.655.0 ]--
r 43             if
--[ 2022.10.25.15.08.05.832.0 ]--
r 43             if ()
--[ 2022.10.25.15.08.06.401.0 ]--
r 43             if (t)
--[ 2022.10.25.15.08.06.482.0 ]--
r 43             if (th)
--[ 2022.10.25.15.08.06.608.0 ]--
r 43             if (thi)
--[ 2022.10.25.15.08.06.714.0 ]--
r 43             if (this)
--[ 2022.10.25.15.08.06.879.0 ]--
r 43             if (this.)
--[ 2022.10.25.15.08.10.561.0 ]--
r 43             if (this.C)
--[ 2022.10.25.15.08.10.677.0 ]--
r 43             if (this.CO)
--[ 2022.10.25.15.08.11.264.0 ]--
r 43             if (this.C)
--[ 2022.10.25.15.08.11.425.0 ]--
r 43             if (this.Co)
--[ 2022.10.25.15.08.11.859.0 ]--
r 43             if (this.C)
--[ 2022.10.25.15.08.12.030.0 ]--
r 43             if (this.)
--[ 2022.10.25.15.08.12.204.0 ]--
r 43             if (this)
--[ 2022.10.25.15.08.12.365.0 ]--
r 43             if (thi)
--[ 2022.10.25.15.08.12.531.0 ]--
r 43             if (th)
--[ 2022.10.25.15.08.12.696.0 ]--
r 43             if (t)
--[ 2022.10.25.15.08.12.893.0 ]--
r 43             if ()
--[ 2022.10.25.15.08.13.764.0 ]--
r 43             if 
--[ 2022.10.25.15.08.13.977.0 ]--
r 43             if
--[ 2022.10.25.15.08.14.154.0 ]--
r 43             i
--[ 2022.10.25.15.08.14.347.0 ]--
r 43             
--[ 2022.10.25.15.08.14.746.0 ]--
- 43
--[ 2022.10.25.15.09.36.823.0 ]--
r 10     
--[ 2022.10.25.15.09.38.037.0 ]--
r 10     C
--[ 2022.10.25.15.09.38.214.0 ]--
r 10     Co
--[ 2022.10.25.15.09.38.312.0 ]--
r 10     Coo
--[ 2022.10.25.15.09.38.414.0 ]--
r 10     Coor
--[ 2022.10.25.15.09.38.570.0 ]--
r 10     Coord
--[ 2022.10.25.15.09.40.823.0 ]--
r 10     Coord 
--[ 2022.10.25.15.09.40.937.0 ]--
r 10     Coord s
--[ 2022.10.25.15.09.41.028.0 ]--
r 10     Coord st
--[ 2022.10.25.15.09.41.143.0 ]--
r 10     Coord sta
--[ 2022.10.25.15.09.41.240.0 ]--
r 10     Coord star
--[ 2022.10.25.15.09.41.433.0 ]--
r 10     Coord start
--[ 2022.10.25.15.09.41.712.0 ]--
r 10     Coord start,
--[ 2022.10.25.15.09.41.827.0 ]--
r 10     Coord start, 
--[ 2022.10.25.15.09.42.866.0 ]--
r 10     Coord start, e
--[ 2022.10.25.15.09.42.968.0 ]--
r 10     Coord start, en
--[ 2022.10.25.15.09.43.052.0 ]--
r 10     Coord start, end
--[ 2022.10.25.15.09.44.196.0 ]--
r 10     Coord start, end 
--[ 2022.10.25.15.09.44.254.0 ]--
r 10     Coord start, end =
--[ 2022.10.25.15.09.44.376.0 ]--
r 10     Coord start, end = 
--[ 2022.10.25.15.09.50.080.0 ]--
r 10     Coord start, end = {}
--[ 2022.10.25.15.09.51.235.0 ]--
r 10     Coord start, end = 
--[ 2022.10.25.15.09.52.651.0 ]--
r 10     Coord start, end =
--[ 2022.10.25.15.09.52.790.0 ]--
r 10     Coord start, end 
--[ 2022.10.25.15.09.52.949.0 ]--
r 10     Coord start, end
--[ 2022.10.25.15.09.53.218.0 ]--
r 10     Coord start, end;
--[ 2022.10.25.15.09.57.770.0 ]--
r 10     Coord start, end
--[ 2022.10.25.15.09.58.648.0 ]--
r 10     Coord start, end 
--[ 2022.10.25.15.09.58.713.0 ]--
r 10     Coord start, end =
--[ 2022.10.25.15.09.58.838.0 ]--
r 10     Coord start, end = 
--[ 2022.10.25.15.09.58.931.0 ]--
r 10     Coord start, end = n
--[ 2022.10.25.15.09.59.144.0 ]--
r 10     Coord start, end = nu
--[ 2022.10.25.15.09.59.264.0 ]--
r 10     Coord start, end = nul
--[ 2022.10.25.15.09.59.401.0 ]--
r 10     Coord start, end = null
--[ 2022.10.25.15.09.59.581.0 ]--
r 10     Coord start, end = null;
--[ 2022.10.25.15.10.10.974.0 ]--
+ 70         
--[ 2022.10.25.15.10.25.829.0 ]--
r 70         s
--[ 2022.10.25.15.10.25.923.0 ]--
r 70         st
--[ 2022.10.25.15.10.26.048.0 ]--
r 70         sta
--[ 2022.10.25.15.10.26.158.0 ]--
r 70         star
--[ 2022.10.25.15.10.26.322.0 ]--
r 70         start
--[ 2022.10.25.15.10.26.461.0 ]--
r 70         start 
--[ 2022.10.25.15.10.26.587.0 ]--
r 70         start =
--[ 2022.10.25.15.10.26.699.0 ]--
r 70         start = 
--[ 2022.10.25.15.10.28.003.0 ]--
r 70         start =
--[ 2022.10.25.15.10.28.918.0 ]--
r 70         start = 
--[ 2022.10.25.15.10.31.801.0 ]--
r 70         start = l
--[ 2022.10.25.15.10.31.994.0 ]--
r 70         start = lo
--[ 2022.10.25.15.10.32.127.0 ]--
r 70         start = loc
--[ 2022.10.25.15.10.32.527.0 ]--
r 70         start = loc;
--[ 2022.10.25.15.10.57.326.0 ]--
+ 78         
--[ 2022.10.25.15.10.58.206.0 ]--
r 78         e
--[ 2022.10.25.15.10.58.336.0 ]--
r 78         en
--[ 2022.10.25.15.10.58.395.0 ]--
r 78         end
--[ 2022.10.25.15.10.58.519.0 ]--
r 78         end 
--[ 2022.10.25.15.10.58.644.0 ]--
r 78         end =
--[ 2022.10.25.15.10.58.762.0 ]--
r 78         end = 
--[ 2022.10.25.15.10.59.241.0 ]--
r 78         end = l
--[ 2022.10.25.15.10.59.387.0 ]--
r 78         end = lo
--[ 2022.10.25.15.10.59.457.0 ]--
r 78         end = loc
--[ 2022.10.25.15.10.59.664.0 ]--
r 78         end = loc;
--[ 2022.10.25.15.11.24.323.0 ]--
r 82         return e;
--[ 2022.10.25.15.11.24.388.0 ]--
r 82         return en;
--[ 2022.10.25.15.11.24.491.0 ]--
r 82         return end;
--[ 2022.10.25.15.11.35.393.0 ]--
+ 11     
--[ 2022.10.25.15.11.41.007.0 ]--
r 11     f
--[ 2022.10.25.15.11.41.095.0 ]--
r 11     fl
--[ 2022.10.25.15.11.41.215.0 ]--
r 11     flo
--[ 2022.10.25.15.11.41.304.0 ]--
r 11     floa
--[ 2022.10.25.15.11.41.395.0 ]--
r 11     float
--[ 2022.10.25.15.11.41.538.0 ]--
r 11     float 
--[ 2022.10.25.15.11.43.733.0 ]--
r 11     float
--[ 2022.10.25.15.11.44.982.0 ]--
r 11     float 
--[ 2022.10.25.15.11.46.037.0 ]--
r 11     float h
--[ 2022.10.25.15.11.47.629.0 ]--
r 11     float he
--[ 2022.10.25.15.11.47.764.0 ]--
r 11     float heu
--[ 2022.10.25.15.11.47.900.0 ]--
r 11     float heur
--[ 2022.10.25.15.11.48.459.0 ]--
r 11     float heuri
--[ 2022.10.25.15.11.48.526.0 ]--
r 11     float heuris
--[ 2022.10.25.15.11.48.624.0 ]--
r 11     float heurist
--[ 2022.10.25.15.11.48.710.0 ]--
r 11     float heuristi
--[ 2022.10.25.15.11.48.806.0 ]--
r 11     float heuristic
--[ 2022.10.25.15.11.49.350.0 ]--
r 11     float heuristic 
--[ 2022.10.25.15.11.49.456.0 ]--
r 11     float heuristic =
--[ 2022.10.25.15.11.49.537.0 ]--
r 11     float heuristic = 
--[ 2022.10.25.15.11.54.683.0 ]--
r 11     float heuristic = n
--[ 2022.10.25.15.11.55.476.0 ]--
r 11     float heuristic = 
--[ 2022.10.25.15.11.56.749.0 ]--
r 11     float heuristic = 0
--[ 2022.10.25.15.11.56.855.0 ]--
r 11     float heuristic = 0.
--[ 2022.10.25.15.11.56.953.0 ]--
r 11     float heuristic = 0.0
--[ 2022.10.25.15.11.57.730.0 ]--
r 11     float heuristic = 0.0;
--[ 2022.10.25.15.12.04.646.0 ]--
r 11     float heuristic = 0.;
--[ 2022.10.25.15.12.04.820.0 ]--
r 11     float heuristic = 0;
--[ 2022.10.25.15.12.12.593.0 ]--
+ 87         
--[ 2022.10.25.15.12.13.640.0 ]--
r 87         h
--[ 2022.10.25.15.12.13.747.0 ]--
r 87         he
--[ 2022.10.25.15.12.13.864.0 ]--
r 87         heu
--[ 2022.10.25.15.12.14.151.0 ]--
r 87         heuristic
--[ 2022.10.25.15.12.14.615.0 ]--
r 87         heuristic 
--[ 2022.10.25.15.12.14.726.0 ]--
r 87         heuristic =
--[ 2022.10.25.15.12.14.814.0 ]--
r 87         heuristic = 
--[ 2022.10.25.15.12.14.990.0 ]--
r 87         heuristic = v
--[ 2022.10.25.15.12.15.282.0 ]--
r 87         heuristic = v;
--[ 2022.10.25.15.12.19.700.0 ]--
r 91         return ;
--[ 2022.10.25.15.12.20.448.0 ]--
r 91         return h;
--[ 2022.10.25.15.12.20.586.0 ]--
r 91         return he;
--[ 2022.10.25.15.12.20.684.0 ]--
r 91         return heu;
--[ 2022.10.25.15.12.21.100.0 ]--
r 91         return heuristic;
--[ 2022.10.25.15.12.44.868.0 ]--
r 27             if (this.getCost(h) > that.getCost()) {
--[ 2022.10.25.15.12.45.000.0 ]--
r 27             if (this.getCost(he) > that.getCost()) {
--[ 2022.10.25.15.12.45.407.0 ]--
r 27             if (this.getCost(heuristic) > that.getCost()) {
--[ 2022.10.25.15.12.47.266.0 ]--
r 27             if (this.getCost(heuristic) > that.getCost(h)) {
--[ 2022.10.25.15.12.47.350.0 ]--
r 27             if (this.getCost(heuristic) > that.getCost(he)) {
--[ 2022.10.25.15.12.47.522.0 ]--
r 27             if (this.getCost(heuristic) > that.getCost(heuristic)) {
--[ 2022.10.25.15.12.49.085.0 ]--
r 30             else if (this.getCost() < that.getCost(h)) {
--[ 2022.10.25.15.12.49.168.0 ]--
r 30             else if (this.getCost() < that.getCost(he)) {
--[ 2022.10.25.15.12.49.295.0 ]--
r 30             else if (this.getCost() < that.getCost(heuristic)) {
--[ 2022.10.25.15.12.50.969.0 ]--
r 30             else if (this.getCost(h) < that.getCost(heuristic)) {
--[ 2022.10.25.15.12.51.048.0 ]--
r 30             else if (this.getCost(he) < that.getCost(heuristic)) {
--[ 2022.10.25.15.12.51.163.0 ]--
r 30             else if (this.getCost(heuristic) < that.getCost(heuristic)) {
--[ 2022.10.25.15.14.38.877.0 ]--
+ 44             
--[ 2022.10.25.15.14.39.435.0 ]--
r 44             i
--[ 2022.10.25.15.14.39.532.0 ]--
r 44             if
--[ 2022.10.25.15.14.39.689.0 ]--
r 44             if ()
--[ 2022.10.25.15.14.40.230.0 ]--
r 44             if (t)
--[ 2022.10.25.15.14.40.280.0 ]--
r 44             if (th)
--[ 2022.10.25.15.14.40.403.0 ]--
r 44             if (thi)
--[ 2022.10.25.15.14.40.427.0 ]--
r 44             if (this)
--[ 2022.10.25.15.14.40.596.0 ]--
r 44             if (this.)
--[ 2022.10.25.15.14.53.176.0 ]--
r 44             if (this.C)
--[ 2022.10.25.15.14.53.922.0 ]--
r 44             if (this.)
--[ 2022.10.25.15.14.54.175.0 ]--
r 44             if (this.l)
--[ 2022.10.25.15.14.54.349.0 ]--
r 44             if (this.lo)
--[ 2022.10.25.15.14.54.943.0 ]--
r 44             if (this.l)
--[ 2022.10.25.15.14.55.093.0 ]--
r 44             if (this.)
--[ 2022.10.25.15.14.55.258.0 ]--
r 44             if (this)
--[ 2022.10.25.15.14.55.398.0 ]--
r 44             if (thi)
--[ 2022.10.25.15.14.55.555.0 ]--
r 44             if (th)
--[ 2022.10.25.15.14.55.709.0 ]--
r 44             if (t)
--[ 2022.10.25.15.14.55.871.0 ]--
r 44             if ()
--[ 2022.10.25.15.14.56.037.0 ]--
r 44             if 
--[ 2022.10.25.15.14.56.202.0 ]--
r 44             if
--[ 2022.10.25.15.14.56.355.0 ]--
r 44             i
--[ 2022.10.25.15.14.56.497.0 ]--
r 44             
--[ 2022.10.25.15.14.57.052.0 ]--
- 44
--[ 2022.10.25.15.15.34.823.0 ]--
+ 57         public void use() { 
r 58         }
--[ 2022.10.25.15.15.34.840.0 ]--
+ 58             
--[ 2022.10.25.15.15.39.648.0 ]--
r 58             p
--[ 2022.10.25.15.15.39.773.0 ]--
r 58             pF
--[ 2022.10.25.15.15.40.298.0 ]--
r 58             p
--[ 2022.10.25.15.15.40.466.0 ]--
r 58             
--[ 2022.10.25.15.15.40.657.0 ]--
r 58             P
--[ 2022.10.25.15.15.41.311.0 ]--
r 58             Pf
--[ 2022.10.25.15.15.41.742.0 ]--
r 58             P
--[ 2022.10.25.15.15.41.801.0 ]--
r 58             PF
--[ 2022.10.25.15.15.42.270.0 ]--
r 58             PFNode
--[ 2022.10.25.15.15.43.441.0 ]--
r 58             PFNode.
--[ 2022.10.25.15.15.44.642.0 ]--
r 58             PFNode
--[ 2022.10.25.15.15.45.540.0 ]--
r 58             PFNod
--[ 2022.10.25.15.15.45.690.0 ]--
r 58             PFNo
--[ 2022.10.25.15.15.45.860.0 ]--
r 58             PFN
--[ 2022.10.25.15.15.45.985.0 ]--
r 58             PF
--[ 2022.10.25.15.15.46.152.0 ]--
r 58             P
--[ 2022.10.25.15.15.46.309.0 ]--
r 58             
--[ 2022.10.25.15.15.46.752.0 ]--
- 57
r 57         public void use() {
--[ 2022.10.25.15.15.47.523.0 ]--
+ 58             
--[ 2022.10.25.15.15.47.858.0 ]--
r 58             t
--[ 2022.10.25.15.15.47.900.0 ]--
r 58             th
--[ 2022.10.25.15.15.48.230.0 ]--
r 58             thi
--[ 2022.10.25.15.15.48.337.0 ]--
r 58             this
--[ 2022.10.25.15.15.48.507.0 ]--
r 58             this.
--[ 2022.10.25.15.15.49.013.0 ]--
r 58             this.d
--[ 2022.10.25.15.15.49.169.0 ]--
r 58             this.de
--[ 2022.10.25.15.15.49.880.0 ]--
r 58             this.d
--[ 2022.10.25.15.15.50.059.0 ]--
r 58             this.
--[ 2022.10.25.15.15.50.226.0 ]--
r 58             this
--[ 2022.10.25.15.15.50.343.0 ]--
r 58             thi
--[ 2022.10.25.15.15.50.505.0 ]--
r 58             th
--[ 2022.10.25.15.15.50.664.0 ]--
r 58             t
--[ 2022.10.25.15.15.50.829.0 ]--
r 58             
--[ 2022.10.25.15.15.51.174.0 ]--
- 58
--[ 2022.10.25.15.15.55.220.0 ]--
+ 10     
--[ 2022.10.25.15.15.59.371.0 ]--
r 10     P
--[ 2022.10.25.15.16.00.083.0 ]--
r 10     PQ
--[ 2022.10.25.15.16.14.953.0 ]--
r 10     P
--[ 2022.10.25.15.16.15.083.0 ]--
r 10     
--[ 2022.10.25.15.16.15.388.0 ]--
- 10
--[ 2022.10.25.15.16.28.762.0 ]--
+ 23         public PFNode(Coord loc, PFNode fromNode) { 
r 24         }
--[ 2022.10.25.15.16.28.783.0 ]--
+ 24             
--[ 2022.10.25.15.16.30.404.0 ]--
r 24             t
--[ 2022.10.25.15.16.30.473.0 ]--
r 24             th
--[ 2022.10.25.15.16.30.576.0 ]--
r 24             thi
--[ 2022.10.25.15.16.30.638.0 ]--
r 24             this
--[ 2022.10.25.15.16.30.801.0 ]--
r 24             this.
--[ 2022.10.25.15.16.32.940.0 ]--
r 24             this.l
--[ 2022.10.25.15.16.33.080.0 ]--
r 24             this.lo
--[ 2022.10.25.15.16.33.191.0 ]--
r 24             this.loc
--[ 2022.10.25.15.16.33.408.0 ]--
r 24             this.loc 
--[ 2022.10.25.15.16.33.513.0 ]--
r 24             this.loc =
--[ 2022.10.25.15.16.33.624.0 ]--
r 24             this.loc = 
--[ 2022.10.25.15.16.35.106.0 ]--
r 24             this.loc = l
--[ 2022.10.25.15.16.35.244.0 ]--
r 24             this.loc = lo
--[ 2022.10.25.15.16.35.423.0 ]--
r 24             this.loc = loc
--[ 2022.10.25.15.16.39.030.0 ]--
r 24             this.loc = loc;
--[ 2022.10.25.15.16.44.296.0 ]--
r 24             this.p = loc;
--[ 2022.10.25.15.16.44.388.0 ]--
r 24             this.po = loc;
--[ 2022.10.25.15.16.44.440.0 ]--
r 24             this.pos = loc;
--[ 2022.10.25.15.16.44.894.0 ]--
r 24             this.posi = loc;
--[ 2022.10.25.15.16.45.005.0 ]--
r 24             this.posit = loc;
--[ 2022.10.25.15.16.45.075.0 ]--
r 24             this.positi = loc;
--[ 2022.10.25.15.16.45.159.0 ]--
r 24             this.positio = loc;
--[ 2022.10.25.15.16.45.248.0 ]--
r 24             this.position = loc;
--[ 2022.10.25.15.16.49.429.0 ]--
r 24           
--[ 2022.10.25.15.16.49.588.0 ]--
- 23
r 23         public PFNode(Coord loc, PFNode fromNode) {
--[ 2022.10.25.15.17.45.284.0 ]--
+ 40             
--[ 2022.10.25.15.17.46.144.0 ]--
r 40             t
--[ 2022.10.25.15.17.46.217.0 ]--
r 40             th
--[ 2022.10.25.15.17.46.320.0 ]--
r 40             thi
--[ 2022.10.25.15.17.46.349.0 ]--
r 40             this
--[ 2022.10.25.15.17.46.565.0 ]--
r 40             this.
--[ 2022.10.25.15.17.47.944.0 ]--
r 40             this.getCost
--[ 2022.10.25.15.17.47.951.0 ]--
r 40             this.getCost()
--[ 2022.10.25.15.17.48.823.0 ]--
r 40             this.getCost(h)
--[ 2022.10.25.15.17.48.952.0 ]--
r 40             this.getCost(he)
--[ 2022.10.25.15.17.49.298.0 ]--
r 40             this.getCost(heuristic)
--[ 2022.10.25.15.17.57.945.0 ]--
r 40             cthis.getCost(heuristic)
--[ 2022.10.25.15.17.58.014.0 ]--
r 40             cothis.getCost(heuristic)
--[ 2022.10.25.15.17.58.063.0 ]--
r 40             costhis.getCost(heuristic)
--[ 2022.10.25.15.17.58.226.0 ]--
r 40             costthis.getCost(heuristic)
--[ 2022.10.25.15.17.58.330.0 ]--
r 40             cost this.getCost(heuristic)
--[ 2022.10.25.15.17.58.437.0 ]--
r 40             cost =this.getCost(heuristic)
--[ 2022.10.25.15.17.58.525.0 ]--
r 40             cost = this.getCost(heuristic)
--[ 2022.10.25.15.18.01.656.0 ]--
r 40             fcost = this.getCost(heuristic)
--[ 2022.10.25.15.18.01.937.0 ]--
r 40             flcost = this.getCost(heuristic)
--[ 2022.10.25.15.18.02.121.0 ]--
r 40             flocost = this.getCost(heuristic)
--[ 2022.10.25.15.18.02.175.0 ]--
r 40             floacost = this.getCost(heuristic)
--[ 2022.10.25.15.18.02.278.0 ]--
r 40             floatcost = this.getCost(heuristic)
--[ 2022.10.25.15.18.02.393.0 ]--
r 40             float cost = this.getCost(heuristic)
--[ 2022.10.25.15.18.04.612.0 ]--
r 40             float cost = this.getCost(heuristic);
--[ 2022.10.25.15.18.09.699.0 ]--
+ 41             
--[ 2022.10.25.15.18.10.700.0 ]--
r 41             t
--[ 2022.10.25.15.18.10.735.0 ]--
r 41             th
--[ 2022.10.25.15.18.10.851.0 ]--
r 41             thi
--[ 2022.10.25.15.18.10.924.0 ]--
r 41             this
--[ 2022.10.25.15.18.11.094.0 ]--
r 41             this.
--[ 2022.10.25.15.18.11.474.0 ]--
r 41             this.d
--[ 2022.10.25.15.18.11.624.0 ]--
r 41             this.di
--[ 2022.10.25.15.18.11.711.0 ]--
r 41             this.dis
--[ 2022.10.25.15.18.12.493.0 ]--
r 41             this.di
--[ 2022.10.25.15.18.12.625.0 ]--
r 41             this.d
--[ 2022.10.25.15.18.12.793.0 ]--
r 41             this.
--[ 2022.10.25.15.18.13.075.0 ]--
r 41             this.d
--[ 2022.10.25.15.18.13.154.0 ]--
r 41             this.di
--[ 2022.10.25.15.18.13.597.0 ]--
r 41             this.d
--[ 2022.10.25.15.18.13.752.0 ]--
r 41             this.
--[ 2022.10.25.15.18.13.911.0 ]--
r 41             this
--[ 2022.10.25.15.18.14.078.0 ]--
r 41             thi
--[ 2022.10.25.15.18.14.234.0 ]--
r 41             th
--[ 2022.10.25.15.18.14.411.0 ]--
r 41             t
--[ 2022.10.25.15.18.14.547.0 ]--
r 41             
--[ 2022.10.25.15.18.14.699.0 ]--
r 41             d
--[ 2022.10.25.15.18.14.749.0 ]--
r 41             di
--[ 2022.10.25.15.18.14.941.0 ]--
r 41             dis
--[ 2022.10.25.15.18.15.474.0 ]--
r 41             di
--[ 2022.10.25.15.18.15.658.0 ]--
r 41             d
--[ 2022.10.25.15.18.15.813.0 ]--
r 41             
--[ 2022.10.25.15.18.15.988.0 ]--
- 41
--[ 2022.10.25.15.18.21.076.0 ]--
r 40             
--[ 2022.10.25.15.18.21.327.0 ]--
- 40
--[ 2022.10.25.15.19.26.510.0 ]--
+ 10     
--[ 2022.10.25.15.19.26.989.0 ]--
r 10     M
--[ 2022.10.25.15.19.27.347.0 ]--
r 10     Mi
--[ 2022.10.25.15.19.27.436.0 ]--
r 10     Min
--[ 2022.10.25.15.19.31.253.0 ]--
r 10     MinPQ
--[ 2022.10.25.15.19.51.921.0 ]--
r 10     MinP
--[ 2022.10.25.15.19.52.075.0 ]--
r 10     Min
--[ 2022.10.25.15.19.52.218.0 ]--
r 10     Mi
--[ 2022.10.25.15.19.52.369.0 ]--
r 10     M
--[ 2022.10.25.15.19.52.532.0 ]--
r 10     
--[ 2022.10.25.15.19.52.677.0 ]--
- 10
--[ 2022.10.27.09.31.34.289.0 ]--
+ 10     
--[ 2022.10.27.09.31.35.352.0 ]--
r 10     M
--[ 2022.10.27.09.31.35.576.0 ]--
r 10     Mi
--[ 2022.10.27.09.31.35.593.0 ]--
r 10     Min
--[ 2022.10.27.09.31.36.395.0 ]--
r 10     MinPQ
--[ 2022.10.27.09.31.37.855.0 ]--
r 10     MinPQ<>
--[ 2022.10.27.09.31.45.047.0 ]--
r 10     MinPQ<f>
--[ 2022.10.27.09.31.45.078.0 ]--
r 10     MinPQ<fl>
--[ 2022.10.27.09.31.45.280.0 ]--
r 10     MinPQ<flo>
--[ 2022.10.27.09.31.45.328.0 ]--
r 10     MinPQ<floa>
--[ 2022.10.27.09.31.45.474.0 ]--
r 10     MinPQ<float>
--[ 2022.10.27.09.31.48.338.0 ]--
r 10     MinPQ<float> 
--[ 2022.10.27.09.31.51.513.0 ]--
r 10     MinPQ<float> s
--[ 2022.10.27.09.31.51.669.0 ]--
r 10     MinPQ<float> st
--[ 2022.10.27.09.31.51.743.0 ]--
r 10     MinPQ<float> sta
--[ 2022.10.27.09.31.51.928.0 ]--
r 10     MinPQ<float> stac
--[ 2022.10.27.09.31.52.039.0 ]--
r 10     MinPQ<float> stack
--[ 2022.10.27.09.31.52.280.0 ]--
r 10     MinPQ<float> stack 
--[ 2022.10.27.09.31.52.499.0 ]--
r 10     MinPQ<float> stack =
--[ 2022.10.27.09.31.52.599.0 ]--
r 10     MinPQ<float> stack = 
--[ 2022.10.27.09.31.53.378.0 ]--
r 10     MinPQ<float> stack = M
--[ 2022.10.27.09.31.53.842.0 ]--
r 10     MinPQ<float> stack = Mi
--[ 2022.10.27.09.31.53.893.0 ]--
r 10     MinPQ<float> stack = Min
--[ 2022.10.27.09.31.54.414.0 ]--
r 10     MinPQ<float> stack = MinPQ
--[ 2022.10.27.09.31.56.640.0 ]--
r 10     MinPQ<float> stack = MinPQ>
--[ 2022.10.27.09.31.57.980.0 ]--
r 10     MinPQ<float> stack = MinPQ
--[ 2022.10.27.09.31.58.359.0 ]--
r 10     MinPQ<float> stack = MinPQ<>
--[ 2022.10.27.09.31.59.329.0 ]--
r 10     MinPQ<float> stack = MinPQ<>;
--[ 2022.10.27.09.32.04.017.0 ]--
r 10     MinPQ<float> stack = MinPQ<f>;
--[ 2022.10.27.09.32.04.277.0 ]--
r 10     MinPQ<float> stack = MinPQ<fl>;
--[ 2022.10.27.09.32.04.450.0 ]--
r 10     MinPQ<float> stack = MinPQ<flo>;
--[ 2022.10.27.09.32.04.507.0 ]--
r 10     MinPQ<float> stack = MinPQ<floa>;
--[ 2022.10.27.09.32.04.607.0 ]--
r 10     MinPQ<float> stack = MinPQ<float>;
--[ 2022.10.27.09.32.07.097.0 ]--
r 10     MinPQ<float> stack = MinPQ<floa>;
--[ 2022.10.27.09.32.07.282.0 ]--
r 10     MinPQ<float> stack = MinPQ<flo>;
--[ 2022.10.27.09.32.07.443.0 ]--
r 10     MinPQ<float> stack = MinPQ<fl>;
--[ 2022.10.27.09.32.07.618.0 ]--
r 10     MinPQ<float> stack = MinPQ<f>;
--[ 2022.10.27.09.32.07.799.0 ]--
r 10     MinPQ<float> stack = MinPQ<>;
--[ 2022.10.27.09.32.09.384.0 ]--
r 10     MinPQ<float> stack = MinPQ<d>;
--[ 2022.10.27.09.32.10.091.0 ]--
r 10     MinPQ<float> stack = MinPQ<>;
--[ 2022.10.27.09.32.10.194.0 ]--
r 10     MinPQ<float> stack = MinPQ<D>;
--[ 2022.10.27.09.32.10.492.0 ]--
r 10     MinPQ<float> stack = MinPQ<Db>;
--[ 2022.10.27.09.32.11.501.0 ]--
r 10     MinPQ<float> stack = MinPQ<D>;
--[ 2022.10.27.09.32.11.643.0 ]--
r 10     MinPQ<float> stack = MinPQ<Do>;
--[ 2022.10.27.09.32.11.719.0 ]--
r 10     MinPQ<float> stack = MinPQ<Dou>;
--[ 2022.10.27.09.32.11.817.0 ]--
r 10     MinPQ<float> stack = MinPQ<Doub>;
--[ 2022.10.27.09.32.12.092.0 ]--
r 10     MinPQ<float> stack = MinPQ<Doube>;
--[ 2022.10.27.09.32.12.493.0 ]--
r 10     MinPQ<float> stack = MinPQ<Doub>;
--[ 2022.10.27.09.32.12.687.0 ]--
r 10     MinPQ<float> stack = MinPQ<Doubl>;
--[ 2022.10.27.09.32.12.789.0 ]--
r 10     MinPQ<float> stack = MinPQ<Double>;
--[ 2022.10.27.09.32.14.962.0 ]--
r 10     MinPQ<float> stack = MinPQ<Doubl>;
--[ 2022.10.27.09.32.15.131.0 ]--
r 10     MinPQ<float> stack = MinPQ<Doub>;
--[ 2022.10.27.09.32.15.304.0 ]--
r 10     MinPQ<float> stack = MinPQ<Dou>;
--[ 2022.10.27.09.32.15.481.0 ]--
r 10     MinPQ<float> stack = MinPQ<Do>;
--[ 2022.10.27.09.32.15.654.0 ]--
r 10     MinPQ<float> stack = MinPQ<D>;
--[ 2022.10.27.09.32.15.856.0 ]--
r 10     MinPQ<float> stack = MinPQ<>;
--[ 2022.10.27.09.32.44.609.0 ]--
r 10     MinPQ<P> stack = MinPQ<>;
--[ 2022.10.27.09.32.44.905.0 ]--
r 10     MinPQ<Pf> stack = MinPQ<>;
--[ 2022.10.27.09.32.45.543.0 ]--
r 10     MinPQ<PFNode> stack = MinPQ<>;
--[ 2022.10.27.09.32.49.679.0 ]--
r 10     MinPQ<PFNode> stack = MinPQ<P>;
--[ 2022.10.27.09.32.49.894.0 ]--
r 10     MinPQ<PFNode> stack = MinPQ<PF>;
--[ 2022.10.27.09.32.50.555.0 ]--
r 10     MinPQ<PFNode> stack = MinPQ<PFNode>;
--[ 2022.10.27.09.33.05.982.0 ]--
r 10     
--[ 2022.10.27.09.34.17.971.0 ]--
r 10     MinPQ<PFNode> stack = MinPQ<PFNode>;
--[ 2022.10.27.09.34.20.229.0 ]--
r 10     MinPQ<PFNode> stack =  MinPQ<PFNode>;
--[ 2022.10.27.09.34.20.291.0 ]--
r 10     MinPQ<PFNode> stack =  nMinPQ<PFNode>;
--[ 2022.10.27.09.34.20.612.0 ]--
r 10     MinPQ<PFNode> stack =  neMinPQ<PFNode>;
--[ 2022.10.27.09.34.21.008.0 ]--
r 10     MinPQ<PFNode> stack =  nMinPQ<PFNode>;
--[ 2022.10.27.09.34.21.142.0 ]--
r 10     MinPQ<PFNode> stack =  MinPQ<PFNode>;
--[ 2022.10.27.09.34.21.314.0 ]--
r 10     MinPQ<PFNode> stack = MinPQ<PFNode>;
--[ 2022.10.27.09.34.21.660.0 ]--
r 10     MinPQ<PFNode> stack = nMinPQ<PFNode>;
--[ 2022.10.27.09.34.21.757.0 ]--
r 10     MinPQ<PFNode> stack = neMinPQ<PFNode>;
--[ 2022.10.27.09.34.21.851.0 ]--
r 10     MinPQ<PFNode> stack = newMinPQ<PFNode>;
--[ 2022.10.27.09.34.21.972.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode>;
--[ 2022.10.27.09.34.33.223.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<>;
--[ 2022.10.27.09.34.34.312.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ;
--[ 2022.10.27.09.34.35.045.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ();
--[ 2022.10.27.09.34.53.819.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<>();
--[ 2022.10.27.09.34.55.019.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<P>();
--[ 2022.10.27.09.34.55.213.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PF>();
--[ 2022.10.27.09.34.55.741.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFN>();
--[ 2022.10.27.09.34.56.525.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PF>();
--[ 2022.10.27.09.34.57.742.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFN>();
--[ 2022.10.27.09.34.58.041.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNo>();
--[ 2022.10.27.09.34.58.158.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNod>();
--[ 2022.10.27.09.34.58.330.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode>();
--[ 2022.10.27.09.35.00.506.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<Pathfinder.PFNode>();
--[ 2022.10.27.09.35.00.513.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode>();
--[ 2022.10.31.10.37.39.955.0 ]--
DisposeComponent
--[ 2022.11.01.10.57.58.806.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.01.10.57.59.060.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2022.11.01.10.57.59.061.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.01.10.57.59.063.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> stack = new MinPQ<PFNode>();
    Coord start, end = null;
    float heuristic = 0;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        public PFNode(Coord loc, PFNode fromNode) {
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.getCost(heuristic) > that.getCost(heuristic)) {
                return 1;
            }
            else if (this.getCost(heuristic) < that.getCost(heuristic)) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            return 0;
        }

        // returns if this PFNode is still valid
        public boolean isValid() {
            return false;
        }

        // invalidates the PFNode
        public void invalidate() {
        }

        // returns if the PFNode has been used
        public boolean isUsed() {
            return true;
        }

        // uses the PFNode
        public void use() {
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() {
        return null;
    }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
    }

    public void computePath() {
    }

    public boolean foundPath() {
        return false;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }
}

--[ 2022.11.01.10.57.59.063.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.01.10.57.59.063.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[2];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.01.10.57.59.064.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.01.10.57.59.064.1 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.01.10.57.59.064.2 ]--
InitFile: /.cos265


--[ 2022.11.01.10.57.59.064.3 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.01.10.57.59.065.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2022.11.01.10.58.58.865.0 ]--
:/src/Pathfinder.java
r 12 
--[ 2022.11.01.10.58.58.950.0 ]--
- 12
--[ 2022.11.01.10.59.03.177.0 ]--
+ 12 
--[ 2022.11.01.10.59.04.648.0 ]--
r 12     float heuristic = 0;
--[ 2022.11.01.10.59.07.346.0 ]--
r 12     float heuristic = ;
--[ 2022.11.01.10.59.07.495.0 ]--
r 12     float heuristic =;
--[ 2022.11.01.10.59.07.661.0 ]--
r 12     float heuristic ;
--[ 2022.11.01.10.59.08.044.0 ]--
r 12     float heuristic;
--[ 2022.11.01.10.59.57.675.0 ]--
- 119
r 119     public boolean wasSearched(Coord loc) {return false;
--[ 2022.11.01.11.05.58.371.0 ]--
+ 25             
--[ 2022.11.01.11.27.11.753.0 ]--
r 25             /
--[ 2022.11.01.11.27.11.789.0 ]--
r 25             //
--[ 2022.11.01.11.27.13.511.0 ]--
r 25             // 
--[ 2022.11.01.11.27.13.626.0 ]--
r 25             // p
--[ 2022.11.01.11.27.13.699.0 ]--
r 25             // po
--[ 2022.11.01.11.27.13.823.0 ]--
r 25             // pos
--[ 2022.11.01.11.27.13.982.0 ]--
r 25             // posi
--[ 2022.11.01.11.27.14.530.0 ]--
r 25             // posit
--[ 2022.11.01.11.27.14.589.0 ]--
r 25             // positi
--[ 2022.11.01.11.27.14.670.0 ]--
r 25             // positio
--[ 2022.11.01.11.27.14.782.0 ]--
r 25             // position
--[ 2022.11.01.11.27.15.150.0 ]--
r 25             // positio
--[ 2022.11.01.11.27.15.639.0 ]--
r 25             // positi
--[ 2022.11.01.11.27.15.723.0 ]--
r 25             // posit
--[ 2022.11.01.11.27.15.806.0 ]--
r 25             // posi
--[ 2022.11.01.11.27.15.890.0 ]--
r 25             // pos
--[ 2022.11.01.11.27.15.973.0 ]--
r 25             // po
--[ 2022.11.01.11.27.16.058.0 ]--
r 25             // p
--[ 2022.11.01.11.27.16.141.0 ]--
r 25             // 
--[ 2022.11.01.11.27.16.226.0 ]--
r 25             //
--[ 2022.11.01.11.27.16.309.0 ]--
r 25             /
--[ 2022.11.01.11.27.16.588.0 ]--
r 25             
--[ 2022.11.01.11.27.28.483.0 ]--
r 25             c
--[ 2022.11.01.11.27.28.581.0 ]--
r 25             cu
--[ 2022.11.01.11.27.28.643.0 ]--
r 25             cur
--[ 2022.11.01.11.27.28.765.0 ]--
r 25             curr
--[ 2022.11.01.11.27.28.862.0 ]--
r 25             curre
--[ 2022.11.01.11.27.29.006.0 ]--
r 25             curren
--[ 2022.11.01.11.27.29.083.0 ]--
r 25             current
--[ 2022.11.01.11.27.30.128.0 ]--
r 25             currentT
--[ 2022.11.01.11.27.30.300.0 ]--
r 25             currentTi
--[ 2022.11.01.11.27.30.410.0 ]--
r 25             currentTil
--[ 2022.11.01.11.27.30.441.0 ]--
r 25             currentTile
--[ 2022.11.01.11.27.32.937.0 ]--
r 25             currentTile 
--[ 2022.11.01.11.27.33.059.0 ]--
r 25             currentTile =
--[ 2022.11.01.11.27.33.152.0 ]--
r 25             currentTile = 
--[ 2022.11.01.11.27.33.539.0 ]--
r 25             currentTile = l
--[ 2022.11.01.11.27.33.710.0 ]--
r 25             currentTile = lo
--[ 2022.11.01.11.27.33.806.0 ]--
r 25             currentTile = loc
--[ 2022.11.01.11.27.38.010.0 ]--
r 25             CcurrentTile = loc
--[ 2022.11.01.11.27.38.206.0 ]--
r 25             CocurrentTile = loc
--[ 2022.11.01.11.27.38.326.0 ]--
r 25             CoocurrentTile = loc
--[ 2022.11.01.11.27.38.433.0 ]--
r 25             CoorcurrentTile = loc
--[ 2022.11.01.11.27.38.703.0 ]--
r 25             CoordcurrentTile = loc
--[ 2022.11.01.11.27.38.872.0 ]--
r 25             Coord currentTile = loc
--[ 2022.11.01.11.27.41.136.0 ]--
r 25             Coord currentTile = loc;
--[ 2022.11.01.11.27.42.386.0 ]--
+ 26             
--[ 2022.11.01.11.27.43.614.0 ]--
r 26             p
--[ 2022.11.01.11.27.43.736.0 ]--
r 26             pr
--[ 2022.11.01.11.27.43.797.0 ]--
r 26             pre
--[ 2022.11.01.11.27.43.972.0 ]--
r 26             prev
--[ 2022.11.01.11.27.45.241.0 ]--
r 26             prevN
--[ 2022.11.01.11.27.45.340.0 ]--
r 26             prevNo
--[ 2022.11.01.11.27.45.455.0 ]--
r 26             prevNod
--[ 2022.11.01.11.27.45.612.0 ]--
r 26             prevNode
--[ 2022.11.01.11.27.45.758.0 ]--
r 26             prevNode 
--[ 2022.11.01.11.27.45.918.0 ]--
r 26             prevNode =
--[ 2022.11.01.11.27.46.018.0 ]--
r 26             prevNode = 
--[ 2022.11.01.11.27.48.138.0 ]--
r 26             prevNode = r
--[ 2022.11.01.11.27.48.438.0 ]--
r 26             prevNode = 
--[ 2022.11.01.11.27.48.523.0 ]--
r 26             prevNode = f
--[ 2022.11.01.11.27.48.686.0 ]--
r 26             prevNode = fr
--[ 2022.11.01.11.27.48.760.0 ]--
r 26             prevNode = fro
--[ 2022.11.01.11.27.48.852.0 ]--
r 26             prevNode = from
--[ 2022.11.01.11.27.49.242.0 ]--
r 26             prevNode = fromN
--[ 2022.11.01.11.27.49.344.0 ]--
r 26             prevNode = fromNo
--[ 2022.11.01.11.27.49.406.0 ]--
r 26             prevNode = fromNod
--[ 2022.11.01.11.27.49.545.0 ]--
r 26             prevNode = fromNode
--[ 2022.11.01.11.27.50.448.0 ]--
r 26             prevNode = fromNode;
--[ 2022.11.01.11.27.52.743.0 ]--
r 26             PprevNode = fromNode;
--[ 2022.11.01.11.27.52.848.0 ]--
r 26             PFprevNode = fromNode;
--[ 2022.11.01.11.27.53.761.0 ]--
r 26             PFNodeprevNode = fromNode;
--[ 2022.11.01.11.27.53.778.0 ]--
r 26             PFNode prevNode = fromNode;
--[ 2022.11.01.11.27.53.785.0 ]--
r 26             PFNodeprevNode = fromNode;
--[ 2022.11.01.11.27.54.305.0 ]--
r 26             PFNode prevNode = fromNode;
--[ 2022.11.01.11.27.57.869.0 ]--
+ 27             
--[ 2022.11.01.11.28.00.146.0 ]--
r 27             d
--[ 2022.11.01.11.28.00.286.0 ]--
r 27             di
--[ 2022.11.01.11.28.00.348.0 ]--
r 27             dis
--[ 2022.11.01.11.28.00.473.0 ]--
r 27             dist
--[ 2022.11.01.11.28.00.583.0 ]--
r 27             dista
--[ 2022.11.01.11.28.00.712.0 ]--
r 27             distan
--[ 2022.11.01.11.28.00.802.0 ]--
r 27             distanc
--[ 2022.11.01.11.28.00.975.0 ]--
r 27             distance
--[ 2022.11.01.11.28.01.796.0 ]--
r 27             distanc
--[ 2022.11.01.11.28.01.964.0 ]--
r 27             distan
--[ 2022.11.01.11.28.02.135.0 ]--
r 27             dista
--[ 2022.11.01.11.28.02.307.0 ]--
r 27             dist
--[ 2022.11.01.11.28.02.474.0 ]--
r 27             dis
--[ 2022.11.01.11.28.02.653.0 ]--
r 27             di
--[ 2022.11.01.11.28.02.875.0 ]--
r 27             d
--[ 2022.11.01.11.28.03.162.0 ]--
r 27             
--[ 2022.11.01.11.28.05.068.0 ]--
r 27             f
--[ 2022.11.01.11.28.05.099.0 ]--
r 27             fl
--[ 2022.11.01.11.28.05.333.0 ]--
r 27             flo
--[ 2022.11.01.11.28.05.455.0 ]--
r 27             floa
--[ 2022.11.01.11.28.05.562.0 ]--
r 27             float
--[ 2022.11.01.11.28.05.806.0 ]--
r 27             float 
--[ 2022.11.01.11.28.06.376.0 ]--
r 27             float d
--[ 2022.11.01.11.28.06.464.0 ]--
r 27             float di
--[ 2022.11.01.11.28.06.558.0 ]--
r 27             float dis
--[ 2022.11.01.11.28.06.674.0 ]--
r 27             float dist
--[ 2022.11.01.11.28.06.809.0 ]--
r 27             float dista
--[ 2022.11.01.11.28.06.860.0 ]--
r 27             float distan
--[ 2022.11.01.11.28.07.046.0 ]--
r 27             float distanc
--[ 2022.11.01.11.28.07.204.0 ]--
r 27             float distance
--[ 2022.11.01.11.28.07.481.0 ]--
r 27             float distance 
--[ 2022.11.01.11.28.07.585.0 ]--
r 27             float distance =
--[ 2022.11.01.11.28.07.698.0 ]--
r 27             float distance = 
--[ 2022.11.01.11.28.08.391.0 ]--
r 27             float distance = f
--[ 2022.11.01.11.28.08.602.0 ]--
r 27             float distance = fr
--[ 2022.11.01.11.28.08.694.0 ]--
r 27             float distance = fro
--[ 2022.11.01.11.28.08.803.0 ]--
r 27             float distance = from
--[ 2022.11.01.11.28.09.598.0 ]--
r 27             float distance = fro
--[ 2022.11.01.11.28.09.754.0 ]--
r 27             float distance = fr
--[ 2022.11.01.11.28.09.919.0 ]--
r 27             float distance = f
--[ 2022.11.01.11.28.10.093.0 ]--
r 27             float distance = 
--[ 2022.11.01.11.28.10.783.0 ]--
r 27             float distance =
--[ 2022.11.01.11.28.10.955.0 ]--
r 27             float distance 
--[ 2022.11.01.11.28.11.127.0 ]--
r 27             float distance
--[ 2022.11.01.11.28.11.388.0 ]--
r 27             float distance;
--[ 2022.11.01.11.28.17.265.0 ]--
+ 27             
--[ 2022.11.01.11.28.18.624.0 ]--
r 27             c
--[ 2022.11.01.11.28.18.754.0 ]--
r 27             ca
--[ 2022.11.01.11.28.18.858.0 ]--
r 27             cal
--[ 2022.11.01.11.28.18.990.0 ]--
r 27             calc
--[ 2022.11.01.11.28.19.164.0 ]--
r 27             calcu
--[ 2022.11.01.11.28.19.654.0 ]--
r 27             calcul
--[ 2022.11.01.11.28.20.041.0 ]--
r 27             calcu
--[ 2022.11.01.11.28.20.207.0 ]--
r 27             calc
--[ 2022.11.01.11.28.20.368.0 ]--
r 27             cal
--[ 2022.11.01.11.28.20.528.0 ]--
r 27             ca
--[ 2022.11.01.11.28.20.691.0 ]--
r 27             c
--[ 2022.11.01.11.28.20.859.0 ]--
r 27             
--[ 2022.11.01.11.28.21.426.0 ]--
r 27             /
--[ 2022.11.01.11.28.21.667.0 ]--
r 27             //
--[ 2022.11.01.11.28.22.182.0 ]--
r 27             //c
--[ 2022.11.01.11.28.22.239.0 ]--
r 27             //ca
--[ 2022.11.01.11.28.22.337.0 ]--
r 27             //cal
--[ 2022.11.01.11.28.22.496.0 ]--
r 27             //calc
--[ 2022.11.01.11.28.24.325.0 ]--
r 27             //calcu
--[ 2022.11.01.11.28.24.441.0 ]--
r 27             //calcul
--[ 2022.11.01.11.28.24.513.0 ]--
r 27             //calcula
--[ 2022.11.01.11.28.24.629.0 ]--
r 27             //calculat
--[ 2022.11.01.11.28.24.747.0 ]--
r 27             //calculate
--[ 2022.11.01.11.28.24.845.0 ]--
r 27             //calculate 
--[ 2022.11.01.11.28.24.950.0 ]--
r 27             //calculate t
--[ 2022.11.01.11.28.25.042.0 ]--
r 27             //calculate th
--[ 2022.11.01.11.28.25.094.0 ]--
r 27             //calculate the
--[ 2022.11.01.11.28.25.180.0 ]--
r 27             //calculate the 
--[ 2022.11.01.11.28.26.697.0 ]--
r 27             //calculate the d
--[ 2022.11.01.11.28.26.778.0 ]--
r 27             //calculate the di
--[ 2022.11.01.11.28.26.864.0 ]--
r 27             //calculate the dis
--[ 2022.11.01.11.28.27.348.0 ]--
r 27             //calculate the dist
--[ 2022.11.01.11.28.27.479.0 ]--
r 27             //calculate the dista
--[ 2022.11.01.11.28.27.623.0 ]--
r 27             //calculate the distan
--[ 2022.11.01.11.28.27.713.0 ]--
r 27             //calculate the distanc
--[ 2022.11.01.11.28.27.872.0 ]--
r 27             //calculate the distance
--[ 2022.11.01.11.28.27.986.0 ]--
r 27             //calculate the distance 
--[ 2022.11.01.11.28.28.187.0 ]--
r 27             //calculate the distance c
--[ 2022.11.01.11.28.28.271.0 ]--
r 27             //calculate the distance co
--[ 2022.11.01.11.28.28.419.0 ]--
r 27             //calculate the distance cos
--[ 2022.11.01.11.28.28.961.0 ]--
r 27             //calculate the distance cost
--[ 2022.11.01.11.28.36.289.0 ]--
r 27             //calculate the distance cost 
--[ 2022.11.01.11.28.37.576.0 ]--
r 27             //calculate the distance cost :
--[ 2022.11.01.11.28.37.723.0 ]--
r 27             //calculate the distance cost ::
--[ 2022.11.01.11.28.38.080.0 ]--
r 27             //calculate the distance cost :: 
--[ 2022.11.01.11.28.38.506.0 ]--
r 27             //calculate the distance cost ::
--[ 2022.11.01.11.28.38.622.0 ]--
r 27             //calculate the distance cost ::g
--[ 2022.11.01.11.28.38.738.0 ]--
r 27             //calculate the distance cost ::ge
--[ 2022.11.01.11.28.38.865.0 ]--
r 27             //calculate the distance cost ::get
--[ 2022.11.01.11.28.39.244.0 ]--
r 27             //calculate the distance cost ::getC
--[ 2022.11.01.11.28.39.404.0 ]--
r 27             //calculate the distance cost ::getCo
--[ 2022.11.01.11.28.39.489.0 ]--
r 27             //calculate the distance cost ::getCos
--[ 2022.11.01.11.28.39.601.0 ]--
r 27             //calculate the distance cost ::getCost
--[ 2022.11.01.11.28.39.932.0 ]--
r 27             //calculate the distance cost ::getCost(
--[ 2022.11.01.11.28.40.022.0 ]--
r 27             //calculate the distance cost ::getCost()
--[ 2022.11.01.11.28.42.794.0 ]--
r 27             //calculate the distance cost ::getCost(h)
--[ 2022.11.01.11.28.42.989.0 ]--
r 27             //calculate the distance cost ::getCost(he)
--[ 2022.11.01.11.28.43.421.0 ]--
r 27             //calculate the distance cost ::getCost(heu)
--[ 2022.11.01.11.28.43.817.0 ]--
r 27             //calculate the distance cost ::getCost(heur)
--[ 2022.11.01.11.28.44.029.0 ]--
r 27             //calculate the distance cost ::getCost(heuri)
--[ 2022.11.01.11.28.44.294.0 ]--
r 27             //calculate the distance cost ::getCost(heuris)
--[ 2022.11.01.11.28.44.424.0 ]--
r 27             //calculate the distance cost ::getCost(heurist)
--[ 2022.11.01.11.28.44.522.0 ]--
r 27             //calculate the distance cost ::getCost(heuristi)
--[ 2022.11.01.11.28.44.623.0 ]--
r 27             //calculate the distance cost ::getCost(heuristic)
--[ 2022.11.01.14.05.29.134.0 ]--
+ 75         
--[ 2022.11.01.14.05.34.533.0 ]--
r 75         r
--[ 2022.11.01.14.05.34.681.0 ]--
r 75         re
--[ 2022.11.01.14.05.34.796.0 ]--
r 75         ret
--[ 2022.11.01.14.05.34.941.0 ]--
r 75         retu
--[ 2022.11.01.14.05.35.104.0 ]--
r 75         retur
--[ 2022.11.01.14.05.35.197.0 ]--
r 75         return
--[ 2022.11.01.14.05.35.347.0 ]--
r 75         return 
--[ 2022.11.01.14.05.35.794.0 ]--
r 75         return n
--[ 2022.11.01.14.05.35.898.0 ]--
r 75         return ne
--[ 2022.11.01.14.05.35.986.0 ]--
r 75         return new
--[ 2022.11.01.14.05.37.075.0 ]--
r 75         return new 
--[ 2022.11.01.14.05.37.298.0 ]--
r 75         return new T
--[ 2022.11.01.14.05.37.473.0 ]--
r 75         return new Te
--[ 2022.11.01.14.05.37.600.0 ]--
r 75         return new Ter
--[ 2022.11.01.14.05.37.741.0 ]--
r 75         return new Terr
--[ 2022.11.01.14.05.38.531.0 ]--
r 75         return new Terrain
--[ 2022.11.01.14.05.38.550.0 ]--
r 75         return new Terrain()
--[ 2022.11.01.14.05.48.035.0 ]--
r 75         return new Terrain() 
--[ 2022.11.01.14.05.48.157.0 ]--
r 75         return new Terrain() =
--[ 2022.11.01.14.05.48.256.0 ]--
r 75         return new Terrain() = 
--[ 2022.11.01.14.05.49.165.0 ]--
r 75         return new Terrain() =
--[ 2022.11.01.14.05.49.326.0 ]--
r 75         return new Terrain() 
--[ 2022.11.01.14.05.49.813.0 ]--
r 75         return new Terrain()
--[ 2022.11.01.14.05.54.769.0 ]--
r 75         
--[ 2022.11.01.14.05.54.964.0 ]--
- 75
--[ 2022.11.01.14.06.02.298.0 ]--
r 82         return s;
--[ 2022.11.01.14.06.02.454.0 ]--
r 82         return st;
--[ 2022.11.01.14.06.02.565.0 ]--
r 82         return sta;
--[ 2022.11.01.14.06.02.672.0 ]--
r 82         return star;
--[ 2022.11.01.14.06.02.845.0 ]--
r 82         return start;
--[ 2022.11.01.14.09.00.252.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode,>();
--[ 2022.11.01.14.09.01.078.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode, >();
--[ 2022.11.01.14.09.02.406.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode, f>();
--[ 2022.11.01.14.09.02.514.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode, fl>();
--[ 2022.11.01.14.09.02.636.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode, flo>();
--[ 2022.11.01.14.09.02.676.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode, floa>();
--[ 2022.11.01.14.09.02.776.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode, float>();
--[ 2022.11.01.14.09.03.461.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode, floa>();
--[ 2022.11.01.14.09.03.629.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode, flo>();
--[ 2022.11.01.14.09.03.796.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode, fl>();
--[ 2022.11.01.14.09.03.953.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode, f>();
--[ 2022.11.01.14.09.04.102.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode, >();
--[ 2022.11.01.14.09.04.289.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode,>();
--[ 2022.11.01.14.09.04.552.0 ]--
r 10     MinPQ<PFNode> stack = new MinPQ<PFNode>();
--[ 2022.11.01.14.12.25.640.0 ]--
r 10     MinPQ<PFNode> p = new MinPQ<PFNode>();
--[ 2022.11.01.14.12.25.728.0 ]--
r 10     MinPQ<PFNode> pq = new MinPQ<PFNode>();
--[ 2022.11.01.14.17.23.169.0 ]--
+ 27             
--[ 2022.11.01.14.17.24.497.0 ]--
r 27             c
--[ 2022.11.01.14.17.24.640.0 ]--
r 27             co
--[ 2022.11.01.14.17.24.650.0 ]--
r 27             cos
--[ 2022.11.01.14.17.24.807.0 ]--
r 27             cost
--[ 2022.11.01.14.17.26.515.0 ]--
r 27             cost 
--[ 2022.11.01.14.17.26.730.0 ]--
r 27             cost
--[ 2022.11.01.14.17.26.899.0 ]--
r 27             cos
--[ 2022.11.01.14.17.27.068.0 ]--
r 27             co
--[ 2022.11.01.14.17.27.239.0 ]--
r 27             c
--[ 2022.11.01.14.17.27.597.0 ]--
r 27             
--[ 2022.11.01.14.17.27.790.0 ]--
r 27             f
--[ 2022.11.01.14.17.27.901.0 ]--
r 27             fl
--[ 2022.11.01.14.17.28.079.0 ]--
r 27             flo
--[ 2022.11.01.14.17.28.091.0 ]--
r 27             floa
--[ 2022.11.01.14.17.28.229.0 ]--
r 27             float
--[ 2022.11.01.14.17.28.344.0 ]--
r 27             float 
--[ 2022.11.01.14.17.28.703.0 ]--
r 27             float c
--[ 2022.11.01.14.17.28.776.0 ]--
r 27             float co
--[ 2022.11.01.14.17.28.869.0 ]--
r 27             float cos
--[ 2022.11.01.14.17.28.980.0 ]--
r 27             float cost
--[ 2022.11.01.14.17.29.110.0 ]--
r 27             float cost 
--[ 2022.11.01.14.17.29.299.0 ]--
r 27             float cost =
--[ 2022.11.01.14.17.29.423.0 ]--
r 27             float cost = 
--[ 2022.11.01.14.17.34.102.0 ]--
r 27             float cost = -
--[ 2022.11.01.14.17.34.233.0 ]--
r 27             float cost = -1
--[ 2022.11.01.14.17.34.595.0 ]--
r 27             float cost = -1;
--[ 2022.11.01.14.18.34.787.0 ]--
+ 46             
--[ 2022.11.01.14.18.35.272.0 ]--
+ 46             
--[ 2022.11.01.14.18.36.320.0 ]--
- 46
--[ 2022.11.01.14.18.50.131.0 ]--
r 29             
--[ 2022.11.01.14.18.50.348.0 ]--
- 29
--[ 2022.11.01.14.19.46.543.0 ]--
r 25              currentTile = loc;
--[ 2022.11.01.14.19.47.063.0 ]--
r 25             currentTile = loc;
--[ 2022.11.01.14.19.48.653.0 ]--
r 26              prevNode = fromNode;
--[ 2022.11.01.14.19.48.971.0 ]--
r 26             prevNode = fromNode;
--[ 2022.11.01.14.19.50.924.0 ]--
r 27              cost = -1;
--[ 2022.11.01.14.19.51.227.0 ]--
r 27             cost = -1;
--[ 2022.11.01.14.19.54.144.0 ]--
+ 24         
--[ 2022.11.01.14.19.57.307.0 ]--
r 24         C
--[ 2022.11.01.14.19.57.586.0 ]--
r 24         Coo
--[ 2022.11.01.14.19.57.665.0 ]--
r 24         Coor
--[ 2022.11.01.14.19.57.783.0 ]--
r 24         Coord
--[ 2022.11.01.14.19.58.010.0 ]--
r 24         Coord 
--[ 2022.11.01.14.19.58.817.0 ]--
r 24         Coord c
--[ 2022.11.01.14.19.58.898.0 ]--
r 24         Coord cu
--[ 2022.11.01.14.19.58.999.0 ]--
r 24         Coord cur
--[ 2022.11.01.14.19.59.122.0 ]--
r 24         Coord curr
--[ 2022.11.01.14.19.59.201.0 ]--
r 24         Coord curre
--[ 2022.11.01.14.19.59.301.0 ]--
r 24         Coord curren
--[ 2022.11.01.14.19.59.389.0 ]--
r 24         Coord current
--[ 2022.11.01.14.19.59.818.0 ]--
r 24         Coord currentT
--[ 2022.11.01.14.20.00.651.0 ]--
r 24         Coord currentTile
--[ 2022.11.01.14.20.01.491.0 ]--
r 24         Coord currentTile 
--[ 2022.11.01.14.20.01.650.0 ]--
r 24         Coord currentTile =
--[ 2022.11.01.14.20.02.085.0 ]--
r 24         Coord currentTile 
--[ 2022.11.01.14.20.02.425.0 ]--
r 24         Coord currentTile
--[ 2022.11.01.14.20.02.660.0 ]--
r 24         Coord currentTile;
--[ 2022.11.01.14.20.02.944.0 ]--
+ 25         
--[ 2022.11.01.14.20.05.285.0 ]--
r 25         P
--[ 2022.11.01.14.20.05.392.0 ]--
r 25         PF
--[ 2022.11.01.14.20.06.202.0 ]--
r 25         PFNode
--[ 2022.11.01.14.20.06.742.0 ]--
r 25         PFNode 
--[ 2022.11.01.14.20.07.457.0 ]--
r 25         PFNode p
--[ 2022.11.01.14.20.07.528.0 ]--
r 25         PFNode pr
--[ 2022.11.01.14.20.07.579.0 ]--
r 25         PFNode pre
--[ 2022.11.01.14.20.07.771.0 ]--
r 25         PFNode prev
--[ 2022.11.01.14.20.08.065.0 ]--
r 25         PFNode prevN
--[ 2022.11.01.14.20.08.211.0 ]--
r 25         PFNode prevNo
--[ 2022.11.01.14.20.08.437.0 ]--
r 25         PFNode prevNode
--[ 2022.11.01.14.20.08.815.0 ]--
r 25         PFNode prevNode;
--[ 2022.11.01.14.20.09.185.0 ]--
+ 26         
--[ 2022.11.01.14.20.10.000.0 ]--
r 26         c
--[ 2022.11.01.14.20.10.063.0 ]--
r 26         co
--[ 2022.11.01.14.20.10.175.0 ]--
r 26         cos
--[ 2022.11.01.14.20.10.250.0 ]--
r 26         cost
--[ 2022.11.01.14.20.10.678.0 ]--
r 26         cost 
--[ 2022.11.01.14.20.10.761.0 ]--
r 26         cost =
--[ 2022.11.01.14.20.10.865.0 ]--
r 26         cost = 
--[ 2022.11.01.14.20.12.223.0 ]--
r 26         cost = -
--[ 2022.11.01.14.20.12.279.0 ]--
r 26         cost = -1
--[ 2022.11.01.14.20.13.390.0 ]--
r 26         cost = -1;
--[ 2022.11.01.14.20.16.065.0 ]--
r 26         fcost = -1;
--[ 2022.11.01.14.20.16.151.0 ]--
r 26         flcost = -1;
--[ 2022.11.01.14.20.16.288.0 ]--
r 26         flacost = -1;
--[ 2022.11.01.14.20.16.328.0 ]--
r 26         flaocost = -1;
--[ 2022.11.01.14.20.16.485.0 ]--
r 26         flaotcost = -1;
--[ 2022.11.01.14.20.16.619.0 ]--
r 26         flaot cost = -1;
--[ 2022.11.01.14.20.18.354.0 ]--
r 30             cost = -1
--[ 2022.11.01.14.20.18.483.0 ]--
r 30             cost = -
--[ 2022.11.01.14.20.18.650.0 ]--
r 30             cost = 
--[ 2022.11.01.14.20.18.822.0 ]--
r 30             cost =
--[ 2022.11.01.14.20.19.000.0 ]--
r 30             cost 
--[ 2022.11.01.14.20.19.197.0 ]--
r 30             cost
--[ 2022.11.01.14.20.19.924.0 ]--
r 30             cost 
--[ 2022.11.01.14.20.19.978.0 ]--
r 30             cost =
--[ 2022.11.01.14.20.20.123.0 ]--
r 30             cost = 
--[ 2022.11.01.14.20.21.950.0 ]--
r 30             cost = g
--[ 2022.11.01.14.20.22.053.0 ]--
r 30             cost = ge
--[ 2022.11.01.14.20.22.168.0 ]--
r 30             cost = get
--[ 2022.11.01.14.20.24.809.0 ]--
r 30             cost = ge
--[ 2022.11.01.14.20.24.975.0 ]--
r 30             cost = g
--[ 2022.11.01.14.20.25.160.0 ]--
r 30             cost = 
--[ 2022.11.01.14.20.25.358.0 ]--
r 30             cost =
--[ 2022.11.01.14.20.26.109.0 ]--
r 30             cost 
--[ 2022.11.01.14.20.26.303.0 ]--
r 30             cost
--[ 2022.11.01.14.20.26.558.0 ]--
r 30             cos
--[ 2022.11.01.14.20.27.681.0 ]--
r 30             cost
--[ 2022.11.01.14.20.29.365.0 ]--
r 30             cost;
--[ 2022.11.01.14.20.33.020.0 ]--
r 48 
--[ 2022.11.01.14.21.07.795.0 ]--
r 26         flot cost = -1;
--[ 2022.11.01.14.21.08.302.0 ]--
r 26         flt cost = -1;
--[ 2022.11.01.14.21.09.308.0 ]--
r 26         flot cost = -1;
--[ 2022.11.01.14.21.09.401.0 ]--
r 26         float cost = -1;
--[ 2022.11.01.14.21.14.753.0 ]--
r 30             cost ;
--[ 2022.11.01.14.21.14.886.0 ]--
r 30             cost =;
--[ 2022.11.01.14.21.14.976.0 ]--
r 30             cost = ;
--[ 2022.11.01.14.21.17.558.0 ]--
r 30             cost = p;
--[ 2022.11.01.14.21.17.608.0 ]--
r 30             cost = pr;
--[ 2022.11.01.14.21.17.713.0 ]--
r 30             cost = pre;
--[ 2022.11.01.14.21.23.907.0 ]--
r 30             cost = prevNode;
--[ 2022.11.01.14.21.24.551.0 ]--
r 30             cost = prevNode.;
--[ 2022.11.01.14.21.25.958.0 ]--
r 30             cost = prevNode.cost;
--[ 2022.11.01.14.21.28.964.0 ]--
r 30             cost = prevNode.cost ;
--[ 2022.11.01.14.21.29.412.0 ]--
r 30             cost = prevNode.cost +;
--[ 2022.11.01.14.21.29.547.0 ]--
r 30             cost = prevNode.cost + ;
--[ 2022.11.01.14.22.31.647.0 ]--
r 30             cost = 
--[ 2022.11.01.14.22.34.870.0 ]--
r 30             cost = c
--[ 2022.11.01.14.22.34.976.0 ]--
r 30             cost = co
--[ 2022.11.01.14.22.35.066.0 ]--
r 30             cost = com
--[ 2022.11.01.14.22.35.135.0 ]--
r 30             cost = comp
--[ 2022.11.01.14.22.35.862.0 ]--
r 30             cost = com
--[ 2022.11.01.14.22.36.033.0 ]--
r 30             cost = co
--[ 2022.11.01.14.22.36.187.0 ]--
r 30             cost = c
--[ 2022.11.01.14.22.36.357.0 ]--
r 30             cost = 
--[ 2022.11.01.14.22.36.714.0 ]--
r 30             cost = T
--[ 2022.11.01.14.22.36.941.0 ]--
r 30             cost = Te
--[ 2022.11.01.14.22.36.980.0 ]--
r 30             cost = Ter
--[ 2022.11.01.14.22.38.002.0 ]--
r 30             cost = Terr
--[ 2022.11.01.14.22.38.092.0 ]--
r 30             cost = Terra
--[ 2022.11.01.14.22.38.179.0 ]--
r 30             cost = Terrai
--[ 2022.11.01.14.22.38.250.0 ]--
r 30             cost = Terrain
--[ 2022.11.01.14.22.38.463.0 ]--
r 30             cost = Terrain.
--[ 2022.11.01.14.22.38.848.0 ]--
r 30             cost = Terrain.c
--[ 2022.11.01.14.22.38.910.0 ]--
r 30             cost = Terrain.co
--[ 2022.11.01.14.22.38.992.0 ]--
r 30             cost = Terrain.com
--[ 2022.11.01.14.22.39.104.0 ]--
r 30             cost = Terrain.comp
--[ 2022.11.01.14.22.40.010.0 ]--
r 30             cost = Terrain.com
--[ 2022.11.01.14.22.40.174.0 ]--
r 30             cost = Terrain.co
--[ 2022.11.01.14.22.40.342.0 ]--
r 30             cost = Terrain.c
--[ 2022.11.01.14.22.40.511.0 ]--
r 30             cost = Terrain.
--[ 2022.11.01.14.22.49.239.0 ]--
r 30             cost = Terrain.c
--[ 2022.11.01.14.22.49.345.0 ]--
r 30             cost = Terrain.co
--[ 2022.11.01.14.22.49.383.0 ]--
r 30             cost = Terrain.com
--[ 2022.11.01.14.22.49.468.0 ]--
r 30             cost = Terrain.comp
--[ 2022.11.01.14.22.49.639.0 ]--
r 30             cost = Terrain.compu
--[ 2022.11.01.14.22.49.714.0 ]--
r 30             cost = Terrain.comput
--[ 2022.11.01.14.22.49.821.0 ]--
r 30             cost = Terrain.compute
--[ 2022.11.01.14.22.49.934.0 ]--
r 30             cost = Terrain.computer
--[ 2022.11.01.14.22.50.607.0 ]--
r 30             cost = Terrain.compute
--[ 2022.11.01.14.22.57.772.0 ]--
r 30             cost = Terrain.computeT
--[ 2022.11.01.14.22.57.936.0 ]--
r 30             cost = Terrain.computeTr
--[ 2022.11.01.14.22.58.016.0 ]--
r 30             cost = Terrain.computeTra
--[ 2022.11.01.14.22.58.176.0 ]--
r 30             cost = Terrain.computeTrav
--[ 2022.11.01.14.22.58.288.0 ]--
r 30             cost = Terrain.computeTrave
--[ 2022.11.01.14.22.58.392.0 ]--
r 30             cost = Terrain.computeTravel
--[ 2022.11.01.14.22.58.851.0 ]--
r 30             cost = Terrain.computeTravelC
--[ 2022.11.01.14.22.58.968.0 ]--
r 30             cost = Terrain.computeTravelCo
--[ 2022.11.01.14.22.59.061.0 ]--
r 30             cost = Terrain.computeTravelCos
--[ 2022.11.01.14.22.59.144.0 ]--
r 30             cost = Terrain.computeTravelCost
--[ 2022.11.01.14.22.59.882.0 ]--
r 30             cost = Terrain.computeTravelCost()
--[ 2022.11.01.14.23.34.604.0 ]--
r 30             cost = Terrain.computeTravelCost();
--[ 2022.11.01.14.24.22.381.0 ]--
r 30             cost = .computeTravelCost();
--[ 2022.11.01.14.24.22.779.0 ]--
r 30             cost = computeTravelCost();
--[ 2022.11.01.14.24.25.639.0 ]--
r 30             cost = tcomputeTravelCost();
--[ 2022.11.01.14.24.26.544.0 ]--
r 30             cost = computeTravelCost();
--[ 2022.11.01.14.24.26.804.0 ]--
r 30             cost = TcomputeTravelCost();
--[ 2022.11.01.14.24.28.360.0 ]--
r 30             cost = TerraincomputeTravelCost();
--[ 2022.11.01.14.24.28.371.0 ]--
r 30             cost = Terrain computeTravelCost();
--[ 2022.11.01.14.24.28.379.0 ]--
r 30             cost = TerraincomputeTravelCost();
--[ 2022.11.01.14.24.28.752.0 ]--
r 30             cost = Terrain.computeTravelCost();
--[ 2022.11.01.14.24.45.891.0 ]--
r 30             cost = .computeTravelCost();
--[ 2022.11.01.14.24.46.251.0 ]--
r 30             cost = computeTravelCost();
--[ 2022.11.01.14.24.59.336.0 ]--
r 30             cost = TcomputeTravelCost();
--[ 2022.11.01.14.24.59.497.0 ]--
r 30             cost = TecomputeTravelCost();
--[ 2022.11.01.14.24.59.564.0 ]--
r 30             cost = TercomputeTravelCost();
--[ 2022.11.01.14.25.02.132.0 ]--
r 30             cost = TerraincomputeTravelCost();
--[ 2022.11.01.14.25.02.141.0 ]--
r 30             cost = Terrain computeTravelCost();
--[ 2022.11.01.14.25.02.149.0 ]--
r 30             cost = TerraincomputeTravelCost();
--[ 2022.11.01.14.25.02.728.0 ]--
r 30             cost = Terrain.computeTravelCost();
--[ 2022.11.01.14.25.07.910.0 ]--
+ 79         
--[ 2022.11.01.14.25.11.631.0 ]--
r 79         r
--[ 2022.11.01.14.25.11.702.0 ]--
r 79         re
--[ 2022.11.01.14.25.11.850.0 ]--
r 79         ret
--[ 2022.11.01.14.25.11.897.0 ]--
r 79         retu
--[ 2022.11.01.14.25.12.075.0 ]--
r 79         retur
--[ 2022.11.01.14.25.12.152.0 ]--
r 79         return
--[ 2022.11.01.14.25.12.264.0 ]--
r 79         return 
--[ 2022.11.01.14.25.13.781.0 ]--
r 79         return n
--[ 2022.11.01.14.25.13.902.0 ]--
r 79         return ne
--[ 2022.11.01.14.25.13.977.0 ]--
r 79         return new
--[ 2022.11.01.14.25.14.522.0 ]--
r 79         return new 
--[ 2022.11.01.14.25.14.990.0 ]--
r 79         return new T
--[ 2022.11.01.14.25.15.598.0 ]--
r 79         return new Terrain
--[ 2022.11.01.14.25.15.605.0 ]--
r 79         return new Terrain()
--[ 2022.11.01.14.25.16.556.0 ]--
r 79         return new Terrain(t)
--[ 2022.11.01.14.25.16.650.0 ]--
r 79         return new Terrain(te)
--[ 2022.11.01.14.25.16.768.0 ]--
r 79         return new Terrain(ter)
--[ 2022.11.01.14.25.17.276.0 ]--
r 79         return new Terrain(terrain)
--[ 2022.11.01.14.25.18.774.0 ]--
r 79         return new Terrain(terrain);
--[ 2022.11.01.14.25.26.280.0 ]--
r 79         
--[ 2022.11.01.14.25.27.277.0 ]--
- 79
--[ 2022.11.01.14.25.42.528.0 ]--
+ 79         
--[ 2022.11.01.14.25.57.434.0 ]--
r 79         T
--[ 2022.11.01.14.25.57.541.0 ]--
r 79         Te
--[ 2022.11.01.14.25.57.663.0 ]--
r 79         Ter
--[ 2022.11.01.14.25.57.823.0 ]--
r 79         Terr
--[ 2022.11.01.14.25.57.900.0 ]--
r 79         Terra
--[ 2022.11.01.14.25.58.081.0 ]--
r 79         Terrai
--[ 2022.11.01.14.25.58.201.0 ]--
r 79         Terrain
--[ 2022.11.01.14.26.00.434.0 ]--
r 79         Terrain 
--[ 2022.11.01.14.26.02.383.0 ]--
r 79         Terrain t
--[ 2022.11.01.14.26.02.603.0 ]--
r 79         Terrain t 
--[ 2022.11.01.14.26.02.803.0 ]--
r 79         Terrain t =
--[ 2022.11.01.14.26.02.890.0 ]--
r 79         Terrain t = 
--[ 2022.11.01.14.26.04.384.0 ]--
r 79         Terrain t = n
--[ 2022.11.01.14.26.04.476.0 ]--
r 79         Terrain t = ne
--[ 2022.11.01.14.26.04.515.0 ]--
r 79         Terrain t = new
--[ 2022.11.01.14.26.04.652.0 ]--
r 79         Terrain t = new 
--[ 2022.11.01.14.26.04.937.0 ]--
r 79         Terrain t = new T
--[ 2022.11.01.14.26.05.528.0 ]--
r 79         Terrain t = new Terrain
--[ 2022.11.01.14.26.05.537.0 ]--
r 79         Terrain t = new Terrain()
--[ 2022.11.01.14.26.06.530.0 ]--
r 79         Terrain t = new Terrain(t)
--[ 2022.11.01.14.26.06.614.0 ]--
r 79         Terrain t = new Terrain(te)
--[ 2022.11.01.14.26.06.742.0 ]--
r 79         Terrain t = new Terrain(ter)
--[ 2022.11.01.14.26.10.714.0 ]--
r 79        
--[ 2022.11.01.14.26.13.626.0 ]--
r 79        T
--[ 2022.11.01.14.26.14.730.0 ]--
r 79        Terrain
--[ 2022.11.01.14.26.15.360.0 ]--
r 79        Terrain 
--[ 2022.11.01.14.26.15.977.0 ]--
r 79        Terrain t
--[ 2022.11.01.14.26.16.094.0 ]--
r 79        Terrain t 
--[ 2022.11.01.14.26.16.217.0 ]--
r 79        Terrain t =
--[ 2022.11.01.14.26.16.308.0 ]--
r 79        Terrain t = 
--[ 2022.11.01.14.26.16.606.0 ]--
r 79        Terrain t = t
--[ 2022.11.01.14.26.16.689.0 ]--
r 79        Terrain t = te
--[ 2022.11.01.14.26.16.809.0 ]--
r 79        Terrain t = ter
--[ 2022.11.01.14.26.17.062.0 ]--
r 79        Terrain t = terrain
--[ 2022.11.01.14.26.17.512.0 ]--
r 79        Terrain t = terrain;
--[ 2022.11.01.14.26.29.275.0 ]--
+ 13     
--[ 2022.11.01.14.26.29.633.0 ]--
r 13     j
--[ 2022.11.01.14.26.30.187.0 ]--
r 13     
--[ 2022.11.01.14.26.30.685.0 ]--
r 13     T
--[ 2022.11.01.14.26.30.791.0 ]--
r 13     Te
--[ 2022.11.01.14.26.30.922.0 ]--
r 13     Ter
--[ 2022.11.01.14.26.31.133.0 ]--
r 13     Terrain
--[ 2022.11.01.14.26.31.730.0 ]--
r 13     Terrain 
--[ 2022.11.01.14.26.31.838.0 ]--
r 13     Terrain t
--[ 2022.11.01.14.26.31.970.0 ]--
r 13     Terrain t 
--[ 2022.11.01.14.26.32.085.0 ]--
r 13     Terrain t =
--[ 2022.11.01.14.26.32.218.0 ]--
r 13     Terrain t = 
--[ 2022.11.01.14.26.32.858.0 ]--
r 13     Terrain t =
--[ 2022.11.01.14.26.33.011.0 ]--
r 13     Terrain t 
--[ 2022.11.01.14.26.33.167.0 ]--
r 13     Terrain t
--[ 2022.11.01.14.26.33.398.0 ]--
r 13     Terrain t;
--[ 2022.11.01.14.26.36.251.0 ]--
r 80         t = terrain;
--[ 2022.11.01.14.26.36.640.0 ]--
- 79
r 79     public Pathfinder(Terrain terrain) {t = terrain;
--[ 2022.11.01.14.26.37.607.0 ]--
+ 79     public Pathfinder(Terrain terrain) {
r 80         t = terrain;
--[ 2022.11.01.14.26.42.752.0 ]--
r 31             cost = t.computeTravelCost();
--[ 2022.11.01.14.26.50.772.0 ]--
r 31             cost = t.computeTravelCost(f);
--[ 2022.11.01.14.26.50.959.0 ]--
r 31             cost = t.computeTravelCost(for);
--[ 2022.11.01.14.26.51.075.0 ]--
r 31             cost = t.computeTravelCost(form);
--[ 2022.11.01.14.26.53.657.0 ]--
r 31             cost = t.computeTravelCost(for);
--[ 2022.11.01.14.26.53.830.0 ]--
r 31             cost = t.computeTravelCost(fo);
--[ 2022.11.01.14.26.54.021.0 ]--
r 31             cost = t.computeTravelCost(f);
--[ 2022.11.01.14.26.54.519.0 ]--
r 31             cost = t.computeTravelCost();
--[ 2022.11.01.14.26.55.576.0 ]--
r 31             cost = t.computeTravelCost(s);
--[ 2022.11.01.14.26.55.690.0 ]--
r 31             cost = t.computeTravelCost(st);
--[ 2022.11.01.14.26.55.803.0 ]--
r 31             cost = t.computeTravelCost(sta);
--[ 2022.11.01.14.26.55.937.0 ]--
r 31             cost = t.computeTravelCost(star);
--[ 2022.11.01.14.26.56.221.0 ]--
r 31             cost = t.computeTravelCost(start);
--[ 2022.11.01.14.26.56.697.0 ]--
r 31             cost = t.computeTravelCost(start,);
--[ 2022.11.01.14.26.56.822.0 ]--
r 31             cost = t.computeTravelCost(start, );
--[ 2022.11.01.14.26.58.741.0 ]--
r 31             cost = t.computeTravelCost(start, c);
--[ 2022.11.01.14.26.58.824.0 ]--
r 31             cost = t.computeTravelCost(start, cu);
--[ 2022.11.01.14.26.59.060.0 ]--
r 31             cost = t.computeTravelCost(start, cur);
--[ 2022.11.01.14.26.59.646.0 ]--
r 31             cost = t.computeTravelCost(start, currentTile);
--[ 2022.11.01.14.27.14.070.0 ]--
r 31             d = t.computeTravelCost(start, currentTile);
--[ 2022.11.01.14.27.14.131.0 ]--
r 31             di = t.computeTravelCost(start, currentTile);
--[ 2022.11.01.14.27.14.228.0 ]--
r 31             dis = t.computeTravelCost(start, currentTile);
--[ 2022.11.01.14.27.14.403.0 ]--
r 31             dist = t.computeTravelCost(start, currentTile);
--[ 2022.11.01.14.27.14.628.0 ]--
r 31             dista = t.computeTravelCost(start, currentTile);
--[ 2022.11.01.14.27.14.784.0 ]--
r 31             distan = t.computeTravelCost(start, currentTile);
--[ 2022.11.01.14.27.14.858.0 ]--
r 31             distanc = t.computeTravelCost(start, currentTile);
--[ 2022.11.01.14.27.14.996.0 ]--
r 31             distance = t.computeTravelCost(start, currentTile);
--[ 2022.11.01.14.27.16.781.0 ]--
r 27         float d = -1;
--[ 2022.11.01.14.27.16.866.0 ]--
r 27         float di = -1;
--[ 2022.11.01.14.27.16.972.0 ]--
r 27         float dis = -1;
--[ 2022.11.01.14.27.17.330.0 ]--
r 27         float dist = -1;
--[ 2022.11.01.14.27.17.474.0 ]--
r 27         float dista = -1;
--[ 2022.11.01.14.27.17.580.0 ]--
r 27         float distan = -1;
--[ 2022.11.01.14.27.17.720.0 ]--
r 27         float distanc = -1;
--[ 2022.11.01.14.27.17.859.0 ]--
r 27         float distance = -1;
--[ 2022.11.01.14.27.22.016.0 ]--
+ 28         
--[ 2022.11.01.14.27.22.446.0 ]--
r 28         c
--[ 2022.11.01.14.27.22.536.0 ]--
r 28         co
--[ 2022.11.01.14.27.22.633.0 ]--
r 28         cos
--[ 2022.11.01.14.27.22.717.0 ]--
r 28         cost
--[ 2022.11.01.14.27.22.915.0 ]--
r 28         cost 
--[ 2022.11.01.14.27.23.420.0 ]--
r 28         cost
--[ 2022.11.01.14.27.23.589.0 ]--
r 28         cos
--[ 2022.11.01.14.27.23.749.0 ]--
r 28         co
--[ 2022.11.01.14.27.23.914.0 ]--
r 28         c
--[ 2022.11.01.14.27.24.068.0 ]--
r 28         
--[ 2022.11.01.14.27.24.555.0 ]--
r 28         f
--[ 2022.11.01.14.27.24.636.0 ]--
r 28         fl
--[ 2022.11.01.14.27.24.800.0 ]--
r 28         flo
--[ 2022.11.01.14.27.24.847.0 ]--
r 28         floa
--[ 2022.11.01.14.27.24.938.0 ]--
r 28         float
--[ 2022.11.01.14.27.25.069.0 ]--
r 28         float 
--[ 2022.11.01.14.27.25.303.0 ]--
r 28         float c
--[ 2022.11.01.14.27.25.384.0 ]--
r 28         float co
--[ 2022.11.01.14.27.25.483.0 ]--
r 28         float cos
--[ 2022.11.01.14.27.25.569.0 ]--
r 28         float cost
--[ 2022.11.01.14.27.25.692.0 ]--
r 28         float cost 
--[ 2022.11.01.14.27.25.852.0 ]--
r 28         float cost =
--[ 2022.11.01.14.27.25.948.0 ]--
r 28         float cost = 
--[ 2022.11.01.14.27.27.150.0 ]--
r 28         float cost =
--[ 2022.11.01.14.27.28.646.0 ]--
r 28         float cost = 
--[ 2022.11.01.14.27.28.815.0 ]--
r 28         float cost = -
--[ 2022.11.01.14.27.28.892.0 ]--
r 28         float cost = -1
--[ 2022.11.01.14.27.29.056.0 ]--
r 28         float cost = -1;
--[ 2022.11.01.14.27.32.283.0 ]--
+ 33             
--[ 2022.11.01.14.27.32.653.0 ]--
r 33             c
--[ 2022.11.01.14.27.32.768.0 ]--
r 33             co
--[ 2022.11.01.14.27.32.831.0 ]--
r 33             cos
--[ 2022.11.01.14.27.32.941.0 ]--
r 33             cost
--[ 2022.11.01.14.27.33.095.0 ]--
r 33             cost 
--[ 2022.11.01.14.27.33.324.0 ]--
r 33             cost =
--[ 2022.11.01.14.27.33.412.0 ]--
r 33             cost = 
--[ 2022.11.01.14.27.34.321.0 ]--
r 33             cost = d
--[ 2022.11.01.14.27.34.421.0 ]--
r 33             cost = di
--[ 2022.11.01.14.27.34.469.0 ]--
r 33             cost = dis
--[ 2022.11.01.14.27.34.587.0 ]--
r 33             cost = dist
--[ 2022.11.01.14.27.34.673.0 ]--
r 33             cost = dista
--[ 2022.11.01.14.27.34.865.0 ]--
r 33             cost = distan
--[ 2022.11.01.14.27.35.012.0 ]--
r 33             cost = distanc
--[ 2022.11.01.14.27.35.154.0 ]--
r 33             cost = distance
--[ 2022.11.01.14.27.35.261.0 ]--
r 33             cost = distance 
--[ 2022.11.01.14.27.35.492.0 ]--
r 33             cost = distance +
--[ 2022.11.01.14.27.35.622.0 ]--
r 33             cost = distance + 
--[ 2022.11.01.14.27.37.511.0 ]--
r 33             cost = distance + f
--[ 2022.11.01.14.27.37.629.0 ]--
r 33             cost = distance + ff
--[ 2022.11.01.14.27.37.787.0 ]--
r 33             cost = distance + ffr
--[ 2022.11.01.14.27.37.870.0 ]--
r 33             cost = distance + ffre
--[ 2022.11.01.14.27.38.176.0 ]--
r 33             cost = distance + ffr
--[ 2022.11.01.14.27.38.328.0 ]--
r 33             cost = distance + ff
--[ 2022.11.01.14.27.38.490.0 ]--
r 33             cost = distance + f
--[ 2022.11.01.14.27.38.653.0 ]--
r 33             cost = distance + 
--[ 2022.11.01.14.27.38.997.0 ]--
r 33             cost = distance + p
--[ 2022.11.01.14.27.39.103.0 ]--
r 33             cost = distance + pr
--[ 2022.11.01.14.27.39.165.0 ]--
r 33             cost = distance + pre
--[ 2022.11.01.14.27.40.128.0 ]--
r 33             cost = distance + prevNode
--[ 2022.11.01.14.27.40.418.0 ]--
r 33             cost = distance + prevNode.
--[ 2022.11.01.14.27.40.909.0 ]--
r 33             cost = distance + prevNode.d
--[ 2022.11.01.14.27.40.964.0 ]--
r 33             cost = distance + prevNode.di
--[ 2022.11.01.14.27.41.318.0 ]--
r 33             cost = distance + prevNode.distance
--[ 2022.11.01.14.27.41.887.0 ]--
r 33             cost = distance + prevNode.distance;
--[ 2022.11.01.14.28.19.209.0 ]--
+ 29         
--[ 2022.11.01.14.28.21.191.0 ]--
r 29         i
--[ 2022.11.01.14.28.21.266.0 ]--
r 29         in
--[ 2022.11.01.14.28.21.340.0 ]--
r 29         int
--[ 2022.11.01.14.28.21.470.0 ]--
r 29         int 
--[ 2022.11.01.14.28.21.844.0 ]--
r 29         int s
--[ 2022.11.01.14.28.21.956.0 ]--
r 29         int se
--[ 2022.11.01.14.28.22.081.0 ]--
r 29         int sea
--[ 2022.11.01.14.28.22.507.0 ]--
r 29         int sear
--[ 2022.11.01.14.28.22.682.0 ]--
r 29         int searc
--[ 2022.11.01.14.28.22.805.0 ]--
r 29         int search
--[ 2022.11.01.14.28.22.869.0 ]--
r 29         int searche
--[ 2022.11.01.14.28.22.998.0 ]--
r 29         int searched
--[ 2022.11.01.14.28.24.416.0 ]--
r 29         int searched 
--[ 2022.11.01.14.28.24.471.0 ]--
r 29         int searched =
--[ 2022.11.01.14.28.24.586.0 ]--
r 29         int searched = 
--[ 2022.11.01.14.28.25.412.0 ]--
r 29         int searched = 0
--[ 2022.11.01.14.28.25.772.0 ]--
r 29         int searched = 0;
--[ 2022.11.01.14.29.15.553.0 ]--
r 29         b searched = 0;
--[ 2022.11.01.14.29.15.684.0 ]--
r 29         bo searched = 0;
--[ 2022.11.01.14.29.15.794.0 ]--
r 29         boo searched = 0;
--[ 2022.11.01.14.29.15.963.0 ]--
r 29         bool searched = 0;
--[ 2022.11.01.14.29.18.180.0 ]--
r 29         boolean searched = 0;
--[ 2022.11.01.14.29.20.013.0 ]--
r 29         boolean searched = ;
--[ 2022.11.01.14.29.20.423.0 ]--
r 29         boolean searched = f;
--[ 2022.11.01.14.29.20.550.0 ]--
r 29         boolean searched = fa;
--[ 2022.11.01.14.29.20.601.0 ]--
r 29         boolean searched = fal;
--[ 2022.11.01.14.29.20.733.0 ]--
r 29         boolean searched = fals;
--[ 2022.11.01.14.29.20.819.0 ]--
r 29         boolean searched = false;
--[ 2022.11.01.14.29.23.567.0 ]--
+ 35             
--[ 2022.11.01.14.29.26.516.0 ]--
r 35             s
--[ 2022.11.01.14.29.26.607.0 ]--
r 35             se
--[ 2022.11.01.14.29.26.759.0 ]--
r 35             sea
--[ 2022.11.01.14.29.26.831.0 ]--
r 35             sear
--[ 2022.11.01.14.29.27.042.0 ]--
r 35             searc
--[ 2022.11.01.14.29.27.190.0 ]--
r 35             search
--[ 2022.11.01.14.29.27.219.0 ]--
r 35             searche
--[ 2022.11.01.14.29.27.378.0 ]--
r 35             searched
--[ 2022.11.01.14.29.29.053.0 ]--
r 35             searched;
--[ 2022.11.01.14.29.30.068.0 ]--
r 35             searched
--[ 2022.11.01.14.29.30.205.0 ]--
r 35             searched 
--[ 2022.11.01.14.29.30.319.0 ]--
r 35             searched =
--[ 2022.11.01.14.29.30.443.0 ]--
r 35             searched = 
--[ 2022.11.01.14.29.31.220.0 ]--
r 35             searched = f
--[ 2022.11.01.14.29.31.338.0 ]--
r 35             searched = fa
--[ 2022.11.01.14.29.31.468.0 ]--
r 35             searched = fal
--[ 2022.11.01.14.29.31.551.0 ]--
r 35             searched = fals
--[ 2022.11.01.14.29.31.669.0 ]--
r 35             searched = false
--[ 2022.11.01.14.29.32.339.0 ]--
r 35             searched = false;
--[ 2022.11.01.14.29.33.804.0 ]--
r 35             searched = false
--[ 2022.11.01.14.29.34.292.0 ]--
r 35             searched = fals
--[ 2022.11.01.14.29.34.374.0 ]--
r 35             searched = fal
--[ 2022.11.01.14.29.34.457.0 ]--
r 35             searched = fa
--[ 2022.11.01.14.29.34.543.0 ]--
r 35             searched = f
--[ 2022.11.01.14.29.34.867.0 ]--
r 35             searched = 
--[ 2022.11.01.14.29.35.663.0 ]--
r 35             searched = t
--[ 2022.11.01.14.29.35.825.0 ]--
r 35             searched = tr
--[ 2022.11.01.14.29.35.930.0 ]--
r 35             searched = tru
--[ 2022.11.01.14.29.36.007.0 ]--
r 35             searched = true
--[ 2022.11.01.14.29.36.264.0 ]--
r 35             searched = true;
--[ 2022.11.01.14.30.03.464.0 ]--
r 36             
--[ 2022.11.01.14.30.03.626.0 ]--
- 36
--[ 2022.11.01.14.30.50.072.0 ]--
- 52
--[ 2022.11.01.14.30.52.606.0 ]--
r 52             return ;
--[ 2022.11.01.14.30.53.586.0 ]--
r 52             return n;
--[ 2022.11.01.14.30.53.667.0 ]--
r 52             return no;
--[ 2022.11.01.14.30.53.719.0 ]--
r 52             return nod;
--[ 2022.11.01.14.30.53.855.0 ]--
r 52             return node;
--[ 2022.11.01.14.30.54.844.0 ]--
r 52             return nod;
--[ 2022.11.01.14.30.55.004.0 ]--
r 52             return no;
--[ 2022.11.01.14.30.55.174.0 ]--
r 52             return n;
--[ 2022.11.01.14.30.55.328.0 ]--
r 52             return ;
--[ 2022.11.01.14.30.58.615.0 ]--
r 52             return t;
--[ 2022.11.01.14.30.58.720.0 ]--
r 52             return th;
--[ 2022.11.01.14.30.58.768.0 ]--
r 52             return thi;
--[ 2022.11.01.14.30.58.823.0 ]--
r 52             return this;
--[ 2022.11.01.14.30.59.035.0 ]--
r 52             return this.;
--[ 2022.11.01.14.30.59.415.0 ]--
r 52             return this.g;
--[ 2022.11.01.14.30.59.493.0 ]--
r 52             return this.ge;
--[ 2022.11.01.14.31.00.093.0 ]--
r 52             return this.getCost;
--[ 2022.11.01.14.31.00.099.0 ]--
r 52             return this.getCost();
--[ 2022.11.01.14.31.18.427.0 ]--
r 52             return this.getCost(h);
--[ 2022.11.01.14.31.18.548.0 ]--
r 52             return this.getCost(hi);
--[ 2022.11.01.14.31.19.074.0 ]--
r 52             return this.getCost(h);
--[ 2022.11.01.14.31.19.159.0 ]--
r 52             return this.getCost(he);
--[ 2022.11.01.14.31.19.293.0 ]--
r 52             return this.getCost(heu);
--[ 2022.11.01.14.31.19.801.0 ]--
r 52             return this.getCost(heuristic);
--[ 2022.11.01.14.31.43.923.0 ]--
r 52             return this
--[ 2022.11.01.14.31.44.961.0 ]--
r 52             return this.
--[ 2022.11.01.14.31.45.168.0 ]--
r 52             return this.c
--[ 2022.11.01.14.31.45.255.0 ]--
r 52             return this.co
--[ 2022.11.01.14.31.45.958.0 ]--
r 52             return this.cost
--[ 2022.11.01.14.31.46.431.0 ]--
r 52             return this.cost;
--[ 2022.11.01.14.31.53.191.0 ]--
+ 52             
--[ 2022.11.01.14.36.02.925.0 ]--
r 33             distance = t.computeTravelCost(g, currentTile);
--[ 2022.11.01.14.36.03.049.0 ]--
r 33             distance = t.computeTravelCost(ge, currentTile);
--[ 2022.11.01.14.36.03.176.0 ]--
r 33             distance = t.computeTravelCost(get, currentTile);
--[ 2022.11.01.14.36.04.608.0 ]--
r 33             distance = t.computeTravelCost(getp, currentTile);
--[ 2022.11.01.14.36.06.065.0 ]--
r 33             distance = t.computeTravelCost(getPathStart, currentTile);
--[ 2022.11.01.14.36.06.071.0 ]--
r 33             distance = t.computeTravelCost(getPathStart(), currentTile);
--[ 2022.11.01.14.37.12.020.0 ]--
r 33             distance = ;
--[ 2022.11.01.14.37.13.865.0 ]--
r 33             distance =;
--[ 2022.11.01.14.37.14.019.0 ]--
r 33             distance ;
--[ 2022.11.01.14.37.14.178.0 ]--
r 33             distance;
--[ 2022.11.01.14.37.15.639.0 ]--
r 33             distance ;
--[ 2022.11.01.14.37.15.725.0 ]--
r 33             distance =;
--[ 2022.11.01.14.37.15.820.0 ]--
r 33             distance = ;
--[ 2022.11.01.14.37.15.973.0 ]--
r 33             distance = n;
--[ 2022.11.01.14.37.16.151.0 ]--
r 33             distance = nu;
--[ 2022.11.01.14.37.16.248.0 ]--
r 33             distance = nul;
--[ 2022.11.01.14.37.16.412.0 ]--
r 33             distance = null;
--[ 2022.11.01.14.37.17.288.0 ]--
r 52 
--[ 2022.11.01.14.37.18.622.0 ]--
r 33             distance = nul;
--[ 2022.11.01.14.37.18.769.0 ]--
r 33             distance = nu;
--[ 2022.11.01.14.37.18.946.0 ]--
r 33             distance = n;
--[ 2022.11.01.14.37.19.129.0 ]--
r 33             distance = ;
--[ 2022.11.01.14.37.22.489.0 ]--
r 33             distance = -;
--[ 2022.11.01.14.37.22.617.0 ]--
r 33             distance = -1;
--[ 2022.11.01.14.37.27.384.0 ]--
r 33             distance = -1.;
--[ 2022.11.01.14.37.27.493.0 ]--
r 33             distance = -1.0;
--[ 2022.11.01.14.37.29.249.0 ]--
r 33             distance = -1.;
--[ 2022.11.01.14.37.29.382.0 ]--
r 33             distance = -1;
--[ 2022.11.01.14.37.41.089.0 ]--
r 52     
--[ 2022.11.01.14.37.41.217.0 ]--
r 52         
--[ 2022.11.01.14.37.41.444.0 ]--
r 52             
--[ 2022.11.01.14.37.42.123.0 ]--
r 52             t.computeTravelCost(getPathStart(), currentTile)
--[ 2022.11.01.14.37.44.406.0 ]--
r 52             t.computeTravelCost(getPathStart(), currentTile);
--[ 2022.11.01.14.37.59.997.0 ]--
+ 52             
--[ 2022.11.01.14.38.00.504.0 ]--
r 52             t
--[ 2022.11.01.14.38.00.591.0 ]--
r 52             th
--[ 2022.11.01.14.38.00.674.0 ]--
r 52             thi
--[ 2022.11.01.14.38.00.720.0 ]--
r 52             this
--[ 2022.11.01.14.38.00.904.0 ]--
r 52             thisl
--[ 2022.11.01.14.38.00.969.0 ]--
r 52             thisl.
--[ 2022.11.01.14.38.01.448.0 ]--
r 52             thisl
--[ 2022.11.01.14.38.01.621.0 ]--
r 52             this
--[ 2022.11.01.14.38.02.080.0 ]--
r 52             thi
--[ 2022.11.01.14.38.02.242.0 ]--
r 52             th
--[ 2022.11.01.14.38.02.407.0 ]--
r 52             t
--[ 2022.11.01.14.38.02.623.0 ]--
r 52             
--[ 2022.11.01.14.38.02.979.0 ]--
- 52
--[ 2022.11.01.14.38.06.975.0 ]--
+ 52             
--[ 2022.11.01.14.38.07.707.0 ]--
r 52             d
--[ 2022.11.01.14.38.07.818.0 ]--
r 52             di
--[ 2022.11.01.14.38.07.913.0 ]--
r 52             dis
--[ 2022.11.01.14.38.08.066.0 ]--
r 52             dist
--[ 2022.11.01.14.38.08.481.0 ]--
r 52             dis
--[ 2022.11.01.14.38.08.626.0 ]--
r 52             di
--[ 2022.11.01.14.38.08.784.0 ]--
r 52             d
--[ 2022.11.01.14.38.08.947.0 ]--
r 52             
--[ 2022.11.01.14.38.09.163.0 ]--
r 52             t
--[ 2022.11.01.14.38.09.284.0 ]--
r 52             th
--[ 2022.11.01.14.38.09.350.0 ]--
r 52             thi
--[ 2022.11.01.14.38.09.440.0 ]--
r 52             this
--[ 2022.11.01.14.38.09.610.0 ]--
r 52             this.
--[ 2022.11.01.14.38.09.924.0 ]--
r 52             this.d
--[ 2022.11.01.14.38.10.072.0 ]--
r 52             this.di
--[ 2022.11.01.14.38.10.179.0 ]--
r 52             this.dis
--[ 2022.11.01.14.38.10.419.0 ]--
r 52             this.distance
--[ 2022.11.01.14.38.10.843.0 ]--
r 52             this.distance 
--[ 2022.11.01.14.38.10.924.0 ]--
r 52             this.distance =
--[ 2022.11.01.14.38.11.036.0 ]--
r 52             this.distance = 
--[ 2022.11.01.14.38.16.456.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), currentTile);
--[ 2022.11.01.14.38.58.948.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), tcurrentTile);
--[ 2022.11.01.14.38.59.000.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), thcurrentTile);
--[ 2022.11.01.14.38.59.094.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), thicurrentTile);
--[ 2022.11.01.14.38.59.146.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), thiscurrentTile);
--[ 2022.11.01.14.38.59.365.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile);
--[ 2022.11.01.14.39.09.996.0 ]--
r 53             t.computeTravelCost(getPathStart(), tcurrentTile);
--[ 2022.11.01.14.39.10.047.0 ]--
r 53             t.computeTravelCost(getPathStart(), thcurrentTile);
--[ 2022.11.01.14.39.10.113.0 ]--
r 53             t.computeTravelCost(getPathStart(), thicurrentTile);
--[ 2022.11.01.14.39.10.203.0 ]--
r 53             t.computeTravelCost(getPathStart(), thiscurrentTile);
--[ 2022.11.01.14.39.10.320.0 ]--
r 53             t.computeTravelCost(getPathStart(), this.currentTile);
--[ 2022.11.01.14.39.15.994.0 ]--
r 54             return ;
--[ 2022.11.01.14.39.21.271.0 ]--
r 53             t.computeTravelCost(getPathStart(), this.currentTile)
--[ 2022.11.01.14.39.24.086.0 ]--
r 53             
--[ 2022.11.01.14.39.24.998.0 ]--
- 53
--[ 2022.11.01.14.39.27.276.0 ]--
r 53             return t.computeTravelCost(getPathStart(), this.currentTile);
--[ 2022.11.01.14.39.39.992.0 ]--
r 53             return t.computeTravelCost(getPathStart(), this.currentTile) ;
--[ 2022.11.01.14.39.40.263.0 ]--
r 53             return t.computeTravelCost(getPathStart(), this.currentTile) *;
--[ 2022.11.01.14.39.40.402.0 ]--
r 53             return t.computeTravelCost(getPathStart(), this.currentTile) * ;
--[ 2022.11.01.14.39.41.129.0 ]--
r 53             return t.computeTravelCost(getPathStart(), this.currentTile) * h;
--[ 2022.11.01.14.39.41.218.0 ]--
r 53             return t.computeTravelCost(getPathStart(), this.currentTile) * he;
--[ 2022.11.01.14.39.41.762.0 ]--
r 53             return t.computeTravelCost(getPathStart(), this.currentTile) * he'';
--[ 2022.11.01.14.39.42.598.0 ]--
r 53             return t.computeTravelCost(getPathStart(), this.currentTile) * he;
--[ 2022.11.01.14.39.43.755.0 ]--
r 53             return t.computeTravelCost(getPathStart(), this.currentTile) * heu;
--[ 2022.11.01.14.39.44.021.0 ]--
r 53             return t.computeTravelCost(getPathStart(), this.currentTile) * heuristic;
--[ 2022.11.01.14.39.47.238.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) ;
--[ 2022.11.01.14.39.47.329.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) h;
--[ 2022.11.01.14.39.47.494.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) hu;
--[ 2022.11.01.14.39.47.887.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) h;
--[ 2022.11.01.14.39.47.983.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) he;
--[ 2022.11.01.14.39.48.081.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) heu;
--[ 2022.11.01.14.39.48.854.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) he;
--[ 2022.11.01.14.39.49.029.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) h;
--[ 2022.11.01.14.39.49.211.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) ;
--[ 2022.11.01.14.39.49.863.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) *;
--[ 2022.11.01.14.39.50.015.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) * ;
--[ 2022.11.01.14.39.50.174.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) * h;
--[ 2022.11.01.14.39.50.257.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) * he;
--[ 2022.11.01.14.39.50.702.0 ]--
r 52             this.distance = t.computeTravelCost(getPathStart(), this.currentTile) * heuristic;
--[ 2022.11.01.14.41.31.224.0 ]--
+ 117         
--[ 2022.11.01.14.41.33.657.0 ]--
r 117         j
--[ 2022.11.01.14.41.33.704.0 ]--
r 117         ji
--[ 2022.11.01.14.41.33.785.0 ]--
r 117         jif
--[ 2022.11.01.14.41.34.131.0 ]--
r 117         ji
--[ 2022.11.01.14.41.34.288.0 ]--
r 117         j
--[ 2022.11.01.14.41.34.452.0 ]--
r 117         
--[ 2022.11.01.14.41.34.540.0 ]--
r 117         i
--[ 2022.11.01.14.41.34.657.0 ]--
r 117         if
--[ 2022.11.01.14.41.34.771.0 ]--
r 117         if 
--[ 2022.11.01.14.41.36.213.0 ]--
r 117         if ()
--[ 2022.11.01.14.41.36.514.0 ]--
r 117         if (p)
--[ 2022.11.01.14.41.36.614.0 ]--
r 117         if (pq)
--[ 2022.11.01.14.41.37.044.0 ]--
r 117         if (pq.)
--[ 2022.11.01.14.41.38.031.0 ]--
r 117         if (pq.d)
--[ 2022.11.01.14.41.38.175.0 ]--
r 117         if (pq.de)
--[ 2022.11.01.14.41.39.484.0 ]--
r 117         if (pq.deq)
--[ 2022.11.01.14.41.39.926.0 ]--
r 117         if (pq.de)
--[ 2022.11.01.14.41.40.455.0 ]--
r 117         if (pq.d)
--[ 2022.11.01.14.41.40.608.0 ]--
r 117         if (pq.)
--[ 2022.11.01.14.41.40.895.0 ]--
r 117         if (pq.p)
--[ 2022.11.01.14.41.41.610.0 ]--
r 117         if (pq.)
--[ 2022.11.01.14.42.07.937.0 ]--
r 117         if (pq.i)
--[ 2022.11.01.14.42.08.016.0 ]--
r 117         if (pq.is)
--[ 2022.11.01.14.42.09.770.0 ]--
r 117         if (pq.i)
--[ 2022.11.01.14.42.09.958.0 ]--
r 117         if (pq.)
--[ 2022.11.01.14.42.12.215.0 ]--
r 117         if (pq.i)
--[ 2022.11.01.14.42.12.286.0 ]--
r 117         if (pq.is)
--[ 2022.11.01.14.42.12.983.0 ]--
r 117         if (pq.isEmpty)
--[ 2022.11.01.14.42.12.988.0 ]--
r 117         if (pq.isEmpty())
--[ 2022.11.01.14.42.14.802.0 ]--
r 117         if (pq.isEmpty()) 
--[ 2022.11.01.14.42.15.028.0 ]--
r 117         if (pq.isEmpty()) {
--[ 2022.11.01.14.42.16.493.0 ]--
+ 118 
+ 119 }
--[ 2022.11.01.14.42.16.505.0 ]--
r 119         }
--[ 2022.11.01.14.42.16.521.0 ]--
r 118             
--[ 2022.11.01.14.42.17.587.0 ]--
r 118             r
--[ 2022.11.01.14.42.17.628.0 ]--
r 118             re
--[ 2022.11.01.14.42.17.783.0 ]--
r 118             ret
--[ 2022.11.01.14.42.17.886.0 ]--
r 118             retu
--[ 2022.11.01.14.42.17.988.0 ]--
r 118             retur
--[ 2022.11.01.14.42.18.106.0 ]--
r 118             return
--[ 2022.11.01.14.42.18.211.0 ]--
r 118             return 
--[ 2022.11.01.14.42.18.593.0 ]--
r 118             return t
--[ 2022.11.01.14.42.18.773.0 ]--
r 118             return tr
--[ 2022.11.01.14.42.18.892.0 ]--
r 118             return tru
--[ 2022.11.01.14.42.18.990.0 ]--
r 118             return true
--[ 2022.11.01.14.42.19.223.0 ]--
r 118             return true;
--[ 2022.11.01.14.42.34.789.0 ]--
r 118             return pq.isEmpty();
--[ 2022.11.01.14.42.34.801.0 ]--
- 117
- 117
r 117         return pq.isEmpty();
--[ 2022.11.01.14.42.34.810.0 ]--
- 117
r 117         return pq.isEmpty();return false;
--[ 2022.11.01.14.42.34.813.0 ]--
r 117         return pq.isEmpty();
--[ 2022.11.01.14.43.27.020.0 ]--
r 117         return pq.();
--[ 2022.11.01.14.43.28.145.0 ]--
r 117         return pq.(;
--[ 2022.11.01.14.43.28.354.0 ]--
r 117         return pq.;
--[ 2022.11.01.14.43.28.713.0 ]--
r 117         return pq;
--[ 2022.11.01.14.43.29.780.0 ]--
r 117         return pq.;
--[ 2022.11.01.14.43.33.295.0 ]--
r 117         return pq.m;
--[ 2022.11.01.14.43.33.339.0 ]--
r 117         return pq.mi;
--[ 2022.11.01.14.43.33.563.0 ]--
r 117         return pq.min;
--[ 2022.11.01.14.43.34.873.0 ]--
r 117         return pq.mi;
--[ 2022.11.01.14.44.06.718.0 ]--
+ 36             
--[ 2022.11.01.14.44.09.677.0 ]--
r 36             f
--[ 2022.11.01.14.44.09.748.0 ]--
r 36             fo
--[ 2022.11.01.14.44.09.787.0 ]--
r 36             fou
--[ 2022.11.01.14.44.10.005.0 ]--
r 36             foun
--[ 2022.11.01.14.44.10.122.0 ]--
r 36             found
--[ 2022.11.01.14.44.10.804.0 ]--
r 36             found 
--[ 2022.11.01.14.44.10.884.0 ]--
r 36             found =
--[ 2022.11.01.14.44.11.000.0 ]--
r 36             found = 
--[ 2022.11.01.14.44.11.924.0 ]--
r 36             found = f
--[ 2022.11.01.14.44.12.031.0 ]--
r 36             found = fa
--[ 2022.11.01.14.44.12.126.0 ]--
r 36             found = fal
--[ 2022.11.01.14.44.12.191.0 ]--
r 36             found = fals
--[ 2022.11.01.14.44.12.296.0 ]--
r 36             found = false
--[ 2022.11.01.14.44.12.528.0 ]--
r 36             found = false;
--[ 2022.11.01.14.44.17.946.0 ]--
r 29         boolean searched, = false;
--[ 2022.11.01.14.44.18.368.0 ]--
r 29         boolean searched,  = false;
--[ 2022.11.01.14.44.18.798.0 ]--
r 29         boolean searched, f = false;
--[ 2022.11.01.14.44.18.833.0 ]--
r 29         boolean searched, fo = false;
--[ 2022.11.01.14.44.18.905.0 ]--
r 29         boolean searched, fou = false;
--[ 2022.11.01.14.44.19.088.0 ]--
r 29         boolean searched, foun = false;
--[ 2022.11.01.14.44.19.200.0 ]--
r 29         boolean searched, found = false;
--[ 2022.11.01.14.44.30.311.0 ]--
r 118         return pq.m;
--[ 2022.11.01.14.44.30.469.0 ]--
r 118         return pq.;
--[ 2022.11.01.14.44.30.658.0 ]--
r 118         return pq;
--[ 2022.11.01.14.44.30.863.0 ]--
r 118         return p;
--[ 2022.11.01.14.44.31.277.0 ]--
r 118         return ;
--[ 2022.11.01.14.44.32.578.0 ]--
r 118         return p;
--[ 2022.11.01.14.44.32.652.0 ]--
r 118         return pq;
--[ 2022.11.01.14.44.32.924.0 ]--
r 118         return pq.;
--[ 2022.11.01.14.44.33.515.0 ]--
r 118         return pq;
--[ 2022.11.01.14.44.33.645.0 ]--
r 118         return p;
--[ 2022.11.01.14.44.33.804.0 ]--
r 118         return ;
--[ 2022.11.01.14.44.33.964.0 ]--
r 118         return;
--[ 2022.11.01.14.44.34.033.0 ]--
r 118         returnt;
--[ 2022.11.01.14.44.34.386.0 ]--
r 118         return;
--[ 2022.11.01.14.44.34.539.0 ]--
r 118         return ;
--[ 2022.11.01.14.44.34.655.0 ]--
r 118         return t;
--[ 2022.11.01.14.44.34.749.0 ]--
r 118         return th;
--[ 2022.11.01.14.44.34.814.0 ]--
r 118         return thi;
--[ 2022.11.01.14.44.34.891.0 ]--
r 118         return this;
--[ 2022.11.01.14.44.35.098.0 ]--
r 118         return this.;
--[ 2022.11.01.14.44.37.049.0 ]--
r 118         return this.f;
--[ 2022.11.01.14.44.37.150.0 ]--
r 118         return this.fo;
--[ 2022.11.01.14.44.37.232.0 ]--
r 118         return this.fou;
--[ 2022.11.01.14.44.39.532.0 ]--
r 118         return this.foun;
--[ 2022.11.01.14.44.39.635.0 ]--
r 118         return this.found;
--[ 2022.11.01.14.45.15.382.0 ]--
r 118         return this.;
--[ 2022.11.01.14.45.15.571.0 ]--
r 118         return this;
--[ 2022.11.01.14.45.16.236.0 ]--
r 118         return this.;
--[ 2022.11.01.14.45.29.839.0 ]--
r 118         return this.PFNode;
--[ 2022.11.01.14.45.30.998.0 ]--
r 118         return this.PFNode.;
--[ 2022.11.01.14.45.32.317.0 ]--
r 118         return this.PFNode;
--[ 2022.11.01.14.45.32.434.0 ]--
r 118         return this.PFNod;
--[ 2022.11.01.14.45.32.595.0 ]--
r 118         return this.PFNo;
--[ 2022.11.01.14.45.32.771.0 ]--
r 118         return this.PFN;
--[ 2022.11.01.14.45.32.942.0 ]--
r 118         return this.PF;
--[ 2022.11.01.14.45.33.119.0 ]--
r 118         return this.P;
--[ 2022.11.01.14.45.33.295.0 ]--
r 118         return this.;
--[ 2022.11.01.14.45.33.477.0 ]--
r 118         return this;
--[ 2022.11.01.14.45.33.658.0 ]--
r 118         return thi;
--[ 2022.11.01.14.45.33.851.0 ]--
r 118         return th;
--[ 2022.11.01.14.45.34.029.0 ]--
r 118         return t;
--[ 2022.11.01.14.45.34.240.0 ]--
r 118         return ;
--[ 2022.11.01.14.45.35.824.0 ]--
r 118         return 0;
--[ 2022.11.01.14.45.43.848.0 ]--
r 118         return ;
--[ 2022.11.01.14.45.45.081.0 ]--
r 118         return f;
--[ 2022.11.01.14.45.45.200.0 ]--
r 118         return fa;
--[ 2022.11.01.14.45.45.238.0 ]--
r 118         return fal;
--[ 2022.11.01.14.45.45.333.0 ]--
r 118         return fals;
--[ 2022.11.01.14.45.45.436.0 ]--
r 118         return false;
--[ 2022.11.01.14.46.01.287.0 ]--
r 133     public boolean wasSearched(Coord loc) {return t;
--[ 2022.11.01.14.46.01.300.0 ]--
r 133     public boolean wasSearched(Coord loc) {return th;
--[ 2022.11.01.14.46.01.476.0 ]--
r 133     public boolean wasSearched(Coord loc) {return ths;
--[ 2022.11.01.14.46.01.629.0 ]--
r 133     public boolean wasSearched(Coord loc) {return ths.;
--[ 2022.11.01.14.46.02.252.0 ]--
r 133     public boolean wasSearched(Coord loc) {return ths;
--[ 2022.11.01.14.46.02.425.0 ]--
r 133     public boolean wasSearched(Coord loc) {return th;
--[ 2022.11.01.14.46.02.589.0 ]--
r 133     public boolean wasSearched(Coord loc) {return t;
--[ 2022.11.01.14.46.02.660.0 ]--
r 133     public boolean wasSearched(Coord loc) {return ti;
--[ 2022.11.01.14.46.03.240.0 ]--
r 133     public boolean wasSearched(Coord loc) {return t;
--[ 2022.11.01.14.46.03.303.0 ]--
r 133     public boolean wasSearched(Coord loc) {return th;
--[ 2022.11.01.14.46.03.406.0 ]--
r 133     public boolean wasSearched(Coord loc) {return thi;
--[ 2022.11.01.14.46.03.515.0 ]--
r 133     public boolean wasSearched(Coord loc) {return this;
--[ 2022.11.01.14.46.03.660.0 ]--
r 133     public boolean wasSearched(Coord loc) {return this.;
--[ 2022.11.01.14.46.03.908.0 ]--
r 133     public boolean wasSearched(Coord loc) {return this.s;
--[ 2022.11.01.14.46.04.008.0 ]--
r 133     public boolean wasSearched(Coord loc) {return this.se;
--[ 2022.11.01.14.46.04.169.0 ]--
r 133     public boolean wasSearched(Coord loc) {return this.sea;
--[ 2022.11.01.14.46.39.431.0 ]--
r 133     public boolean wasSearched(Coord loc) {return this.sa;
--[ 2022.11.01.14.46.40.223.0 ]--
r 133     public boolean wasSearched(Coord loc) {return this.s;
--[ 2022.11.01.14.46.40.422.0 ]--
r 133     public boolean wasSearched(Coord loc) {return this.s
--[ 2022.11.01.14.46.40.588.0 ]--
r 133     public boolean wasSearched(Coord loc) {return this.
--[ 2022.11.01.14.46.40.788.0 ]--
r 133     public boolean wasSearched(Coord loc) {return this
--[ 2022.11.01.14.46.40.986.0 ]--
r 133     public boolean wasSearched(Coord loc) {return thi
--[ 2022.11.01.14.46.41.185.0 ]--
r 133     public boolean wasSearched(Coord loc) {return th
--[ 2022.11.01.14.46.41.382.0 ]--
r 133     public boolean wasSearched(Coord loc) {return t
--[ 2022.11.01.14.46.41.820.0 ]--
r 133     public boolean wasSearched(Coord loc) {return 
--[ 2022.11.01.14.46.53.102.0 ]--
r 133     public boolean wasSearched(Coord loc) {return 0
--[ 2022.11.01.14.46.53.581.0 ]--
r 133     public boolean wasSearched(Coord loc) {return 0;
--[ 2022.11.01.14.46.54.996.0 ]--
r 133     public boolean wasSearched(Coord loc) {return 0
--[ 2022.11.01.14.46.55.365.0 ]--
r 133     public boolean wasSearched(Coord loc) {return 
--[ 2022.11.01.14.46.55.808.0 ]--
r 133     public boolean wasSearched(Coord loc) {return f
--[ 2022.11.01.14.46.55.910.0 ]--
r 133     public boolean wasSearched(Coord loc) {return fa
--[ 2022.11.01.14.46.56.009.0 ]--
r 133     public boolean wasSearched(Coord loc) {return fal
--[ 2022.11.01.14.46.56.152.0 ]--
r 133     public boolean wasSearched(Coord loc) {return fals
--[ 2022.11.01.14.46.56.208.0 ]--
r 133     public boolean wasSearched(Coord loc) {return false
--[ 2022.11.01.14.46.56.546.0 ]--
r 133     public boolean wasSearched(Coord loc) {return false;
--[ 2022.11.01.14.47.24.255.0 ]--
r 35             searched = f;
--[ 2022.11.01.14.47.24.357.0 ]--
r 35             searched = fa;
--[ 2022.11.01.14.47.25.240.0 ]--
r 35             searched = fal;
--[ 2022.11.01.14.47.25.332.0 ]--
r 35             searched = fals;
--[ 2022.11.01.14.47.25.424.0 ]--
r 35             searched = false;
--[ 2022.11.01.14.52.11.186.0 ]--
+ 53             
--[ 2022.11.01.14.52.12.103.0 ]--
r 53             t
--[ 2022.11.01.14.52.12.223.0 ]--
r 53             to
--[ 2022.11.01.14.52.12.300.0 ]--
r 53             tot
--[ 2022.11.01.14.52.12.321.0 ]--
r 53             tota
--[ 2022.11.01.14.52.12.441.0 ]--
r 53             total
--[ 2022.11.01.14.52.13.998.0 ]--
r 53             tota
--[ 2022.11.01.14.52.14.166.0 ]--
r 53             tot
--[ 2022.11.01.14.52.14.326.0 ]--
r 53             to
--[ 2022.11.01.14.52.14.507.0 ]--
r 53             t
--[ 2022.11.01.14.52.14.669.0 ]--
r 53             
--[ 2022.11.01.14.52.18.843.0 ]--
r 53             t
--[ 2022.11.01.14.52.18.945.0 ]--
r 53             t.
--[ 2022.11.01.14.52.19.340.0 ]--
r 53             t.c
--[ 2022.11.01.14.52.19.383.0 ]--
r 53             t.co
--[ 2022.11.01.14.52.19.487.0 ]--
r 53             t.com
--[ 2022.11.01.14.52.20.427.0 ]--
r 53             t.computeTravelCost
--[ 2022.11.01.14.52.20.433.0 ]--
r 53             t.computeTravelCost()
--[ 2022.11.01.14.52.21.993.0 ]--
r 53             t.computeTravelCost
--[ 2022.11.01.14.52.22.485.0 ]--
r 53             t.computeTravelCos
--[ 2022.11.01.14.52.22.577.0 ]--
r 53             t.computeTravelCo
--[ 2022.11.01.14.52.22.650.0 ]--
r 53             t.computeTravelC
--[ 2022.11.01.14.52.22.733.0 ]--
r 53             t.computeTravel
--[ 2022.11.01.14.52.22.817.0 ]--
r 53             t.computeTrave
--[ 2022.11.01.14.52.22.900.0 ]--
r 53             t.computeTrav
--[ 2022.11.01.14.52.22.983.0 ]--
r 53             t.computeTra
--[ 2022.11.01.14.52.23.067.0 ]--
r 53             t.computeTr
--[ 2022.11.01.14.52.23.150.0 ]--
r 53             t.computeT
--[ 2022.11.01.14.52.23.234.0 ]--
r 53             t.compute
--[ 2022.11.01.14.52.23.317.0 ]--
r 53             t.comput
--[ 2022.11.01.14.52.23.400.0 ]--
r 53             t.compu
--[ 2022.11.01.14.52.23.483.0 ]--
r 53             t.comp
--[ 2022.11.01.14.52.23.567.0 ]--
r 53             t.com
--[ 2022.11.01.14.52.23.650.0 ]--
r 53             t.co
--[ 2022.11.01.14.52.23.733.0 ]--
r 53             t.c
--[ 2022.11.01.14.52.24.814.0 ]--
r 53             t.co
--[ 2022.11.01.14.52.24.906.0 ]--
r 53             t.com
--[ 2022.11.01.14.52.26.288.0 ]--
r 53             t.computeTravelCost
--[ 2022.11.01.14.52.26.294.0 ]--
r 53             t.computeTravelCost()
--[ 2022.11.01.14.52.28.598.0 ]--
r 53             t.com
--[ 2022.11.01.14.52.29.147.0 ]--
r 53             t.c
--[ 2022.11.01.14.52.29.587.0 ]--
r 53             t.computeTravelCost()
--[ 2022.11.01.14.52.30.017.0 ]--
r 53             t.com
--[ 2022.11.01.14.52.30.886.0 ]--
r 53             t.co
--[ 2022.11.01.14.52.31.029.0 ]--
r 53             t.c
--[ 2022.11.01.14.52.31.176.0 ]--
r 53             t.
--[ 2022.11.01.14.52.31.311.0 ]--
r 53             t
--[ 2022.11.01.14.52.31.454.0 ]--
r 53             
--[ 2022.11.01.14.52.31.595.0 ]--
- 53
--[ 2022.11.01.14.53.19.409.0 ]--
+ 53             
--[ 2022.11.01.14.53.19.747.0 ]--
r 53             /
--[ 2022.11.01.14.53.19.869.0 ]--
r 53             //
--[ 2022.11.01.14.53.20.282.0 ]--
r 53             // 
--[ 2022.11.01.14.53.20.642.0 ]--
r 53             // c
--[ 2022.11.01.14.53.20.787.0 ]--
r 53             // co
--[ 2022.11.01.14.53.20.855.0 ]--
r 53             // cos
--[ 2022.11.01.14.53.20.951.0 ]--
r 53             // cost
--[ 2022.11.01.14.53.21.049.0 ]--
r 53             // cost 
--[ 2022.11.01.14.53.21.575.0 ]--
r 53             // cost
--[ 2022.11.01.14.53.21.719.0 ]--
r 53             // cost(
--[ 2022.11.01.14.53.22.485.0 ]--
r 53             // cost(s
--[ 2022.11.01.14.53.22.564.0 ]--
r 53             // cost(st
--[ 2022.11.01.14.53.22.668.0 ]--
r 53             // cost(sta
--[ 2022.11.01.14.53.22.781.0 ]--
r 53             // cost(star
--[ 2022.11.01.14.53.22.957.0 ]--
r 53             // cost(start
--[ 2022.11.01.14.53.23.183.0 ]--
r 53             // cost(start,
--[ 2022.11.01.14.53.23.272.0 ]--
r 53             // cost(start, 
--[ 2022.11.01.14.53.23.472.0 ]--
r 53             // cost(start, n
--[ 2022.11.01.14.53.23.520.0 ]--
r 53             // cost(start, ne
--[ 2022.11.01.14.53.23.702.0 ]--
r 53             // cost(start, nei
--[ 2022.11.01.14.53.23.769.0 ]--
r 53             // cost(start, neig
--[ 2022.11.01.14.53.23.929.0 ]--
r 53             // cost(start, neigh
--[ 2022.11.01.14.53.24.280.0 ]--
r 53             // cost(start, neighb
--[ 2022.11.01.14.53.24.391.0 ]--
r 53             // cost(start, neighbo
--[ 2022.11.01.14.53.25.012.0 ]--
r 53             // cost(start, neighbor
--[ 2022.11.01.14.53.25.739.0 ]--
r 53             // cost(start, neighbor)
--[ 2022.11.01.14.53.26.831.0 ]--
r 53             // cost(start, neighbor),
--[ 2022.11.01.14.53.27.982.0 ]--
r 53             // cost(start, neighbor)
--[ 2022.11.01.14.53.28.153.0 ]--
r 53             // cost(start, neighbor) 
--[ 2022.11.01.14.53.28.267.0 ]--
r 53             // cost(start, neighbor) =
--[ 2022.11.01.14.53.28.452.0 ]--
r 53             // cost(start, neighbor) = 
--[ 2022.11.01.14.53.28.978.0 ]--
r 53             // cost(start, neighbor) =
--[ 2022.11.01.14.53.29.150.0 ]--
r 53             // cost(start, neighbor) 
--[ 2022.11.01.14.53.29.360.0 ]--
r 53             // cost(start, neighbor) +
--[ 2022.11.01.14.53.29.617.0 ]--
r 53             // cost(start, neighbor) + 
--[ 2022.11.01.14.53.30.191.0 ]--
r 53             // cost(start, neighbor) + t
--[ 2022.11.01.14.53.30.385.0 ]--
r 53             // cost(start, neighbor) + tr
--[ 2022.11.01.14.53.30.471.0 ]--
r 53             // cost(start, neighbor) + tra
--[ 2022.11.01.14.53.30.687.0 ]--
r 53             // cost(start, neighbor) + trav
--[ 2022.11.01.14.53.30.817.0 ]--
r 53             // cost(start, neighbor) + trave
--[ 2022.11.01.14.53.30.911.0 ]--
r 53             // cost(start, neighbor) + travel
--[ 2022.11.01.14.53.31.492.0 ]--
r 53             // cost(start, neighbor) + travelC
--[ 2022.11.01.14.53.31.695.0 ]--
r 53             // cost(start, neighbor) + travelCo
--[ 2022.11.01.14.53.31.806.0 ]--
r 53             // cost(start, neighbor) + travelCos
--[ 2022.11.01.14.53.31.920.0 ]--
r 53             // cost(start, neighbor) + travelCost
--[ 2022.11.01.14.53.32.152.0 ]--
r 53             // cost(start, neighbor) + travelCost(
--[ 2022.11.01.14.53.36.109.0 ]--
r 53             // cost(start, neighbor) + travelCost(n
--[ 2022.11.01.14.53.36.161.0 ]--
r 53             // cost(start, neighbor) + travelCost(ne
--[ 2022.11.01.14.53.36.297.0 ]--
r 53             // cost(start, neighbor) + travelCost(nei
--[ 2022.11.01.14.53.36.433.0 ]--
r 53             // cost(start, neighbor) + travelCost(neig
--[ 2022.11.01.14.53.36.571.0 ]--
r 53             // cost(start, neighbor) + travelCost(neigh
--[ 2022.11.01.14.53.36.835.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighb
--[ 2022.11.01.14.53.36.948.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbo
--[ 2022.11.01.14.53.37.056.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor
--[ 2022.11.01.14.53.37.222.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor 
--[ 2022.11.01.14.53.37.359.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor t
--[ 2022.11.01.14.53.37.404.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor to
--[ 2022.11.01.14.53.37.519.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor to 
--[ 2022.11.01.14.53.37.810.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor to
--[ 2022.11.01.14.53.37.969.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor t
--[ 2022.11.01.14.53.38.134.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor 
--[ 2022.11.01.14.53.38.303.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor
--[ 2022.11.01.14.53.38.662.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor,
--[ 2022.11.01.14.53.38.795.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, 
--[ 2022.11.01.14.53.41.128.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, t
--[ 2022.11.01.14.53.41.245.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, th
--[ 2022.11.01.14.53.41.303.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, thi
--[ 2022.11.01.14.53.41.388.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this
--[ 2022.11.01.14.53.41.779.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this)
--[ 2022.11.01.14.53.43.734.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) 
--[ 2022.11.01.14.53.43.931.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) +
--[ 2022.11.01.14.53.44.052.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + 
--[ 2022.11.01.14.53.49.921.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + h
--[ 2022.11.01.14.53.49.997.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + he
--[ 2022.11.01.14.53.50.633.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + heu
--[ 2022.11.01.14.53.50.933.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + heur
--[ 2022.11.01.14.53.51.041.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + heuri
--[ 2022.11.01.14.53.51.128.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + heuris
--[ 2022.11.01.14.53.51.212.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + heurist
--[ 2022.11.01.14.53.51.316.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + heuristi
--[ 2022.11.01.14.53.51.428.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + heuristic
--[ 2022.11.01.14.53.52.059.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + heuristic 
--[ 2022.11.01.14.53.52.752.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + heuristic *
--[ 2022.11.01.14.53.55.408.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic *
--[ 2022.11.01.14.53.57.593.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * 
--[ 2022.11.01.14.54.16.407.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * c
--[ 2022.11.01.14.54.16.458.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * co
--[ 2022.11.01.14.54.16.569.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * com
--[ 2022.11.01.14.54.16.633.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * comp
--[ 2022.11.01.14.54.16.790.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * compu
--[ 2022.11.01.14.54.16.992.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * comput
--[ 2022.11.01.14.54.17.148.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * compute
--[ 2022.11.01.14.54.18.128.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeD
--[ 2022.11.01.14.54.18.282.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDi
--[ 2022.11.01.14.54.18.362.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDis
--[ 2022.11.01.14.54.18.469.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDist
--[ 2022.11.01.14.54.18.663.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDista
--[ 2022.11.01.14.54.18.852.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistan
--[ 2022.11.01.14.54.18.907.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistanc
--[ 2022.11.01.14.54.19.094.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance
--[ 2022.11.01.14.54.19.387.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(
--[ 2022.11.01.14.54.23.490.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(t
--[ 2022.11.01.14.54.23.573.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(th
--[ 2022.11.01.14.54.23.612.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(thi
--[ 2022.11.01.14.54.23.708.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this
--[ 2022.11.01.14.54.23.971.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this,
--[ 2022.11.01.14.54.24.067.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, 
--[ 2022.11.01.14.54.24.217.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, e
--[ 2022.11.01.14.54.24.291.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, en
--[ 2022.11.01.14.54.24.429.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end
--[ 2022.11.01.14.54.24.706.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end)
--[ 2022.11.01.14.54.25.965.0 ]--
r 53             // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
--[ 2022.11.01.14.54.52.901.0 ]--
r 34             cost = -;
--[ 2022.11.01.14.54.53.363.0 ]--
r 34             cost = -1;
--[ 2022.11.01.14.54.56.162.0 ]--
r 33             d
--[ 2022.11.01.14.54.56.315.0 ]--
r 33             
--[ 2022.11.01.14.54.56.645.0 ]--
- 33
--[ 2022.11.01.14.54.59.448.0 ]--
r 27       
--[ 2022.11.01.14.54.59.602.0 ]--
- 27
--[ 2022.11.01.14.55.08.223.0 ]--
r 27         float cost = -;
--[ 2022.11.01.14.55.08.382.0 ]--
r 27         float cost = ;
--[ 2022.11.01.14.55.08.561.0 ]--
r 27         float cost =;
--[ 2022.11.01.14.55.08.736.0 ]--
r 27         float cost ;
--[ 2022.11.01.14.55.09.109.0 ]--
r 27         float cost;
--[ 2022.11.01.14.55.13.716.0 ]--
r 28         boolean searched, found = fals;
--[ 2022.11.01.14.55.13.869.0 ]--
r 28         boolean searched, found = fal;
--[ 2022.11.01.14.55.14.029.0 ]--
r 28         boolean searched, found = fa;
--[ 2022.11.01.14.55.14.193.0 ]--
r 28         boolean searched, found = f;
--[ 2022.11.01.14.55.14.377.0 ]--
r 28         boolean searched, found = ;
--[ 2022.11.01.14.55.14.541.0 ]--
r 28         boolean searched, found =;
--[ 2022.11.01.14.55.14.732.0 ]--
r 28         boolean searched, found ;
--[ 2022.11.01.14.55.15.143.0 ]--
r 28         boolean searched, found;
--[ 2022.11.01.14.55.23.191.0 ]--
r 52             this.c = t.computeTravelCost(getPathStart(), this.currentTile) * heuristic;
--[ 2022.11.01.14.55.23.307.0 ]--
r 52             this.co = t.computeTravelCost(getPathStart(), this.currentTile) * heuristic;
--[ 2022.11.01.14.55.23.371.0 ]--
r 52             this.cos = t.computeTravelCost(getPathStart(), this.currentTile) * heuristic;
--[ 2022.11.01.14.55.23.521.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.currentTile) * heuristic;
--[ 2022.11.01.14.55.38.636.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.currentTile) ;
--[ 2022.11.01.14.55.43.576.0 ]--
r 53             return 
--[ 2022.11.01.14.55.45.864.0 ]--
r 53             return 0
--[ 2022.11.01.14.55.46.286.0 ]--
r 53             return 0;
--[ 2022.11.01.14.55.49.627.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.currentTile) 
--[ 2022.11.01.14.55.49.871.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.currentTile)
--[ 2022.11.01.14.56.00.833.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), n)
--[ 2022.11.01.14.56.00.908.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), ne)
--[ 2022.11.01.14.56.01.012.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), nei)
--[ 2022.11.01.14.56.02.930.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), neighbors)
--[ 2022.11.01.14.56.02.936.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), neighbors())
--[ 2022.11.01.14.56.04.752.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), nei)
--[ 2022.11.01.14.56.05.865.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), ne)
--[ 2022.11.01.14.56.06.014.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), n)
--[ 2022.11.01.14.56.06.233.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), )
--[ 2022.11.01.14.56.38.111.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), t)
--[ 2022.11.01.14.56.38.169.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), th)
--[ 2022.11.01.14.56.38.296.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), thi)
--[ 2022.11.01.14.56.38.372.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this)
--[ 2022.11.01.14.56.38.908.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.)
--[ 2022.11.01.14.56.47.265.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.p)
--[ 2022.11.01.14.56.47.344.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.pr)
--[ 2022.11.01.14.56.47.391.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.pre)
--[ 2022.11.01.14.56.47.905.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode)
--[ 2022.11.01.14.56.59.563.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.)
--[ 2022.11.01.14.57.04.046.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.c)
--[ 2022.11.01.14.57.04.188.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.cu)
--[ 2022.11.01.14.57.04.660.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile)
--[ 2022.11.01.14.57.06.930.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) 
--[ 2022.11.01.14.57.07.289.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) +
--[ 2022.11.01.14.57.07.418.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + 
--[ 2022.11.01.14.57.11.267.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t
--[ 2022.11.01.14.57.11.377.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.
--[ 2022.11.01.14.57.11.578.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.c
--[ 2022.11.01.14.57.11.655.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.co
--[ 2022.11.01.14.57.11.742.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.com
--[ 2022.11.01.14.57.11.796.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.comp
--[ 2022.11.01.14.57.12.009.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.compu
--[ 2022.11.01.14.57.13.582.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost
--[ 2022.11.01.14.57.13.589.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost()
--[ 2022.11.01.14.57.18.853.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost(t)
--[ 2022.11.01.14.57.18.911.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost(th)
--[ 2022.11.01.14.57.18.996.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost(thi)
--[ 2022.11.01.14.57.19.042.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost(this)
--[ 2022.11.01.14.57.19.244.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost(this.)
--[ 2022.11.01.14.57.20.234.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost(this)
--[ 2022.11.01.14.57.20.368.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost(thi)
--[ 2022.11.01.14.57.20.537.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost(th)
--[ 2022.11.01.14.57.20.712.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost(t)
--[ 2022.11.01.14.57.20.894.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost()
--[ 2022.11.01.14.57.21.595.0 ]--
+ 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost(
r 53             )
--[ 2022.11.01.14.57.21.619.0 ]--
+ 53                     
--[ 2022.11.01.14.57.23.074.0 ]--
r 53                     t
--[ 2022.11.01.14.57.23.179.0 ]--
r 53                     th
--[ 2022.11.01.14.57.23.235.0 ]--
r 53                     thi
--[ 2022.11.01.14.57.23.302.0 ]--
r 53                     this
--[ 2022.11.01.14.57.23.630.0 ]--
r 53                     this.
--[ 2022.11.01.14.57.24.683.0 ]--
r 53                     this.t
--[ 2022.11.01.14.57.24.924.0 ]--
r 53                     this.tr
--[ 2022.11.01.14.57.24.989.0 ]--
r 53                     this.tra
--[ 2022.11.01.14.57.25.361.0 ]--
r 53                     this.tr
--[ 2022.11.01.14.57.25.874.0 ]--
r 53                     this.t
--[ 2022.11.01.14.57.25.947.0 ]--
r 53                     this.
--[ 2022.11.01.14.57.26.031.0 ]--
r 53                     this
--[ 2022.11.01.14.57.26.116.0 ]--
r 53                     thi
--[ 2022.11.01.14.57.26.199.0 ]--
r 53                     th
--[ 2022.11.01.14.57.26.283.0 ]--
r 53                     t
--[ 2022.11.01.14.57.26.367.0 ]--
r 53                     
--[ 2022.11.01.14.57.26.478.0 ]--
- 53
--[ 2022.11.01.14.57.26.543.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCost
--[ 2022.11.01.14.57.26.749.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCos
--[ 2022.11.01.14.57.27.313.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelCo
--[ 2022.11.01.14.57.27.815.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravelC
--[ 2022.11.01.14.57.27.897.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTravel
--[ 2022.11.01.14.57.27.981.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTrave
--[ 2022.11.01.14.57.28.065.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTrav
--[ 2022.11.01.14.57.28.149.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTra
--[ 2022.11.01.14.57.28.233.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeTr
--[ 2022.11.01.14.57.28.317.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.computeT
--[ 2022.11.01.14.57.28.404.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.compute
--[ 2022.11.01.14.57.28.485.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.comput
--[ 2022.11.01.14.57.28.569.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.compu
--[ 2022.11.01.14.57.28.651.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.comp
--[ 2022.11.01.14.57.28.735.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.com
--[ 2022.11.01.14.57.28.818.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.co
--[ 2022.11.01.14.57.28.904.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.c
--[ 2022.11.01.14.57.28.986.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t.
--[ 2022.11.01.14.57.29.070.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + t
--[ 2022.11.01.14.57.29.153.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) + 
--[ 2022.11.01.14.57.36.115.0 ]--
r 53             
--[ 2022.11.01.14.57.36.306.0 ]--
- 52
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) +
--[ 2022.11.01.14.57.37.513.0 ]--
+ 53             
--[ 2022.11.01.14.57.37.525.0 ]--
r 53                     
--[ 2022.11.01.14.57.39.762.0 ]--
- 53
--[ 2022.11.01.14.58.20.179.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile) 
--[ 2022.11.01.14.58.20.939.0 ]--
r 52             this.cost = t.computeTravelCost(getPathStart(), this.prevNode.currentTile)
--[ 2022.11.01.14.58.21.701.0 ]--
+ 53             
--[ 2022.11.01.14.58.21.719.0 ]--
r 53                     
--[ 2022.11.01.14.58.23.440.0 ]--
r 53                     +
--[ 2022.11.01.14.58.23.630.0 ]--
r 53                     + 
--[ 2022.11.01.14.58.25.102.0 ]--
r 53                     + t
--[ 2022.11.01.14.58.25.219.0 ]--
r 53                     + t.
--[ 2022.11.01.14.58.25.468.0 ]--
r 53                     + t.c
--[ 2022.11.01.14.58.25.506.0 ]--
r 53                     + t.co
--[ 2022.11.01.14.58.25.611.0 ]--
r 53                     + t.com
--[ 2022.11.01.14.58.26.786.0 ]--
r 53                     + t.computeTravelCost
--[ 2022.11.01.14.58.26.791.0 ]--
r 53                     + t.computeTravelCost()
--[ 2022.11.01.14.58.33.732.0 ]--
r 53                     + t.computeTravelCost(n)
--[ 2022.11.01.14.58.33.793.0 ]--
r 53                     + t.computeTravelCost(ne)
--[ 2022.11.01.14.58.33.918.0 ]--
r 53                     + t.computeTravelCost(nei)
--[ 2022.11.01.14.58.35.075.0 ]--
r 53                     + t.computeTravelCost(ne)
--[ 2022.11.01.14.58.35.222.0 ]--
r 53                     + t.computeTravelCost(n)
--[ 2022.11.01.14.58.35.401.0 ]--
r 53                     + t.computeTravelCost()
--[ 2022.11.01.14.58.35.642.0 ]--
r 53                     + t.computeTravelCost(t)
--[ 2022.11.01.14.58.35.707.0 ]--
r 53                     + t.computeTravelCost(th)
--[ 2022.11.01.14.58.35.809.0 ]--
r 53                     + t.computeTravelCost(thi)
--[ 2022.11.01.14.58.35.856.0 ]--
r 53                     + t.computeTravelCost(this)
--[ 2022.11.01.14.58.36.062.0 ]--
r 53                     + t.computeTravelCost(this.)
--[ 2022.11.01.14.58.39.380.0 ]--
r 53                     + t.computeTravelCost(this.p)
--[ 2022.11.01.14.58.39.424.0 ]--
r 53                     + t.computeTravelCost(this.pr)
--[ 2022.11.01.14.58.39.536.0 ]--
r 53                     + t.computeTravelCost(this.pre)
--[ 2022.11.01.14.58.43.422.0 ]--
r 53                     + t.computeTravelCost(this.prevNode)
--[ 2022.11.01.14.58.44.573.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.)
--[ 2022.11.01.14.58.46.171.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.currentTile)
--[ 2022.11.01.14.58.47.573.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.currentTile,)
--[ 2022.11.01.14.58.47.694.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.currentTile, )
--[ 2022.11.01.14.58.50.202.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.currentTile, t)
--[ 2022.11.01.14.58.50.298.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.currentTile, th)
--[ 2022.11.01.14.58.50.325.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.currentTile, thi)
--[ 2022.11.01.14.58.50.415.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.currentTile, this)
--[ 2022.11.01.14.58.50.643.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.currentTile, this.)
--[ 2022.11.01.14.58.52.942.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
--[ 2022.11.01.14.58.54.119.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.currentTile, this.currentTile) 
--[ 2022.11.01.14.58.57.660.0 ]--
+ 54                     
--[ 2022.11.01.14.58.58.697.0 ]--
r 54                     +
--[ 2022.11.01.14.58.58.812.0 ]--
r 54                     + 
--[ 2022.11.01.14.58.59.662.0 ]--
r 54                     + ()
--[ 2022.11.01.14.59.01.311.0 ]--
r 54                     + (h)
--[ 2022.11.01.14.59.01.375.0 ]--
r 54                     + (he)
--[ 2022.11.01.14.59.02.204.0 ]--
r 54                     + (heuristic)
--[ 2022.11.01.14.59.03.758.0 ]--
r 54                     + (heuristic )
--[ 2022.11.01.14.59.04.318.0 ]--
r 54                     + (heuristic *)
--[ 2022.11.01.14.59.04.426.0 ]--
r 54                     + (heuristic * )
--[ 2022.11.01.14.59.05.802.0 ]--
r 53                     + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
--[ 2022.11.01.14.59.19.962.0 ]--
r 54                     + (heuristic * c)
--[ 2022.11.01.14.59.20.006.0 ]--
r 54                     + (heuristic * co)
--[ 2022.11.01.14.59.20.122.0 ]--
r 54                     + (heuristic * com)
--[ 2022.11.01.14.59.21.131.0 ]--
r 54                     + (heuristic * co)
--[ 2022.11.01.14.59.22.104.0 ]--
r 54                     + (heuristic * c)
--[ 2022.11.01.14.59.22.261.0 ]--
r 54                     + (heuristic * )
--[ 2022.11.01.14.59.22.387.0 ]--
r 54                     + (heuristic * t)
--[ 2022.11.01.14.59.22.533.0 ]--
r 54                     + (heuristic * t.)
--[ 2022.11.01.14.59.22.893.0 ]--
r 54                     + (heuristic * t.c)
--[ 2022.11.01.14.59.22.935.0 ]--
r 54                     + (heuristic * t.co)
--[ 2022.11.01.14.59.23.015.0 ]--
r 54                     + (heuristic * t.com)
--[ 2022.11.01.14.59.23.167.0 ]--
r 54                     + (heuristic * t.comp)
--[ 2022.11.01.14.59.26.193.0 ]--
r 54                     + (heuristic * t.computeDistance)
--[ 2022.11.01.14.59.26.199.0 ]--
r 54                     + (heuristic * t.computeDistance())
--[ 2022.11.01.14.59.28.471.0 ]--
r 54                     + (heuristic * t.computeDistance(t))
--[ 2022.11.01.14.59.28.553.0 ]--
r 54                     + (heuristic * t.computeDistance(th))
--[ 2022.11.01.14.59.28.606.0 ]--
r 54                     + (heuristic * t.computeDistance(thi))
--[ 2022.11.01.14.59.28.692.0 ]--
r 54                     + (heuristic * t.computeDistance(this))
--[ 2022.11.01.14.59.28.862.0 ]--
r 54                     + (heuristic * t.computeDistance(this.))
--[ 2022.11.01.14.59.29.136.0 ]--
r 54                     + (heuristic * t.computeDistance(this.c))
--[ 2022.11.01.14.59.29.224.0 ]--
r 54                     + (heuristic * t.computeDistance(this.cu))
--[ 2022.11.01.14.59.29.954.0 ]--
r 54                     + (heuristic * t.computeDistance(this.currentTile))
--[ 2022.11.01.14.59.30.652.0 ]--
r 54                     + (heuristic * t.computeDistance(this.currentTile,))
--[ 2022.11.01.14.59.30.780.0 ]--
r 54                     + (heuristic * t.computeDistance(this.currentTile, ))
--[ 2022.11.01.14.59.31.844.0 ]--
r 54                     + (heuristic * t.computeDistance(this.currentTile, g))
--[ 2022.11.01.14.59.31.948.0 ]--
r 54                     + (heuristic * t.computeDistance(this.currentTile, ge))
--[ 2022.11.01.14.59.32.060.0 ]--
r 54                     + (heuristic * t.computeDistance(this.currentTile, get))
--[ 2022.11.01.14.59.33.052.0 ]--
r 54                     + (heuristic * t.computeDistance(this.currentTile, getPathEnd))
--[ 2022.11.01.14.59.33.057.0 ]--
r 54                     + (heuristic * t.computeDistance(this.currentTile, getPathEnd()))
--[ 2022.11.01.14.59.34.971.0 ]--
r 54                     + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
--[ 2022.11.01.14.59.39.567.0 ]--
r 55             return ;
--[ 2022.11.01.14.59.40.388.0 ]--
r 55             return t;
--[ 2022.11.01.14.59.40.467.0 ]--
r 55             return th;
--[ 2022.11.01.14.59.40.529.0 ]--
r 55             return thi;
--[ 2022.11.01.14.59.40.605.0 ]--
r 55             return this;
--[ 2022.11.01.14.59.40.741.0 ]--
r 55             return this.;
--[ 2022.11.01.14.59.41.003.0 ]--
r 55             return this.c;
--[ 2022.11.01.14.59.41.100.0 ]--
r 55             return this.co;
--[ 2022.11.01.14.59.41.178.0 ]--
r 55             return this.cos;
--[ 2022.11.01.14.59.41.293.0 ]--
r 55             return this.cost;
--[ 2022.11.01.15.02.04.765.0 ]--
+ 65             
--[ 2022.11.01.15.02.05.563.0 ]--
r 65             t
--[ 2022.11.01.15.02.05.640.0 ]--
r 65             th
--[ 2022.11.01.15.02.05.693.0 ]--
r 65             thi
--[ 2022.11.01.15.02.05.759.0 ]--
r 65             this
--[ 2022.11.01.15.02.05.937.0 ]--
r 65             this.
--[ 2022.11.01.15.02.13.226.0 ]--
r 65             this
--[ 2022.11.01.15.02.13.341.0 ]--
r 65             thi
--[ 2022.11.01.15.02.13.517.0 ]--
r 65             th
--[ 2022.11.01.15.02.13.682.0 ]--
r 65             t
--[ 2022.11.01.15.02.13.852.0 ]--
r 65             
--[ 2022.11.01.15.02.14.180.0 ]--
- 65
--[ 2022.11.01.15.11.35.923.0 ]--
+ 116         
--[ 2022.11.01.15.11.36.105.0 ]--
r 116         /
--[ 2022.11.01.15.11.36.236.0 ]--
r 116         //
--[ 2022.11.01.15.11.37.139.0 ]--
r 116         // 
--[ 2022.11.01.15.11.37.307.0 ]--
r 116         // s
--[ 2022.11.01.15.11.37.316.0 ]--
r 116         // su
--[ 2022.11.01.15.11.37.507.0 ]--
r 116         // sue
--[ 2022.11.01.15.11.37.637.0 ]--
r 116         // sue 
--[ 2022.11.01.15.11.38.100.0 ]--
r 116         // sue
--[ 2022.11.01.15.11.38.261.0 ]--
r 116         // su
--[ 2022.11.01.15.11.38.436.0 ]--
r 116         // s
--[ 2022.11.01.15.11.38.594.0 ]--
r 116         // 
--[ 2022.11.01.15.11.38.722.0 ]--
r 116         // u
--[ 2022.11.01.15.11.38.820.0 ]--
r 116         // us
--[ 2022.11.01.15.11.38.935.0 ]--
r 116         // use
--[ 2022.11.01.15.11.39.041.0 ]--
r 116         // use 
--[ 2022.11.01.15.11.39.992.0 ]--
r 116         // use d
--[ 2022.11.01.15.11.40.099.0 ]--
r 116         // use di
--[ 2022.11.01.15.11.40.284.0 ]--
r 116         // use dik
--[ 2022.11.01.15.11.40.538.0 ]--
r 116         // use diks
--[ 2022.11.01.15.11.40.607.0 ]--
r 116         // use dikst
--[ 2022.11.01.15.11.40.793.0 ]--
r 116         // use dikstr
--[ 2022.11.01.15.11.40.865.0 ]--
r 116         // use dikstra
--[ 2022.11.01.15.11.41.221.0 ]--
r 116         // use dikstra'
--[ 2022.11.01.15.11.41.337.0 ]--
r 116         // use dikstra's
--[ 2022.11.01.15.11.41.455.0 ]--
r 116         // use dikstra's 
--[ 2022.11.01.15.11.41.840.0 ]--
r 116         // use dikstra's a
--[ 2022.11.01.15.11.41.957.0 ]--
r 116         // use dikstra's al
--[ 2022.11.01.15.11.42.077.0 ]--
r 116         // use dikstra's alg
--[ 2022.11.01.15.11.42.211.0 ]--
r 116         // use dikstra's algo
--[ 2022.11.01.15.11.42.330.0 ]--
r 116         // use dikstra's algor
--[ 2022.11.01.15.11.42.577.0 ]--
r 116         // use dikstra's algori
--[ 2022.11.01.15.11.42.696.0 ]--
r 116         // use dikstra's algorit
--[ 2022.11.01.15.11.42.812.0 ]--
r 116         // use dikstra's algorith
--[ 2022.11.01.15.11.43.012.0 ]--
r 116         // use dikstra's algorithm
--[ 2022.11.01.15.11.44.293.0 ]--
r 116         // use dikstra's algorithm 
--[ 2022.11.01.15.11.44.420.0 ]--
r 116         // use dikstra's algorithm h
--[ 2022.11.01.15.11.44.481.0 ]--
r 116         // use dikstra's algorithm he
--[ 2022.11.01.15.11.44.580.0 ]--
r 116         // use dikstra's algorithm her
--[ 2022.11.01.15.11.44.681.0 ]--
r 116         // use dikstra's algorithm here
--[ 2022.11.01.15.11.46.108.0 ]--
r 116         // use dikstra's algorithm here 
--[ 2022.11.01.15.11.46.245.0 ]--
r 116         // use dikstra's algorithm here a
--[ 2022.11.01.15.11.46.326.0 ]--
r 116         // use dikstra's algorithm here al
--[ 2022.11.01.15.11.46.506.0 ]--
r 116         // use dikstra's algorithm here alo
--[ 2022.11.01.15.11.46.605.0 ]--
r 116         // use dikstra's algorithm here alon
--[ 2022.11.01.15.11.46.661.0 ]--
r 116         // use dikstra's algorithm here along
--[ 2022.11.01.15.11.46.759.0 ]--
r 116         // use dikstra's algorithm here along 
--[ 2022.11.01.15.11.46.834.0 ]--
r 116         // use dikstra's algorithm here along w
--[ 2022.11.01.15.11.46.922.0 ]--
r 116         // use dikstra's algorithm here along wi
--[ 2022.11.01.15.11.46.969.0 ]--
r 116         // use dikstra's algorithm here along wit
--[ 2022.11.01.15.11.47.106.0 ]--
r 116         // use dikstra's algorithm here along with
--[ 2022.11.01.15.11.47.176.0 ]--
r 116         // use dikstra's algorithm here along with 
--[ 2022.11.01.15.11.47.500.0 ]--
r 116         // use dikstra's algorithm here along with m
--[ 2022.11.01.15.11.47.676.0 ]--
r 116         // use dikstra's algorithm here along with mi
--[ 2022.11.01.15.11.47.729.0 ]--
r 116         // use dikstra's algorithm here along with min
--[ 2022.11.01.15.11.48.772.0 ]--
r 116         // use dikstra's algorithm here along with minP
--[ 2022.11.01.15.11.49.184.0 ]--
r 116         // use dikstra's algorithm here along with minPQ
--[ 2022.11.01.15.11.52.743.0 ]--
r 116         // use dikstra's algorithm here along with minPQ(
--[ 2022.11.01.15.11.52.962.0 ]--
r 116         // use dikstra's algorithm here along with minPQ()
--[ 2022.11.01.15.11.55.521.0 ]--
r 116         // use dikstra's algorithm here along with minPQ(
--[ 2022.11.01.15.11.55.653.0 ]--
r 116         // use dikstra's algorithm here along with minPQ
--[ 2022.11.01.15.13.58.371.0 ]--
+ 117         
--[ 2022.11.01.15.13.59.237.0 ]--
r 117         /
--[ 2022.11.01.15.13.59.356.0 ]--
r 117         //
--[ 2022.11.01.15.14.00.048.0 ]--
r 117         // 
--[ 2022.11.01.15.14.00.299.0 ]--
r 117         // t
--[ 2022.11.01.15.14.00.467.0 ]--
r 117         // tr
--[ 2022.11.01.15.14.00.579.0 ]--
r 117         // tra
--[ 2022.11.01.15.14.00.770.0 ]--
r 117         // trav
--[ 2022.11.01.15.14.00.910.0 ]--
r 117         // trave
--[ 2022.11.01.15.14.01.019.0 ]--
r 117         // travel
--[ 2022.11.01.15.14.01.869.0 ]--
r 117         // travelC
--[ 2022.11.01.15.14.01.984.0 ]--
r 117         // travelCo
--[ 2022.11.01.15.14.02.077.0 ]--
r 117         // travelCos
--[ 2022.11.01.15.14.02.190.0 ]--
r 117         // travelCost
--[ 2022.11.01.15.14.02.331.0 ]--
r 117         // travelCost 
--[ 2022.11.01.15.14.02.601.0 ]--
r 117         // travelCost  
--[ 2022.11.01.15.14.02.957.0 ]--
r 117         // travelCost 
--[ 2022.11.01.15.14.03.201.0 ]--
r 117         // travelCost =
--[ 2022.11.01.15.14.03.330.0 ]--
r 117         // travelCost = 
--[ 2022.11.01.15.14.06.411.0 ]--
r 117         // travelCost =
--[ 2022.11.01.15.14.06.902.0 ]--
r 117         // travelCost 
--[ 2022.11.01.15.14.06.986.0 ]--
r 117         // travelCost
--[ 2022.11.01.15.14.07.070.0 ]--
r 117         // travelCos
--[ 2022.11.01.15.14.07.153.0 ]--
r 117         // travelCo
--[ 2022.11.01.15.14.07.237.0 ]--
r 117         // travelC
--[ 2022.11.01.15.14.07.320.0 ]--
r 117         // travel
--[ 2022.11.01.15.14.07.402.0 ]--
r 117         // trave
--[ 2022.11.01.15.14.07.487.0 ]--
r 117         // trav
--[ 2022.11.01.15.14.07.568.0 ]--
r 117         // tra
--[ 2022.11.01.15.14.07.651.0 ]--
r 117         // tr
--[ 2022.11.01.15.14.07.738.0 ]--
r 117         // t
--[ 2022.11.01.15.14.08.081.0 ]--
r 117         // 
--[ 2022.11.01.15.14.08.575.0 ]--
r 117         // t
--[ 2022.11.01.15.14.08.633.0 ]--
r 117         // to
--[ 2022.11.01.15.14.08.760.0 ]--
r 117         // tot
--[ 2022.11.01.15.14.08.870.0 ]--
r 117         // tota
--[ 2022.11.01.15.14.09.007.0 ]--
r 117         // total
--[ 2022.11.01.15.14.09.488.0 ]--
r 117         // totalC
--[ 2022.11.01.15.14.09.596.0 ]--
r 117         // totalCo
--[ 2022.11.01.15.14.09.700.0 ]--
r 117         // totalCos
--[ 2022.11.01.15.14.09.784.0 ]--
r 117         // totalCost
--[ 2022.11.01.15.14.10.026.0 ]--
r 117         // totalCost 
--[ 2022.11.01.15.14.10.171.0 ]--
r 117         // totalCost =
--[ 2022.11.01.15.14.10.288.0 ]--
r 117         // totalCost = 
--[ 2022.11.01.15.14.12.212.0 ]--
r 117         // totalCost = (
--[ 2022.11.01.15.14.12.468.0 ]--
r 117         // totalCost = (q
--[ 2022.11.01.15.14.13.067.0 ]--
r 117         // totalCost = (
--[ 2022.11.01.15.14.13.416.0 ]--
r 117         // totalCost = (1
--[ 2022.11.01.15.14.13.876.0 ]--
r 117         // totalCost = (1 
--[ 2022.11.01.15.14.14.013.0 ]--
r 117         // totalCost = (1 +
--[ 2022.11.01.15.14.14.064.0 ]--
r 117         // totalCost = (1 + 
--[ 2022.11.01.15.14.15.414.0 ]--
r 117         // totalCost = (1 + c
--[ 2022.11.01.15.14.15.536.0 ]--
r 117         // totalCost = (1 + cl
--[ 2022.11.01.15.14.15.646.0 ]--
r 117         // totalCost = (1 + cli
--[ 2022.11.01.15.14.15.724.0 ]--
r 117         // totalCost = (1 + clim
--[ 2022.11.01.15.14.15.930.0 ]--
r 117         // totalCost = (1 + climb
--[ 2022.11.01.15.14.16.579.0 ]--
r 117         // totalCost = (1 + climb(
--[ 2022.11.01.15.14.19.718.0 ]--
r 117         // totalCost = (1 + climb(p
--[ 2022.11.01.15.14.19.822.0 ]--
r 117         // totalCost = (1 + climb(pr
--[ 2022.11.01.15.14.19.901.0 ]--
r 117         // totalCost = (1 + climb(pre
--[ 2022.11.01.15.14.20.383.0 ]--
r 117         // totalCost = (1 + climb(prev
--[ 2022.11.01.15.14.22.166.0 ]--
r 117         // totalCost = (1 + climb(prevN
--[ 2022.11.01.15.14.22.415.0 ]--
r 117         // totalCost = (1 + climb(prevNo
--[ 2022.11.01.15.14.22.491.0 ]--
r 117         // totalCost = (1 + climb(prevNod
--[ 2022.11.01.15.14.22.642.0 ]--
r 117         // totalCost = (1 + climb(prevNode
--[ 2022.11.01.15.14.22.970.0 ]--
r 117         // totalCost = (1 + climb(prevNode,
--[ 2022.11.01.15.14.23.058.0 ]--
r 117         // totalCost = (1 + climb(prevNode, 
--[ 2022.11.01.15.14.23.245.0 ]--
r 117         // totalCost = (1 + climb(prevNode, c
--[ 2022.11.01.15.14.24.562.0 ]--
r 117         // totalCost = (1 + climb(prevNode, 
--[ 2022.11.01.15.14.24.754.0 ]--
r 117         // totalCost = (1 + climb(prevNode, t
--[ 2022.11.01.15.14.24.829.0 ]--
r 117         // totalCost = (1 + climb(prevNode, th
--[ 2022.11.01.15.14.24.914.0 ]--
r 117         // totalCost = (1 + climb(prevNode, thi
--[ 2022.11.01.15.14.24.975.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this
--[ 2022.11.01.15.14.25.442.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)
--[ 2022.11.01.15.14.26.384.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this
--[ 2022.11.01.15.14.26.576.0 ]--
r 117         // totalCost = (1 + climb(prevNode, thi
--[ 2022.11.01.15.14.27.457.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this
--[ 2022.11.01.15.14.27.635.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)
--[ 2022.11.01.15.14.33.459.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this))
--[ 2022.11.01.15.14.33.972.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) 
--[ 2022.11.01.15.14.34.512.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) *
--[ 2022.11.01.15.14.34.624.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * 
--[ 2022.11.01.15.14.35.203.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (
--[ 2022.11.01.15.14.40.175.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (d
--[ 2022.11.01.15.14.40.279.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (di
--[ 2022.11.01.15.14.40.393.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (dis
--[ 2022.11.01.15.14.40.506.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (dist
--[ 2022.11.01.15.14.40.603.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (dista
--[ 2022.11.01.15.14.40.757.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distan
--[ 2022.11.01.15.14.40.853.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distanc
--[ 2022.11.01.15.14.41.014.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance
--[ 2022.11.01.15.14.41.752.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(
--[ 2022.11.01.15.14.43.287.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(p
--[ 2022.11.01.15.14.43.361.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(pr
--[ 2022.11.01.15.14.44.074.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(pre
--[ 2022.11.01.15.14.44.252.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prev
--[ 2022.11.01.15.14.44.540.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevN
--[ 2022.11.01.15.14.44.633.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevNo
--[ 2022.11.01.15.14.44.783.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevNod
--[ 2022.11.01.15.14.44.930.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevNode
--[ 2022.11.01.15.14.45.506.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevNode,
--[ 2022.11.01.15.14.45.607.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevNode, 
--[ 2022.11.01.15.14.45.954.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevNode, t
--[ 2022.11.01.15.14.45.996.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevNode, th
--[ 2022.11.01.15.14.46.066.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevNode, thi
--[ 2022.11.01.15.14.46.135.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevNode, this
--[ 2022.11.01.15.14.46.409.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevNode, this)
--[ 2022.11.01.15.14.47.142.0 ]--
r 117         // totalCost = (1 + climb(prevNode, this)) * (distance(prevNode, this))
--[ 2022.11.01.15.16.54.281.0 ]--
+ 118         
--[ 2022.11.01.15.16.55.501.0 ]--
r 118         t
--[ 2022.11.01.15.16.55.627.0 ]--
r 118         to
--[ 2022.11.01.15.16.55.678.0 ]--
r 118         tot
--[ 2022.11.01.15.16.55.741.0 ]--
r 118         tota
--[ 2022.11.01.15.16.55.878.0 ]--
r 118         total
--[ 2022.11.01.15.16.56.323.0 ]--
r 118         totalC
--[ 2022.11.01.15.16.56.445.0 ]--
r 118         totalCo
--[ 2022.11.01.15.16.56.529.0 ]--
r 118         totalCos
--[ 2022.11.01.15.16.56.638.0 ]--
r 118         totalCost
--[ 2022.11.01.15.16.56.788.0 ]--
r 118         totalCost 
--[ 2022.11.01.15.16.56.932.0 ]--
r 118         totalCost =
--[ 2022.11.01.15.16.57.028.0 ]--
r 118         totalCost = 
--[ 2022.11.01.15.16.57.978.0 ]--
r 118         totalCost = ()
--[ 2022.11.01.15.17.03.392.0 ]--
r 118          = ()
--[ 2022.11.01.15.17.04.292.0 ]--
r 118         d = ()
--[ 2022.11.01.15.17.04.361.0 ]--
r 118         di = ()
--[ 2022.11.01.15.17.04.463.0 ]--
r 118         dis = ()
--[ 2022.11.01.15.17.04.965.0 ]--
r 118         di = ()
--[ 2022.11.01.15.17.05.020.0 ]--
r 118         dik = ()
--[ 2022.11.01.15.17.05.268.0 ]--
r 118         diks = ()
--[ 2022.11.01.15.17.05.418.0 ]--
r 118         dikst = ()
--[ 2022.11.01.15.17.05.575.0 ]--
r 118         dikstr = ()
--[ 2022.11.01.15.17.05.689.0 ]--
r 118         dikstra = ()
--[ 2022.11.01.15.17.10.727.0 ]--
+ 14     
--[ 2022.11.01.15.17.11.154.0 ]--
r 14     d
--[ 2022.11.01.15.17.11.281.0 ]--
r 14     di
--[ 2022.11.01.15.17.11.328.0 ]--
r 14     dis
--[ 2022.11.01.15.17.11.468.0 ]--
r 14     disk
--[ 2022.11.01.15.17.11.947.0 ]--
r 14     disks
--[ 2022.11.01.15.17.12.427.0 ]--
r 14     disk
--[ 2022.11.01.15.17.12.574.0 ]--
r 14     dis
--[ 2022.11.01.15.17.12.725.0 ]--
r 14     di
--[ 2022.11.01.15.17.12.840.0 ]--
r 14     dik
--[ 2022.11.01.15.17.12.951.0 ]--
r 14     diks
--[ 2022.11.01.15.17.13.022.0 ]--
r 14     dikst
--[ 2022.11.01.15.17.13.171.0 ]--
r 14     dikstr
--[ 2022.11.01.15.17.13.265.0 ]--
r 14     dikstra
--[ 2022.11.01.15.17.14.670.0 ]--
r 14     dikstra;
--[ 2022.11.01.15.17.16.956.0 ]--
r 14     fdikstra;
--[ 2022.11.01.15.17.17.029.0 ]--
r 14     fldikstra;
--[ 2022.11.01.15.17.17.198.0 ]--
r 14     flodikstra;
--[ 2022.11.01.15.17.17.300.0 ]--
r 14     floadikstra;
--[ 2022.11.01.15.17.17.396.0 ]--
r 14     floatdikstra;
--[ 2022.11.01.15.17.17.531.0 ]--
r 14     float dikstra;
--[ 2022.11.01.15.17.30.996.0 ]--
r 119         dikstra = (1)
--[ 2022.11.01.15.17.31.236.0 ]--
r 119         dikstra = (1 )
--[ 2022.11.01.15.17.31.408.0 ]--
r 119         dikstra = (1 =)
--[ 2022.11.01.15.17.32.759.0 ]--
r 119         dikstra = (1 )
--[ 2022.11.01.15.17.33.043.0 ]--
r 119         dikstra = (1 +)
--[ 2022.11.01.15.17.33.279.0 ]--
r 119         dikstra = (1 + )
--[ 2022.11.01.15.17.35.050.0 ]--
r 119         dikstra = (1 + c)
--[ 2022.11.01.15.17.37.126.0 ]--
r 119         dikstra = (1 + )
--[ 2022.11.01.15.17.37.284.0 ]--
r 119         dikstra = (1 + g)
--[ 2022.11.01.15.17.37.364.0 ]--
r 119         dikstra = (1 + ge)
--[ 2022.11.01.15.17.37.457.0 ]--
r 119         dikstra = (1 + get)
--[ 2022.11.01.15.17.38.678.0 ]--
r 119         dikstra = (1 + ge)
--[ 2022.11.01.15.17.38.826.0 ]--
r 119         dikstra = (1 + g)
--[ 2022.11.01.15.17.39.015.0 ]--
r 119         dikstra = (1 + )
--[ 2022.11.01.15.17.39.157.0 ]--
r 119         dikstra = (1 + t)
--[ 2022.11.01.15.17.39.266.0 ]--
r 119         dikstra = (1 + t.)
--[ 2022.11.01.15.17.39.750.0 ]--
r 119         dikstra = (1 + t.g)
--[ 2022.11.01.15.17.39.831.0 ]--
r 119         dikstra = (1 + t.ge)
--[ 2022.11.01.15.17.39.953.0 ]--
r 119         dikstra = (1 + t.get)
--[ 2022.11.01.15.17.42.216.0 ]--
r 119         dikstra = (1 + t.getHeight)
--[ 2022.11.01.15.17.42.222.0 ]--
r 119         dikstra = (1 + t.getHeight())
--[ 2022.11.01.15.21.54.128.0 ]--
r 119         dikstra = (1 + 
--[ 2022.11.01.15.22.13.243.0 ]--
r 119         dikstra = (1 +
--[ 2022.11.01.15.24.04.623.0 ]--
r 119        
--[ 2022.11.01.15.24.04.937.0 ]--
- 119
--[ 2022.11.01.15.24.46.841.0 ]--
r 118         
--[ 2022.11.01.15.24.47.187.0 ]--
- 118
--[ 2022.11.01.15.25.04.828.0 ]--
+ 118         
--[ 2022.11.01.15.25.06.210.0 ]--
r 118         w
--[ 2022.11.01.15.25.06.358.0 ]--
r 118         wh
--[ 2022.11.01.15.25.06.365.0 ]--
r 118         whi
--[ 2022.11.01.15.25.06.853.0 ]--
r 118         whil
--[ 2022.11.01.15.25.06.944.0 ]--
r 118         while
--[ 2022.11.01.15.25.07.146.0 ]--
r 118         while 
--[ 2022.11.01.15.25.07.835.0 ]--
r 118         while
--[ 2022.11.01.15.25.07.950.0 ]--
r 118         while()
--[ 2022.11.01.15.25.08.134.0 ]--
r 118         while( )
--[ 2022.11.01.15.25.08.955.0 ]--
r 118         while()
--[ 2022.11.01.15.25.12.187.0 ]--
r 118         while(!)
--[ 2022.11.01.15.25.12.754.0 ]--
r 118         while(!n)
--[ 2022.11.01.15.25.12.872.0 ]--
r 118         while(!no)
--[ 2022.11.01.15.25.13.306.0 ]--
r 118         while(!n)
--[ 2022.11.01.15.25.13.468.0 ]--
r 118         while(!)
--[ 2022.11.01.15.25.13.562.0 ]--
r 118         while(!d)
--[ 2022.11.01.15.25.13.626.0 ]--
r 118         while(!do)
--[ 2022.11.01.15.25.13.721.0 ]--
r 118         while(!don)
--[ 2022.11.01.15.25.13.809.0 ]--
r 118         while(!done)
--[ 2022.11.01.15.25.15.749.0 ]--
r 118         while(!done) 
--[ 2022.11.01.15.25.16.004.0 ]--
r 118         while(!done) {
--[ 2022.11.01.15.25.16.268.0 ]--
+ 119 
+ 120 }
--[ 2022.11.01.15.25.16.282.0 ]--
r 120         }
--[ 2022.11.01.15.25.16.298.0 ]--
r 119             
--[ 2022.11.01.15.25.34.913.0 ]--
r 118         while(!) {
--[ 2022.11.01.15.25.35.057.0 ]--
r 118         while() {
--[ 2022.11.01.15.25.38.231.0 ]--
r 118         while(f) {
--[ 2022.11.01.15.25.38.699.0 ]--
r 118         while(fo) {
--[ 2022.11.01.15.25.38.880.0 ]--
r 118         while(fou) {
--[ 2022.11.01.15.25.39.121.0 ]--
r 118         while(foun) {
--[ 2022.11.01.15.25.39.267.0 ]--
r 118         while(found) {
--[ 2022.11.01.15.25.40.107.0 ]--
r 118         while(foundPath) {
--[ 2022.11.01.15.25.40.113.0 ]--
r 118         while(foundPath()) {
--[ 2022.11.01.15.25.47.226.0 ]--
r 118         while(!foundPath()) {
--[ 2022.11.01.15.29.24.105.0 ]--
r 119 
--[ 2022.11.01.15.30.01.138.0 ]--
r 117         
--[ 2022.11.01.15.30.01.263.0 ]--
- 117
--[ 2022.11.01.15.30.03.771.0 ]--
r 118     
--[ 2022.11.01.15.30.03.915.0 ]--
r 118         
--[ 2022.11.01.15.30.07.084.0 ]--
r 118             
--[ 2022.11.01.15.31.18.019.0 ]--
+ 61             
--[ 2022.11.01.15.31.33.528.0 ]--
- 61
--[ 2022.11.01.15.31.36.451.0 ]--
r 61             return t;
--[ 2022.11.01.15.31.36.570.0 ]--
r 61             return th;
--[ 2022.11.01.15.31.36.612.0 ]--
r 61             return thi;
--[ 2022.11.01.15.31.36.659.0 ]--
r 61             return this;
--[ 2022.11.01.15.31.36.838.0 ]--
r 61             return this.;
--[ 2022.11.01.15.31.38.597.0 ]--
r 61             return this.s;
--[ 2022.11.01.15.31.39.813.0 ]--
r 61             return this.;
--[ 2022.11.01.15.31.40.530.0 ]--
r 61             return this;
--[ 2022.11.01.15.31.40.735.0 ]--
r 61             return thi;
--[ 2022.11.01.15.31.40.900.0 ]--
r 61             return th;
--[ 2022.11.01.15.31.41.074.0 ]--
r 61             return t;
--[ 2022.11.01.15.31.41.244.0 ]--
r 61             return ;
--[ 2022.11.01.15.31.48.029.0 ]--
+ 61             
--[ 2022.11.01.15.31.48.856.0 ]--
r 61             i
--[ 2022.11.01.15.31.48.958.0 ]--
r 61             if
--[ 2022.11.01.15.31.49.418.0 ]--
r 61             if()
--[ 2022.11.01.15.31.51.804.0 ]--
r 61             if(g)
--[ 2022.11.01.15.31.51.918.0 ]--
r 61             if(ge)
--[ 2022.11.01.15.31.52.056.0 ]--
r 61             if(get)
--[ 2022.11.01.15.31.52.573.0 ]--
r 61             if(ge)
--[ 2022.11.01.15.31.52.715.0 ]--
r 61             if(g)
--[ 2022.11.01.15.31.52.890.0 ]--
r 61             if()
--[ 2022.11.01.15.31.53.428.0 ]--
r 61             if(t)
--[ 2022.11.01.15.31.53.527.0 ]--
r 61             if(t.)
--[ 2022.11.01.15.31.53.847.0 ]--
r 61             if(t.g)
--[ 2022.11.01.15.31.53.943.0 ]--
r 61             if(t.ge)
--[ 2022.11.01.15.31.54.040.0 ]--
r 61             if(t.get)
--[ 2022.11.01.15.31.56.719.0 ]--
r 61             if(t.getHeight)
--[ 2022.11.01.15.31.56.725.0 ]--
r 61             if(t.getHeight())
--[ 2022.11.01.15.31.59.389.0 ]--
r 61             if(t.getHeight(t))
--[ 2022.11.01.15.31.59.455.0 ]--
r 61             if(t.getHeight(th))
--[ 2022.11.01.15.31.59.542.0 ]--
r 61             if(t.getHeight(thi))
--[ 2022.11.01.15.31.59.615.0 ]--
r 61             if(t.getHeight(this))
--[ 2022.11.01.15.31.59.785.0 ]--
r 61             if(t.getHeight(this.))
--[ 2022.11.01.15.32.02.016.0 ]--
r 61             if(t.getHeight(this.currentTile))
--[ 2022.11.01.15.32.08.799.0 ]--
r 61             if(t.getHeight(this.currentTile) )
--[ 2022.11.01.15.32.09.190.0 ]--
r 61             if(t.getHeight(this.currentTile) !)
--[ 2022.11.01.15.32.09.984.0 ]--
r 61             if(t.getHeight(this.currentTile) !=)
--[ 2022.11.01.15.32.10.501.0 ]--
r 61             if(t.getHeight(this.currentTile) != )
--[ 2022.11.01.15.32.10.598.0 ]--
r 61             if(t.getHeight(this.currentTile) != n)
--[ 2022.11.01.15.32.10.803.0 ]--
r 61             if(t.getHeight(this.currentTile) != nu)
--[ 2022.11.01.15.32.10.936.0 ]--
r 61             if(t.getHeight(this.currentTile) != nul)
--[ 2022.11.01.15.32.11.070.0 ]--
r 61             if(t.getHeight(this.currentTile) != null)
--[ 2022.11.01.15.32.13.271.0 ]--
r 61             if(t.getHeight(this.currentTile) != null) 
--[ 2022.11.01.15.32.13.522.0 ]--
r 61             if(t.getHeight(this.currentTile) != null) {
--[ 2022.11.01.15.32.13.701.0 ]--
+ 62 
+ 63 }
--[ 2022.11.01.15.32.13.708.0 ]--
r 63             }
--[ 2022.11.01.15.32.13.716.0 ]--
r 62                 
--[ 2022.11.01.15.32.14.896.0 ]--
r 62                 r
--[ 2022.11.01.15.32.14.967.0 ]--
r 62                 re
--[ 2022.11.01.15.32.15.145.0 ]--
r 62                 ret
--[ 2022.11.01.15.32.15.158.0 ]--
r 62                 retu
--[ 2022.11.01.15.32.15.327.0 ]--
r 62                 retur
--[ 2022.11.01.15.32.15.420.0 ]--
r 62                 return
--[ 2022.11.01.15.32.15.545.0 ]--
r 62                 return 
--[ 2022.11.01.15.32.15.914.0 ]--
r 62                 return t
--[ 2022.11.01.15.32.16.076.0 ]--
r 62                 return tr
--[ 2022.11.01.15.32.16.147.0 ]--
r 62                 return tru
--[ 2022.11.01.15.32.16.235.0 ]--
r 62                 return true
--[ 2022.11.01.15.32.17.921.0 ]--
r 62                 return true;
--[ 2022.11.01.15.32.19.981.0 ]--
r 64             return f;
--[ 2022.11.01.15.32.20.100.0 ]--
r 64             return fa;
--[ 2022.11.01.15.32.20.171.0 ]--
r 64             return fal;
--[ 2022.11.01.15.32.20.261.0 ]--
r 64             return fals;
--[ 2022.11.01.15.32.20.349.0 ]--
r 64             return false;
--[ 2022.11.01.15.32.21.097.0 ]--
r 121 
--[ 2022.11.01.15.34.05.038.0 ]--
r 61             if(t.getHeight(this.currentTile) ) {
--[ 2022.11.01.15.34.05.659.0 ]--
r 61             if(t.getHeight(this.currentTile)) {
--[ 2022.11.01.15.34.07.759.0 ]--
r 61             if(t.getHeight(this.currentTile) != null) {
--[ 2022.11.01.15.34.37.864.0 ]--
r 61             if(t.) {
--[ 2022.11.01.15.34.39.424.0 ]--
r 61             if(t.i) {
--[ 2022.11.01.15.34.39.510.0 ]--
r 61             if(t.is) {
--[ 2022.11.01.15.34.40.469.0 ]--
r 61             if(t.i) {
--[ 2022.11.01.15.34.40.647.0 ]--
r 61             if(t.) {
--[ 2022.11.01.15.34.40.798.0 ]--
r 61             if(t) {
--[ 2022.11.01.15.34.40.975.0 ]--
r 61             if() {
--[ 2022.11.01.15.34.41.491.0 ]--
r 61             if(i) {
--[ 2022.11.01.15.34.41.599.0 ]--
r 61             if(is) {
--[ 2022.11.01.15.34.42.758.0 ]--
r 61             if(i) {
--[ 2022.11.01.15.34.42.895.0 ]--
r 61             if() {
--[ 2022.11.01.15.34.53.184.0 ]--
r 61             if(t) {
--[ 2022.11.01.15.34.53.222.0 ]--
r 61             if(th) {
--[ 2022.11.01.15.34.53.321.0 ]--
r 61             if(thi) {
--[ 2022.11.01.15.34.53.406.0 ]--
r 61             if(this) {
--[ 2022.11.01.15.34.53.596.0 ]--
r 61             if(this.) {
--[ 2022.11.01.15.34.53.808.0 ]--
r 61             if(this.c) {
--[ 2022.11.01.15.34.53.922.0 ]--
r 61             if(this.cu) {
--[ 2022.11.01.15.34.54.005.0 ]--
r 61             if(this.cur) {
--[ 2022.11.01.15.34.54.552.0 ]--
r 61             if(this.currentTile) {
--[ 2022.11.01.15.34.54.976.0 ]--
r 61             if(this.currentTile.) {
--[ 2022.11.01.15.34.55.179.0 ]--
r 61             if(this.currentTile.i) {
--[ 2022.11.01.15.34.55.242.0 ]--
r 61             if(this.currentTile.is) {
--[ 2022.11.01.15.34.58.825.0 ]--
r 61             if(this.currentTile.isInBounds) {
--[ 2022.11.01.15.34.58.830.0 ]--
r 61             if(this.currentTile.isInBounds()) {
--[ 2022.11.01.15.37.40.265.0 ]--
r 120         while(!foundPath(t)) {
--[ 2022.11.01.15.37.40.411.0 ]--
r 120         while(!foundPath(t.)) {
--[ 2022.11.01.15.37.41.061.0 ]--
r 120         while(!foundPath(t.N)) {
--[ 2022.11.01.15.37.42.447.0 ]--
r 120         while(!foundPath(t.)) {
--[ 2022.11.01.15.37.42.557.0 ]--
r 120         while(!foundPath(t.n)) {
--[ 2022.11.01.15.37.43.667.0 ]--
r 120         while(!foundPath(t.getN)) {
--[ 2022.11.01.15.37.43.673.0 ]--
r 120         while(!foundPath(t.getN())) {
--[ 2022.11.01.15.37.56.163.0 ]--
r 120         while(!foundPath(t.getN()) {
--[ 2022.11.01.15.37.56.273.0 ]--
r 120         while(!foundPath(t.getN)) {
--[ 2022.11.01.15.37.56.417.0 ]--
r 120         while(!foundPath(t.get)) {
--[ 2022.11.01.15.37.56.587.0 ]--
r 120         while(!foundPath(t.ge)) {
--[ 2022.11.01.15.37.56.762.0 ]--
r 120         while(!foundPath(t.g)) {
--[ 2022.11.01.15.37.57.315.0 ]--
r 120         while(!foundPath(t.)) {
--[ 2022.11.01.15.37.57.953.0 ]--
r 120         while(!foundPath(t.N)) {
--[ 2022.11.01.15.38.04.159.0 ]--
r 120         while(!foundPath(t.)) {
--[ 2022.11.01.15.38.16.355.0 ]--
r 120         while(!foundPath(t.g)) {
--[ 2022.11.01.15.38.16.465.0 ]--
r 120         while(!foundPath(t.ge)) {
--[ 2022.11.01.15.38.18.244.0 ]--
r 120         while(!foundPath(t.getN)) {
--[ 2022.11.01.15.38.18.246.0 ]--
r 120         while(!foundPath(t.getN())) {
--[ 2022.11.01.15.38.31.037.0 ]--
r 120         while(!foundPath(t.ge)) {
--[ 2022.11.01.15.38.31.235.0 ]--
r 120         while(!foundPath(t.)) {
--[ 2022.11.01.15.38.31.418.0 ]--
r 120         while(!foundPath(t.N)) {
--[ 2022.11.01.15.38.31.802.0 ]--
r 120         while(!foundPath(t.)) {
--[ 2022.11.01.15.38.32.148.0 ]--
r 120         while(!foundPath(t.getN())) {
--[ 2022.11.01.15.38.32.515.0 ]--
r 120         while(!foundPath(t.n)) {
--[ 2022.11.01.15.38.32.929.0 ]--
r 120         while(!foundPath(t.)) {
--[ 2022.11.01.15.38.33.346.0 ]--
r 120         while(!foundPath(t.N)) {
--[ 2022.11.01.15.38.33.741.0 ]--
r 120         while(!foundPath()) {
--[ 2022.11.01.15.38.46.711.0 ]--
r 61             if(this.currentTile.isInBounds(0)) {
--[ 2022.11.01.15.38.47.112.0 ]--
r 61             if(this.currentTile.isInBounds(0,)) {
--[ 2022.11.01.15.38.49.125.0 ]--
r 61             if(this.currentTile.isInBounds(0,t)) {
--[ 2022.11.01.15.38.49.253.0 ]--
r 61             if(this.currentTile.isInBounds(0,t.)) {
--[ 2022.11.01.15.38.49.420.0 ]--
r 61             if(this.currentTile.isInBounds(0,t.g)) {
--[ 2022.11.01.15.38.49.502.0 ]--
r 61             if(this.currentTile.isInBounds(0,t.ge)) {
--[ 2022.11.01.15.38.50.072.0 ]--
r 61             if(this.currentTile.isInBounds(0,t.getN)) {
--[ 2022.11.01.15.38.50.077.0 ]--
r 61             if(this.currentTile.isInBounds(0,t.getN())) {
--[ 2022.11.01.15.39.26.504.0 ]--
r 61             if(this.currentTile.isInBounds(C0,t.getN())) {
--[ 2022.11.01.15.39.27.238.0 ]--
r 61             if(this.currentTile.isInBounds(Co0,t.getN())) {
--[ 2022.11.01.15.39.27.371.0 ]--
r 61             if(this.currentTile.isInBounds(Coo0,t.getN())) {
--[ 2022.11.01.15.39.27.466.0 ]--
r 61             if(this.currentTile.isInBounds(Coor0,t.getN())) {
--[ 2022.11.01.15.39.27.942.0 ]--
r 61             if(this.currentTile.isInBounds(Coord0,t.getN())) {
--[ 2022.11.01.15.39.29.064.0 ]--
r 61             if(this.currentTile.isInBounds(Coord 0,t.getN())) {
--[ 2022.11.01.15.39.29.076.0 ]--
r 61             if(this.currentTile.isInBounds(Coord0,t.getN())) {
--[ 2022.11.01.15.39.30.162.0 ]--
r 61             if(this.currentTile.isInBounds(Coord 0,t.getN())) {
--[ 2022.11.01.15.39.30.301.0 ]--
r 61             if(this.currentTile.isInBounds(Coord {0,t.getN())) {
--[ 2022.11.01.15.39.32.060.0 ]--
r 61             if(this.currentTile.isInBounds(Coord {0},t.getN())) {
--[ 2022.11.01.15.39.33.889.0 ]--
r 61             if(this.currentTile.isInBounds(Coord {0,},t.getN())) {
--[ 2022.11.01.15.39.34.527.0 ]--
r 61             if(this.currentTile.isInBounds(Coord {0,0},t.getN())) {
--[ 2022.11.01.15.39.50.889.0 ]--
r 61             if(this.currentTile.isInBounds(Coord 0,0},t.getN())) {
--[ 2022.11.01.15.39.51.004.0 ]--
r 61             if(this.currentTile.isInBounds(Coord0,0},t.getN())) {
--[ 2022.11.01.15.39.52.092.0 ]--
r 61             if(this.currentTile.isInBounds(Coord(0,0},t.getN())) {
--[ 2022.11.01.15.39.53.732.0 ]--
r 61             if(this.currentTile.isInBounds(Coord(0,0,t.getN())) {
--[ 2022.11.01.15.39.54.124.0 ]--
r 61             if(this.currentTile.isInBounds(Coord(0,0),t.getN())) {
--[ 2022.11.01.15.40.07.677.0 ]--
r 61             if(this.currentTile.isInBounds(nCoord(0,0),t.getN())) {
--[ 2022.11.01.15.40.07.748.0 ]--
r 61             if(this.currentTile.isInBounds(neCoord(0,0),t.getN())) {
--[ 2022.11.01.15.40.07.843.0 ]--
r 61             if(this.currentTile.isInBounds(newCoord(0,0),t.getN())) {
--[ 2022.11.01.15.40.07.948.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),t.getN())) {
--[ 2022.11.01.15.40.22.615.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),nt.getN())) {
--[ 2022.11.01.15.40.22.718.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),net.getN())) {
--[ 2022.11.01.15.40.22.736.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),newt.getN())) {
--[ 2022.11.01.15.40.22.881.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new t.getN())) {
--[ 2022.11.01.15.40.23.216.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new Ct.getN())) {
--[ 2022.11.01.15.40.23.403.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new Cot.getN())) {
--[ 2022.11.01.15.40.23.535.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new Coot.getN())) {
--[ 2022.11.01.15.40.23.628.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new Coort.getN())) {
--[ 2022.11.01.15.40.23.732.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new Coordt.getN())) {
--[ 2022.11.01.15.40.24.148.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN())) {
--[ 2022.11.01.15.40.26.324.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN()))) {
--[ 2022.11.01.15.40.34.079.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(),))) {
--[ 2022.11.01.15.40.35.043.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(), ))) {
--[ 2022.11.01.15.40.35.162.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(), t.getN()))) {
--[ 2022.11.01.15.41.22.751.0 ]--
r 61             if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(), t.getN()) )) {
--[ 2022.11.01.15.41.48.175.0 ]--
r 10     MinPQ<PFNode> pq = new MinPQ<>();
--[ 2022.11.01.15.43.18.244.0 ]--
r 14    
--[ 2022.11.01.15.43.18.394.0 ]--
- 14
--[ 2022.11.01.15.44.50.562.0 ]--
r 120     
--[ 2022.11.01.15.44.50.831.0 ]--
r 120         
--[ 2022.11.01.15.44.51.090.0 ]--
r 120             
--[ 2022.11.01.15.44.51.992.0 ]--
r 120             b
--[ 2022.11.01.15.44.52.217.0 ]--
r 120             br
--[ 2022.11.01.15.44.52.261.0 ]--
r 120             bre
--[ 2022.11.01.15.44.52.350.0 ]--
r 120             brea
--[ 2022.11.01.15.44.52.501.0 ]--
r 120             break
--[ 2022.11.01.15.44.52.687.0 ]--
r 120             break;
--[ 2022.11.01.15.45.00.369.0 ]--
r 120             break
--[ 2022.11.01.15.45.00.521.0 ]--
r 120             brea
--[ 2022.11.01.15.45.00.654.0 ]--
r 120             bre
--[ 2022.11.01.15.45.00.799.0 ]--
r 120             br
--[ 2022.11.01.15.45.00.970.0 ]--
r 120             b
--[ 2022.11.01.15.45.01.139.0 ]--
r 120             
--[ 2022.11.01.15.45.01.819.0 ]--
r 120             /
--[ 2022.11.01.15.45.01.945.0 ]--
r 120             //
--[ 2022.11.01.15.45.03.778.0 ]--
r 120             // 
--[ 2022.11.01.15.45.03.934.0 ]--
r 120             // l
--[ 2022.11.01.15.45.04.106.0 ]--
r 120             // lo
--[ 2022.11.01.15.45.04.219.0 ]--
r 120             // log
--[ 2022.11.01.15.45.04.334.0 ]--
r 120             // logi
--[ 2022.11.01.15.45.04.411.0 ]--
r 120             // logic
--[ 2022.11.01.15.45.04.533.0 ]--
r 120             // logic 
--[ 2022.11.01.15.45.04.660.0 ]--
r 120             // logic f
--[ 2022.11.01.15.45.04.756.0 ]--
r 120             // logic fo
--[ 2022.11.01.15.45.04.864.0 ]--
r 120             // logic for
--[ 2022.11.01.15.45.04.981.0 ]--
r 120             // logic for 
--[ 2022.11.01.15.45.08.236.0 ]--
r 120             // logic for c
--[ 2022.11.01.15.45.08.344.0 ]--
r 120             // logic for ch
--[ 2022.11.01.15.45.08.407.0 ]--
r 120             // logic for che
--[ 2022.11.01.15.45.08.593.0 ]--
r 120             // logic for chec
--[ 2022.11.01.15.45.08.642.0 ]--
r 120             // logic for check
--[ 2022.11.01.15.45.08.835.0 ]--
r 120             // logic for checki
--[ 2022.11.01.15.45.08.934.0 ]--
r 120             // logic for checkin
--[ 2022.11.01.15.45.09.005.0 ]--
r 120             // logic for checking
--[ 2022.11.01.15.45.09.114.0 ]--
r 120             // logic for checking 
--[ 2022.11.01.15.45.09.250.0 ]--
r 120             // logic for checking s
--[ 2022.11.01.15.45.09.385.0 ]--
r 120             // logic for checking su
--[ 2022.11.01.15.45.09.501.0 ]--
r 120             // logic for checking sur
--[ 2022.11.01.15.45.09.632.0 ]--
r 120             // logic for checking surr
--[ 2022.11.01.15.45.09.719.0 ]--
r 120             // logic for checking surro
--[ 2022.11.01.15.45.09.810.0 ]--
r 120             // logic for checking surrou
--[ 2022.11.01.15.45.09.997.0 ]--
r 120             // logic for checking surroun
--[ 2022.11.01.15.45.10.119.0 ]--
r 120             // logic for checking surround
--[ 2022.11.01.15.45.10.239.0 ]--
r 120             // logic for checking surround 
--[ 2022.11.01.15.45.10.800.0 ]--
r 120             // logic for checking surround
--[ 2022.11.01.15.45.10.961.0 ]--
r 120             // logic for checking surroundi
--[ 2022.11.01.15.45.11.042.0 ]--
r 120             // logic for checking surroundin
--[ 2022.11.01.15.45.11.147.0 ]--
r 120             // logic for checking surrounding
--[ 2022.11.01.15.45.11.261.0 ]--
r 120             // logic for checking surrounding 
--[ 2022.11.01.15.45.12.518.0 ]--
r 120             // logic for checking surrounding t
--[ 2022.11.01.15.45.12.559.0 ]--
r 120             // logic for checking surrounding ti
--[ 2022.11.01.15.45.12.650.0 ]--
r 120             // logic for checking surrounding til
--[ 2022.11.01.15.45.12.709.0 ]--
r 120             // logic for checking surrounding tile
--[ 2022.11.01.15.45.12.847.0 ]--
r 120             // logic for checking surrounding tiles
--[ 2022.11.01.15.45.12.964.0 ]--
r 120             // logic for checking surrounding tiles 
--[ 2022.11.01.15.45.13.074.0 ]--
r 120             // logic for checking surrounding tiles a
--[ 2022.11.01.15.45.13.143.0 ]--
r 120             // logic for checking surrounding tiles an
--[ 2022.11.01.15.45.13.218.0 ]--
r 120             // logic for checking surrounding tiles and
--[ 2022.11.01.15.45.13.335.0 ]--
r 120             // logic for checking surrounding tiles and 
--[ 2022.11.01.15.45.14.005.0 ]--
r 120             // logic for checking surrounding tiles and t
--[ 2022.11.01.15.45.14.094.0 ]--
r 120             // logic for checking surrounding tiles and th
--[ 2022.11.01.15.45.14.162.0 ]--
r 120             // logic for checking surrounding tiles and the
--[ 2022.11.01.15.45.14.277.0 ]--
r 120             // logic for checking surrounding tiles and then
--[ 2022.11.01.15.45.14.440.0 ]--
r 120             // logic for checking surrounding tiles and then 
--[ 2022.11.01.15.45.14.707.0 ]--
r 120             // logic for checking surrounding tiles and then d
--[ 2022.11.01.15.45.14.870.0 ]--
r 120             // logic for checking surrounding tiles and then de
--[ 2022.11.01.15.45.15.095.0 ]--
r 120             // logic for checking surrounding tiles and then dec
--[ 2022.11.01.15.45.15.237.0 ]--
r 120             // logic for checking surrounding tiles and then deci
--[ 2022.11.01.15.45.15.383.0 ]--
r 120             // logic for checking surrounding tiles and then decid
--[ 2022.11.01.15.45.15.562.0 ]--
r 120             // logic for checking surrounding tiles and then decidi
--[ 2022.11.01.15.45.16.064.0 ]--
r 120             // logic for checking surrounding tiles and then decid
--[ 2022.11.01.15.45.16.237.0 ]--
r 120             // logic for checking surrounding tiles and then deci
--[ 2022.11.01.15.45.16.416.0 ]--
r 120             // logic for checking surrounding tiles and then dec
--[ 2022.11.01.15.45.16.580.0 ]--
r 120             // logic for checking surrounding tiles and then de
--[ 2022.11.01.15.45.16.881.0 ]--
r 120             // logic for checking surrounding tiles and then d
--[ 2022.11.01.15.45.17.081.0 ]--
r 120             // logic for checking surrounding tiles and then 
--[ 2022.11.01.15.45.17.421.0 ]--
r 120             // logic for checking surrounding tiles and then s
--[ 2022.11.01.15.45.17.813.0 ]--
r 120             // logic for checking surrounding tiles and then 
--[ 2022.11.01.15.45.18.208.0 ]--
r 120             // logic for checking surrounding tiles and then u
--[ 2022.11.01.15.45.18.319.0 ]--
r 120             // logic for checking surrounding tiles and then us
--[ 2022.11.01.15.45.18.383.0 ]--
r 120             // logic for checking surrounding tiles and then usi
--[ 2022.11.01.15.45.18.478.0 ]--
r 120             // logic for checking surrounding tiles and then usin
--[ 2022.11.01.15.45.18.565.0 ]--
r 120             // logic for checking surrounding tiles and then using
--[ 2022.11.01.15.45.18.683.0 ]--
r 120             // logic for checking surrounding tiles and then using 
--[ 2022.11.01.15.45.19.563.0 ]--
r 120             // logic for checking surrounding tiles and then using g
--[ 2022.11.01.15.45.19.644.0 ]--
r 120             // logic for checking surrounding tiles and then using ge
--[ 2022.11.01.15.45.19.780.0 ]--
r 120             // logic for checking surrounding tiles and then using get
--[ 2022.11.01.15.45.20.124.0 ]--
r 120             // logic for checking surrounding tiles and then using getC
--[ 2022.11.01.15.45.20.260.0 ]--
r 120             // logic for checking surrounding tiles and then using getCo
--[ 2022.11.01.15.45.20.394.0 ]--
r 120             // logic for checking surrounding tiles and then using getCos
--[ 2022.11.01.15.45.21.075.0 ]--
r 120             // logic for checking surrounding tiles and then using getCos(
--[ 2022.11.01.15.45.21.465.0 ]--
r 120             // logic for checking surrounding tiles and then using getCos
--[ 2022.11.01.15.45.21.580.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost
--[ 2022.11.01.15.45.21.946.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost(
--[ 2022.11.01.15.45.22.071.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost()
--[ 2022.11.01.15.45.22.413.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() 
--[ 2022.11.01.15.45.22.546.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() t
--[ 2022.11.01.15.45.22.626.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to
--[ 2022.11.01.15.45.22.698.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to 
--[ 2022.11.01.15.45.22.877.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to d
--[ 2022.11.01.15.45.23.052.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to de
--[ 2022.11.01.15.45.23.143.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to det
--[ 2022.11.01.15.45.23.243.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to dete
--[ 2022.11.01.15.45.23.343.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to deter
--[ 2022.11.01.15.45.23.430.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determ
--[ 2022.11.01.15.45.23.561.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determi
--[ 2022.11.01.15.45.23.628.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determin
--[ 2022.11.01.15.45.23.736.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine
--[ 2022.11.01.15.45.23.833.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine 
--[ 2022.11.01.15.45.24.010.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine w
--[ 2022.11.01.15.45.24.148.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine wh
--[ 2022.11.01.15.45.24.221.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine whi
--[ 2022.11.01.15.45.24.377.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine whic
--[ 2022.11.01.15.45.24.461.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which
--[ 2022.11.01.15.45.24.658.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which 
--[ 2022.11.01.15.45.25.019.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which o
--[ 2022.11.01.15.45.25.112.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which on
--[ 2022.11.01.15.45.25.170.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which one
--[ 2022.11.01.15.45.25.286.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which one 
--[ 2022.11.01.15.45.25.433.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which one o
--[ 2022.11.01.15.45.25.438.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which one ot
--[ 2022.11.01.15.45.25.574.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which one ot 
--[ 2022.11.01.15.45.26.027.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which one ot
--[ 2022.11.01.15.45.26.545.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which one o
--[ 2022.11.01.15.45.26.613.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which one 
--[ 2022.11.01.15.45.26.697.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which one
--[ 2022.11.01.15.45.26.782.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which on
--[ 2022.11.01.15.45.26.865.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which o
--[ 2022.11.01.15.45.26.950.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which 
--[ 2022.11.01.15.45.27.031.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which
--[ 2022.11.01.15.45.27.117.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine whic
--[ 2022.11.01.15.45.27.201.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine whi
--[ 2022.11.01.15.45.27.285.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine wh
--[ 2022.11.01.15.45.27.368.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine w
--[ 2022.11.01.15.45.27.452.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine 
--[ 2022.11.01.15.45.29.078.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine w
--[ 2022.11.01.15.45.29.244.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine wh
--[ 2022.11.01.15.45.29.357.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine whi
--[ 2022.11.01.15.45.29.481.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine whic
--[ 2022.11.01.15.45.29.561.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which
--[ 2022.11.01.15.45.29.711.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which 
--[ 2022.11.01.15.45.29.971.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which d
--[ 2022.11.01.15.45.30.035.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which di
--[ 2022.11.01.15.45.30.144.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which dir
--[ 2022.11.01.15.45.30.255.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which dire
--[ 2022.11.01.15.45.30.472.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direc
--[ 2022.11.01.15.45.30.565.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direct
--[ 2022.11.01.15.45.30.647.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which directi
--[ 2022.11.01.15.45.30.763.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which directio
--[ 2022.11.01.15.45.30.839.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direction
--[ 2022.11.01.15.45.30.973.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direction 
--[ 2022.11.01.15.45.31.072.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direction t
--[ 2022.11.01.15.45.31.159.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direction to
--[ 2022.11.01.15.45.31.230.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direction to 
--[ 2022.11.01.15.45.31.462.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direction to m
--[ 2022.11.01.15.45.31.522.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direction to ma
--[ 2022.11.01.15.45.31.577.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direction to mak
--[ 2022.11.01.15.45.31.718.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direction to make
--[ 2022.11.01.15.45.31.817.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direction to make 
--[ 2022.11.01.15.45.31.988.0 ]--
r 120             // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
--[ 2022.11.01.15.45.33.138.0 ]--
+ 121             
--[ 2022.11.01.15.45.34.059.0 ]--
r 121             /
--[ 2022.11.01.15.45.34.230.0 ]--
r 121             //
--[ 2022.11.01.15.45.34.364.0 ]--
r 121             // 
--[ 2022.11.01.15.45.34.435.0 ]--
r 121             // n
--[ 2022.11.01.15.45.34.588.0 ]--
r 121             // ne
--[ 2022.11.01.15.45.34.662.0 ]--
r 121             // new
--[ 2022.11.01.15.45.34.736.0 ]--
r 121             // new 
--[ 2022.11.01.15.45.36.346.0 ]--
r 121             // new P
--[ 2022.11.01.15.45.36.463.0 ]--
r 121             // new PF
--[ 2022.11.01.15.45.37.014.0 ]--
r 121             // new PFN
--[ 2022.11.01.15.45.37.176.0 ]--
r 121             // new PFNo
--[ 2022.11.01.15.45.37.284.0 ]--
r 121             // new PFNod
--[ 2022.11.01.15.45.37.405.0 ]--
r 121             // new PFNode
--[ 2022.11.01.15.45.37.679.0 ]--
r 121             // new PFNode 
--[ 2022.11.01.15.45.38.349.0 ]--
r 121             // new PFNode f
--[ 2022.11.01.15.45.38.427.0 ]--
r 121             // new PFNode fo
--[ 2022.11.01.15.45.38.547.0 ]--
r 121             // new PFNode for
--[ 2022.11.01.15.45.38.755.0 ]--
r 121             // new PFNode for.
--[ 2022.11.02.09.51.48.992.0 ]--
+ 122             
--[ 2022.11.02.09.53.15.179.0 ]--
r 122             /
--[ 2022.11.02.09.53.15.275.0 ]--
r 122             //
--[ 2022.11.02.09.53.17.348.0 ]--
r 122             // 
--[ 2022.11.02.09.53.17.525.0 ]--
r 122             // l
--[ 2022.11.02.09.53.17.706.0 ]--
r 122             // lo
--[ 2022.11.02.09.53.17.860.0 ]--
r 122             // loo
--[ 2022.11.02.09.53.18.032.0 ]--
r 122             // loop
--[ 2022.11.02.09.53.18.846.0 ]--
r 122             // loo
--[ 2022.11.02.09.53.18.977.0 ]--
r 122             // lo
--[ 2022.11.02.09.53.19.151.0 ]--
r 122             // l
--[ 2022.11.02.09.53.19.312.0 ]--
r 122             // 
--[ 2022.11.02.10.01.49.445.0 ]--
r 122             //
--[ 2022.11.02.10.04.23.374.0 ]--
+ 52             
--[ 2022.11.02.10.04.23.909.0 ]--
r 52             /
--[ 2022.11.02.10.04.24.028.0 ]--
r 52             //
--[ 2022.11.02.10.05.13.212.0 ]--
r 52             // 
--[ 2022.11.02.10.05.18.554.0 ]--
r 52             // r
--[ 2022.11.02.10.05.18.660.0 ]--
r 52             // re
--[ 2022.11.02.10.05.18.848.0 ]--
r 52             // rec
--[ 2022.11.02.10.05.18.954.0 ]--
r 52             // recu
--[ 2022.11.02.10.05.19.004.0 ]--
r 52             // recur
--[ 2022.11.02.10.05.19.146.0 ]--
r 52             // recurs
--[ 2022.11.02.10.05.19.243.0 ]--
r 52             // recursi
--[ 2022.11.02.10.05.19.342.0 ]--
r 52             // recursiv
--[ 2022.11.02.10.05.19.437.0 ]--
r 52             // recursive
--[ 2022.11.02.10.24.31.131.0 ]--
r 53             this.cost = , this.prevNode.currentTile)
--[ 2022.11.02.10.24.33.019.0 ]--
r 53             this.cost = p, this.prevNode.currentTile)
--[ 2022.11.02.10.24.33.152.0 ]--
r 53             this.cost = pr, this.prevNode.currentTile)
--[ 2022.11.02.10.24.33.182.0 ]--
r 53             this.cost = pre, this.prevNode.currentTile)
--[ 2022.11.02.10.24.37.685.0 ]--
r 53             this.cost = prevNode.getCost, this.prevNode.currentTile)
--[ 2022.11.02.10.24.37.695.0 ]--
r 53             this.cost = prevNode;, this.prevNode.currentTile)
--[ 2022.11.02.10.24.37.703.0 ]--
r 53             this.cost = prevNode.getCost, this.prevNode.currentTile)
--[ 2022.11.02.10.24.37.708.0 ]--
r 53             this.cost = prevNode.getCost(), this.prevNode.currentTile)
--[ 2022.11.02.10.24.39.088.0 ]--
r 53             this.cost = prevNode.getCost(0), this.prevNode.currentTile)
--[ 2022.11.02.10.24.49.844.0 ]--
r 53             this.cost = prevNode.getCost(0)
--[ 2022.11.02.10.24.55.869.0 ]--
r 52             // recursive 
--[ 2022.11.02.10.24.55.995.0 ]--
r 52             // recursive a
--[ 2022.11.02.10.24.56.111.0 ]--
r 52             // recursive al
--[ 2022.11.02.10.24.56.190.0 ]--
r 52             // recursive all
--[ 2022.11.02.10.24.56.324.0 ]--
r 52             // recursive all 
--[ 2022.11.02.10.24.56.579.0 ]--
r 52             // recursive all t
--[ 2022.11.02.10.24.56.666.0 ]--
r 52             // recursive all th
--[ 2022.11.02.10.24.56.731.0 ]--
r 52             // recursive all the
--[ 2022.11.02.10.24.56.840.0 ]--
r 52             // recursive all the 
--[ 2022.11.02.10.24.56.969.0 ]--
r 52             // recursive all the w
--[ 2022.11.02.10.24.57.061.0 ]--
r 52             // recursive all the wa
--[ 2022.11.02.10.24.57.178.0 ]--
r 52             // recursive all the way
--[ 2022.11.02.10.24.57.291.0 ]--
r 52             // recursive all the way 
--[ 2022.11.02.10.24.57.470.0 ]--
r 52             // recursive all the way b
--[ 2022.11.02.10.24.57.519.0 ]--
r 52             // recursive all the way ba
--[ 2022.11.02.10.24.57.665.0 ]--
r 52             // recursive all the way bac
--[ 2022.11.02.10.24.57.781.0 ]--
r 52             // recursive all the way back
--[ 2022.11.02.10.24.57.863.0 ]--
r 52             // recursive all the way back 
--[ 2022.11.02.10.24.57.942.0 ]--
r 52             // recursive all the way back t
--[ 2022.11.02.10.24.58.087.0 ]--
r 52             // recursive all the way back to
--[ 2022.11.02.10.24.58.099.0 ]--
r 52             // recursive all the way back to 
--[ 2022.11.02.10.24.58.296.0 ]--
r 52             // recursive all the way back to s
--[ 2022.11.02.10.24.58.403.0 ]--
r 52             // recursive all the way back to st
--[ 2022.11.02.10.24.58.524.0 ]--
r 52             // recursive all the way back to sta
--[ 2022.11.02.10.24.58.638.0 ]--
r 52             // recursive all the way back to star
--[ 2022.11.02.10.24.58.845.0 ]--
r 52             // recursive all the way back to start
--[ 2022.11.02.10.26.31.436.0 ]--
+ 53             
--[ 2022.11.02.10.26.33.006.0 ]--
- 53
--[ 2022.11.02.10.26.52.324.0 ]--
+ 13     
--[ 2022.11.02.10.26.55.665.0 ]--
r 13     b
--[ 2022.11.02.10.26.55.771.0 ]--
r 13     bo
--[ 2022.11.02.10.26.55.902.0 ]--
r 13     boo
--[ 2022.11.02.10.26.56.075.0 ]--
r 13     bool
--[ 2022.11.02.10.26.57.731.0 ]--
r 13     boolean
--[ 2022.11.02.10.26.57.931.0 ]--
r 13     boolean[]
--[ 2022.11.02.10.27.00.112.0 ]--
r 13     boolean[] 
--[ 2022.11.02.10.27.21.224.0 ]--
r 13     boolean[] v
--[ 2022.11.02.10.27.21.254.0 ]--
r 13     boolean[] va
--[ 2022.11.02.10.27.21.382.0 ]--
r 13     boolean[] val
--[ 2022.11.02.10.27.21.462.0 ]--
r 13     boolean[] vali
--[ 2022.11.02.10.27.21.554.0 ]--
r 13     boolean[] valid
--[ 2022.11.02.10.27.22.331.0 ]--
r 13     boolean[] vali
--[ 2022.11.02.10.27.22.495.0 ]--
r 13     boolean[] val
--[ 2022.11.02.10.27.22.656.0 ]--
r 13     boolean[] va
--[ 2022.11.02.10.27.22.824.0 ]--
r 13     boolean[] v
--[ 2022.11.02.10.27.22.999.0 ]--
r 13     boolean[] 
--[ 2022.11.02.10.27.33.592.0 ]--
r 13     boolean[] o
--[ 2022.11.02.10.27.33.866.0 ]--
r 13     boolean[] oc
--[ 2022.11.02.10.27.34.085.0 ]--
r 13     boolean[] occ
--[ 2022.11.02.10.27.34.374.0 ]--
r 13     boolean[] occu
--[ 2022.11.02.10.27.34.742.0 ]--
r 13     boolean[] occum
--[ 2022.11.02.10.27.34.847.0 ]--
r 13     boolean[] occump
--[ 2022.11.02.10.27.34.964.0 ]--
r 13     boolean[] occumpi
--[ 2022.11.02.10.27.35.087.0 ]--
r 13     boolean[] occumpie
--[ 2022.11.02.10.27.35.275.0 ]--
r 13     boolean[] occumpied
--[ 2022.11.02.10.27.35.517.0 ]--
r 13     boolean[] occumpie
--[ 2022.11.02.10.27.36.013.0 ]--
r 13     boolean[] occumpi
--[ 2022.11.02.10.27.36.097.0 ]--
r 13     boolean[] occump
--[ 2022.11.02.10.27.36.181.0 ]--
r 13     boolean[] occum
--[ 2022.11.02.10.27.36.264.0 ]--
r 13     boolean[] occu
--[ 2022.11.02.10.27.36.347.0 ]--
r 13     boolean[] occ
--[ 2022.11.02.10.27.36.431.0 ]--
r 13     boolean[] oc
--[ 2022.11.02.10.27.36.791.0 ]--
r 13     boolean[] o
--[ 2022.11.02.10.27.36.980.0 ]--
r 13     boolean[] 
--[ 2022.11.02.10.28.44.057.0 ]--
r 13     boolean[] a
--[ 2022.11.02.10.28.44.195.0 ]--
r 13     boolean[] ar
--[ 2022.11.02.10.28.44.342.0 ]--
r 13     boolean[] arr
--[ 2022.11.02.10.28.44.412.0 ]--
r 13     boolean[] arra
--[ 2022.11.02.10.28.44.544.0 ]--
r 13     boolean[] array
--[ 2022.11.02.10.28.46.115.0 ]--
r 13     boolean[] array 
--[ 2022.11.02.10.28.46.186.0 ]--
r 13     boolean[] array =
--[ 2022.11.02.10.28.47.188.0 ]--
r 13     boolean[] array 
--[ 2022.11.02.10.28.47.685.0 ]--
r 13     boolean[] array
--[ 2022.11.02.10.28.48.125.0 ]--
r 13     boolean[] array;
--[ 2022.11.02.10.28.52.691.0 ]--
r 13     boolean[][] array;
--[ 2022.11.02.10.28.54.320.0 ]--
r 13     boolea[][] array;
--[ 2022.11.02.10.28.54.443.0 ]--
r 13     boole[][] array;
--[ 2022.11.02.10.28.54.595.0 ]--
r 13     bool[][] array;
--[ 2022.11.02.10.28.54.765.0 ]--
r 13     boo[][] array;
--[ 2022.11.02.10.28.54.935.0 ]--
r 13     bo[][] array;
--[ 2022.11.02.10.28.55.128.0 ]--
r 13     b[][] array;
--[ 2022.11.02.10.28.55.329.0 ]--
r 13     [][] array;
--[ 2022.11.02.10.28.56.449.0 ]--
r 13     i[][] array;
--[ 2022.11.02.10.28.56.508.0 ]--
r 13     in[][] array;
--[ 2022.11.02.10.28.56.581.0 ]--
r 13     int[][] array;
--[ 2022.11.02.10.29.07.295.0 ]--
r 13     int[][] array ;
--[ 2022.11.02.10.29.07.377.0 ]--
r 13     int[][] array =;
--[ 2022.11.02.10.29.07.511.0 ]--
r 13     int[][] array = ;
--[ 2022.11.02.10.29.07.844.0 ]--
r 13     int[][] array = f;
--[ 2022.11.02.10.29.07.949.0 ]--
r 13     int[][] array = fa;
--[ 2022.11.02.10.29.08.008.0 ]--
r 13     int[][] array = fal;
--[ 2022.11.02.10.29.08.121.0 ]--
r 13     int[][] array = fals;
--[ 2022.11.02.10.29.08.168.0 ]--
r 13     int[][] array = false;
--[ 2022.11.02.10.29.09.363.0 ]--
r 13     int[][] array = fals;
--[ 2022.11.02.10.29.09.482.0 ]--
r 13     int[][] array = fal;
--[ 2022.11.02.10.29.09.643.0 ]--
r 13     int[][] array = fa;
--[ 2022.11.02.10.29.09.795.0 ]--
r 13     int[][] array = f;
--[ 2022.11.02.10.29.09.937.0 ]--
r 13     int[][] array = ;
--[ 2022.11.02.10.29.10.089.0 ]--
r 13     int[][] array =;
--[ 2022.11.02.10.29.10.255.0 ]--
r 13     int[][] array ;
--[ 2022.11.02.10.29.10.402.0 ]--
r 13     int[][] array;
--[ 2022.11.02.10.32.24.184.0 ]--
r 13     b[][] array;
--[ 2022.11.02.10.32.24.310.0 ]--
r 13     bo[][] array;
--[ 2022.11.02.10.32.24.403.0 ]--
r 13     boo[][] array;
--[ 2022.11.02.10.32.24.565.0 ]--
r 13     booo[][] array;
--[ 2022.11.02.10.32.25.213.0 ]--
r 13     boo[][] array;
--[ 2022.11.02.10.32.25.421.0 ]--
r 13     bool[][] array;
--[ 2022.11.02.10.32.26.134.0 ]--
r 13     boolean[][] array;
--[ 2022.11.02.10.33.11.948.0 ]--
- 34
r 34             
--[ 2022.11.02.10.33.14.107.0 ]--
- 34
--[ 2022.11.02.10.33.23.212.0 ]--
+ 89         
--[ 2022.11.02.10.33.23.984.0 ]--
r 89         a
--[ 2022.11.02.10.33.24.139.0 ]--
r 89         ar
--[ 2022.11.02.10.33.24.306.0 ]--
r 89         arr
--[ 2022.11.02.10.33.24.357.0 ]--
r 89         arra
--[ 2022.11.02.10.33.24.462.0 ]--
r 89         array
--[ 2022.11.02.10.33.24.627.0 ]--
r 89         array 
--[ 2022.11.02.10.33.24.826.0 ]--
r 89         array =
--[ 2022.11.02.10.33.24.933.0 ]--
r 89         array = 
--[ 2022.11.02.10.33.27.969.0 ]--
r 89         array = n
--[ 2022.11.02.10.33.28.039.0 ]--
r 89         array = ne
--[ 2022.11.02.10.33.28.113.0 ]--
r 89         array = new
--[ 2022.11.02.10.33.28.221.0 ]--
r 89         array = new 
--[ 2022.11.02.10.33.28.367.0 ]--
r 89         array = new a
--[ 2022.11.02.10.33.28.456.0 ]--
r 89         array = new ar
--[ 2022.11.02.10.33.28.579.0 ]--
r 89         array = new arr
--[ 2022.11.02.10.33.28.657.0 ]--
r 89         array = new arra
--[ 2022.11.02.10.33.28.761.0 ]--
r 89         array = new array
--[ 2022.11.02.10.33.37.287.0 ]--
r 89         array = new array[]
--[ 2022.11.02.10.33.38.780.0 ]--
r 89         array = new array[][]
--[ 2022.11.02.10.33.43.545.0 ]--
+ 89         
--[ 2022.11.02.10.33.44.388.0 ]--
r 89         n
--[ 2022.11.02.10.33.45.421.0 ]--
r 89         
--[ 2022.11.02.10.33.46.271.0 ]--
r 89         i
--[ 2022.11.02.10.33.46.375.0 ]--
r 89         in
--[ 2022.11.02.10.33.46.429.0 ]--
r 89         int
--[ 2022.11.02.10.33.46.541.0 ]--
r 89         int 
--[ 2022.11.02.10.33.46.806.0 ]--
r 89         int n
--[ 2022.11.02.10.33.46.928.0 ]--
r 89         int n 
--[ 2022.11.02.10.33.47.082.0 ]--
r 89         int n =
--[ 2022.11.02.10.33.47.188.0 ]--
r 89         int n = 
--[ 2022.11.02.10.33.48.554.0 ]--
r 89         int n = t
--[ 2022.11.02.10.33.48.648.0 ]--
r 89         int n = t.
--[ 2022.11.02.10.33.49.648.0 ]--
r 89         int n = t.getN
--[ 2022.11.02.10.33.49.655.0 ]--
r 89         int n = t.getN()
--[ 2022.11.02.10.33.50.548.0 ]--
r 89         int n = t.getN();
--[ 2022.11.02.10.33.52.984.0 ]--
r 90         array = new array[n][]
--[ 2022.11.02.10.33.54.277.0 ]--
r 90         array = new array[n][n]
--[ 2022.11.02.10.33.56.014.0 ]--
r 90         array = new array[n][n];
--[ 2022.11.02.10.34.03.236.0 ]--
r 90         array = new b[n][n];
--[ 2022.11.02.10.34.03.310.0 ]--
r 90         array = new bo[n][n];
--[ 2022.11.02.10.34.03.452.0 ]--
r 90         array = new boo[n][n];
--[ 2022.11.02.10.34.03.620.0 ]--
r 90         array = new bool[n][n];
--[ 2022.11.02.10.34.03.911.0 ]--
r 90         array = new boole[n][n];
--[ 2022.11.02.10.34.03.985.0 ]--
r 90         array = new boolea[n][n];
--[ 2022.11.02.10.34.04.094.0 ]--
r 90         array = new boolean[n][n];
--[ 2022.11.02.10.34.09.147.0 ]--
- 90
--[ 2022.11.02.10.34.10.166.0 ]--
+ 90         array = new boolean[n][n];
--[ 2022.11.02.10.34.45.074.0 ]--
+ 91         
--[ 2022.11.02.10.34.46.290.0 ]--
r 91         s
--[ 2022.11.02.10.34.46.386.0 ]--
r 91         so
--[ 2022.11.02.10.34.46.484.0 ]--
r 91         sou
--[ 2022.11.02.10.34.46.534.0 ]--
r 91         sout
--[ 2022.11.02.10.34.46.682.0 ]--
r 91         System.out.println();
--[ 2022.11.02.10.34.51.452.0 ]--
r 91         System.out.println("");
--[ 2022.11.02.10.34.52.063.0 ]--
r 91         System.out.println("i");
--[ 2022.11.02.10.34.52.148.0 ]--
r 91         System.out.println("in");
--[ 2022.11.02.10.34.52.223.0 ]--
r 91         System.out.println("ind");
--[ 2022.11.02.10.34.52.396.0 ]--
r 91         System.out.println("inde");
--[ 2022.11.02.10.34.52.875.0 ]--
r 91         System.out.println("ind");
--[ 2022.11.02.10.34.53.023.0 ]--
r 91         System.out.println("in");
--[ 2022.11.02.10.34.53.197.0 ]--
r 91         System.out.println("i");
--[ 2022.11.02.10.34.53.349.0 ]--
r 91         System.out.println("");
--[ 2022.11.02.10.34.53.462.0 ]--
r 91         System.out.println("v");
--[ 2022.11.02.10.34.53.575.0 ]--
r 91         System.out.println("va");
--[ 2022.11.02.10.34.53.662.0 ]--
r 91         System.out.println("val");
--[ 2022.11.02.10.34.53.733.0 ]--
r 91         System.out.println("valu");
--[ 2022.11.02.10.34.53.817.0 ]--
r 91         System.out.println("value");
--[ 2022.11.02.10.34.54.554.0 ]--
r 91         System.out.println("value:");
--[ 2022.11.02.10.34.54.711.0 ]--
r 91         System.out.println("value: ");
--[ 2022.11.02.10.34.55.263.0 ]--
r 91         System.out.println("value: " );
--[ 2022.11.02.10.34.55.443.0 ]--
r 91         System.out.println("value: " +);
--[ 2022.11.02.10.34.55.538.0 ]--
r 91         System.out.println("value: " + );
--[ 2022.11.02.10.34.57.918.0 ]--
r 91         System.out.println("value: " + a);
--[ 2022.11.02.10.34.58.476.0 ]--
r 91         System.out.println("value: " + ar);
--[ 2022.11.02.10.34.58.612.0 ]--
r 91         System.out.println("value: " + arr);
--[ 2022.11.02.10.34.58.648.0 ]--
r 91         System.out.println("value: " + arra);
--[ 2022.11.02.10.34.58.736.0 ]--
r 91         System.out.println("value: " + array);
--[ 2022.11.02.10.35.00.029.0 ]--
r 91         System.out.println("value: " + array[]);
--[ 2022.11.02.10.35.00.454.0 ]--
r 91         System.out.println("value: " + array[0]);
--[ 2022.11.02.10.35.03.060.0 ]--
r 91         System.out.println("value: " + array[0][]);
--[ 2022.11.02.10.35.03.369.0 ]--
r 91         System.out.println("value: " + array[0][0]);
--[ 2022.11.02.10.35.08.660.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.02.10.35.16.697.0 ]--
r 91        
--[ 2022.11.02.10.35.18.890.0 ]--
+ 90         
--[ 2022.11.02.10.35.19.080.0 ]--
r 90         /
--[ 2022.11.02.10.35.19.235.0 ]--
r 90         //
--[ 2022.11.02.10.35.19.882.0 ]--
r 90         // 
--[ 2022.11.02.10.35.20.020.0 ]--
r 90         // l
--[ 2022.11.02.10.35.20.449.0 ]--
r 90         // 
--[ 2022.11.02.10.35.20.572.0 ]--
r 90         // a
--[ 2022.11.02.10.35.20.702.0 ]--
r 90         // al
--[ 2022.11.02.10.35.20.830.0 ]--
r 90         // all
--[ 2022.11.02.10.35.20.886.0 ]--
r 90         // all 
--[ 2022.11.02.10.35.20.990.0 ]--
r 90         // all v
--[ 2022.11.02.10.35.21.079.0 ]--
r 90         // all va
--[ 2022.11.02.10.35.21.183.0 ]--
r 90         // all val
--[ 2022.11.02.10.35.21.294.0 ]--
r 90         // all valu
--[ 2022.11.02.10.35.21.352.0 ]--
r 90         // all value
--[ 2022.11.02.10.35.21.498.0 ]--
r 90         // all values
--[ 2022.11.02.10.35.21.591.0 ]--
r 90         // all values 
--[ 2022.11.02.10.35.22.277.0 ]--
r 90         // all values
--[ 2022.11.02.10.35.22.768.0 ]--
r 90         // all value
--[ 2022.11.02.10.35.22.852.0 ]--
r 90         // all valu
--[ 2022.11.02.10.35.22.936.0 ]--
r 90         // all val
--[ 2022.11.02.10.35.23.019.0 ]--
r 90         // all va
--[ 2022.11.02.10.35.23.104.0 ]--
r 90         // all v
--[ 2022.11.02.10.35.23.188.0 ]--
r 90         // all 
--[ 2022.11.02.10.35.23.272.0 ]--
r 90         // all
--[ 2022.11.02.10.35.23.356.0 ]--
r 90         // al
--[ 2022.11.02.10.35.23.438.0 ]--
r 90         // a
--[ 2022.11.02.10.35.23.521.0 ]--
r 90         // 
--[ 2022.11.02.10.35.23.817.0 ]--
r 90         // s
--[ 2022.11.02.10.35.23.912.0 ]--
r 90         // se
--[ 2022.11.02.10.35.24.099.0 ]--
r 90         // sed
--[ 2022.11.02.10.35.24.189.0 ]--
r 90         // sedo
--[ 2022.11.02.10.35.24.531.0 ]--
r 90         // sed
--[ 2022.11.02.10.35.24.728.0 ]--
r 90         // se
--[ 2022.11.02.10.35.24.921.0 ]--
r 90         // sec
--[ 2022.11.02.10.35.24.995.0 ]--
r 90         // seco
--[ 2022.11.02.10.35.25.101.0 ]--
r 90         // secon
--[ 2022.11.02.10.35.25.167.0 ]--
r 90         // second
--[ 2022.11.02.10.35.25.311.0 ]--
r 90         // seconda
--[ 2022.11.02.10.35.25.463.0 ]--
r 90         // seconday
--[ 2022.11.02.10.35.25.480.0 ]--
r 90         // secondayr
--[ 2022.11.02.10.35.25.886.0 ]--
r 90         // seconday
--[ 2022.11.02.10.35.26.035.0 ]--
r 90         // seconda
--[ 2022.11.02.10.35.26.083.0 ]--
r 90         // secondar
--[ 2022.11.02.10.35.26.162.0 ]--
r 90         // secondary
--[ 2022.11.02.10.35.26.233.0 ]--
r 90         // secondary 
--[ 2022.11.02.10.35.26.870.0 ]--
r 90         // secondary d
--[ 2022.11.02.10.35.26.958.0 ]--
r 90         // secondary da
--[ 2022.11.02.10.35.27.033.0 ]--
r 90         // secondary dat
--[ 2022.11.02.10.35.27.120.0 ]--
r 90         // secondary data
--[ 2022.11.02.10.35.27.214.0 ]--
r 90         // secondary data 
--[ 2022.11.02.10.35.27.393.0 ]--
r 90         // secondary data s
--[ 2022.11.02.10.35.27.535.0 ]--
r 90         // secondary data st
--[ 2022.11.02.10.35.27.698.0 ]--
r 90         // secondary data str
--[ 2022.11.02.10.35.27.847.0 ]--
r 90         // secondary data stru
--[ 2022.11.02.10.35.28.033.0 ]--
r 90         // secondary data strut
--[ 2022.11.02.10.35.28.182.0 ]--
r 90         // secondary data strutu
--[ 2022.11.02.10.35.28.312.0 ]--
r 90         // secondary data strutur
--[ 2022.11.02.10.35.28.568.0 ]--
r 90         // secondary data strutu
--[ 2022.11.02.10.35.28.722.0 ]--
r 90         // secondary data strut
--[ 2022.11.02.10.35.28.878.0 ]--
r 90         // secondary data stru
--[ 2022.11.02.10.35.28.934.0 ]--
r 90         // secondary data struc
--[ 2022.11.02.10.35.29.051.0 ]--
r 90         // secondary data struct
--[ 2022.11.02.10.35.29.102.0 ]--
r 90         // secondary data structu
--[ 2022.11.02.10.35.29.226.0 ]--
r 90         // secondary data structur
--[ 2022.11.02.10.35.29.294.0 ]--
r 90         // secondary data structure
--[ 2022.11.02.10.35.29.395.0 ]--
r 90         // secondary data structure 
--[ 2022.11.02.10.35.29.514.0 ]--
r 90         // secondary data structure t
--[ 2022.11.02.10.35.29.582.0 ]--
r 90         // secondary data structure to
--[ 2022.11.02.10.35.29.654.0 ]--
r 90         // secondary data structure to 
--[ 2022.11.02.10.35.30.274.0 ]--
r 90         // secondary data structure to k
--[ 2022.11.02.10.35.30.429.0 ]--
r 90         // secondary data structure to ke
--[ 2022.11.02.10.35.30.584.0 ]--
r 90         // secondary data structure to kee
--[ 2022.11.02.10.35.30.696.0 ]--
r 90         // secondary data structure to keep
--[ 2022.11.02.10.35.30.728.0 ]--
r 90         // secondary data structure to keep 
--[ 2022.11.02.10.35.30.857.0 ]--
r 90         // secondary data structure to keep t
--[ 2022.11.02.10.35.31.038.0 ]--
r 90         // secondary data structure to keep tr
--[ 2022.11.02.10.35.31.145.0 ]--
r 90         // secondary data structure to keep tra
--[ 2022.11.02.10.35.31.311.0 ]--
r 90         // secondary data structure to keep trac
--[ 2022.11.02.10.35.31.436.0 ]--
r 90         // secondary data structure to keep track
--[ 2022.11.02.10.35.31.620.0 ]--
r 90         // secondary data structure to keep track 
--[ 2022.11.02.10.35.31.749.0 ]--
r 90         // secondary data structure to keep track o
--[ 2022.11.02.10.35.31.819.0 ]--
r 90         // secondary data structure to keep track of
--[ 2022.11.02.10.35.31.919.0 ]--
r 90         // secondary data structure to keep track of 
--[ 2022.11.02.10.35.32.048.0 ]--
r 90         // secondary data structure to keep track of a
--[ 2022.11.02.10.35.32.150.0 ]--
r 90         // secondary data structure to keep track of a 
--[ 2022.11.02.10.35.32.753.0 ]--
r 90         // secondary data structure to keep track of a
--[ 2022.11.02.10.35.32.920.0 ]--
r 90         // secondary data structure to keep track of 
--[ 2022.11.02.10.35.33.519.0 ]--
r 90         // secondary data structure to keep track of w
--[ 2022.11.02.10.35.33.609.0 ]--
r 90         // secondary data structure to keep track of wh
--[ 2022.11.02.10.35.33.675.0 ]--
r 90         // secondary data structure to keep track of whe
--[ 2022.11.02.10.35.33.763.0 ]--
r 90         // secondary data structure to keep track of wher
--[ 2022.11.02.10.35.33.892.0 ]--
r 90         // secondary data structure to keep track of where
--[ 2022.11.02.10.35.33.961.0 ]--
r 90         // secondary data structure to keep track of where 
--[ 2022.11.02.10.35.38.411.0 ]--
r 90         // secondary data structure to keep track of where N
--[ 2022.11.02.10.35.38.523.0 ]--
r 90         // secondary data structure to keep track of where No
--[ 2022.11.02.10.35.38.598.0 ]--
r 90         // secondary data structure to keep track of where Nod
--[ 2022.11.02.10.35.38.749.0 ]--
r 90         // secondary data structure to keep track of where Node
--[ 2022.11.02.10.35.38.978.0 ]--
r 90         // secondary data structure to keep track of where Nodes
--[ 2022.11.02.10.35.39.309.0 ]--
r 90         // secondary data structure to keep track of where Nodes 
--[ 2022.11.02.10.35.39.561.0 ]--
r 90         // secondary data structure to keep track of where Nodes h
--[ 2022.11.02.10.35.39.609.0 ]--
r 90         // secondary data structure to keep track of where Nodes ha
--[ 2022.11.02.10.35.39.687.0 ]--
r 90         // secondary data structure to keep track of where Nodes hav
--[ 2022.11.02.10.35.39.870.0 ]--
r 90         // secondary data structure to keep track of where Nodes have
--[ 2022.11.02.10.35.39.916.0 ]--
r 90         // secondary data structure to keep track of where Nodes have 
--[ 2022.11.02.10.35.40.007.0 ]--
r 90         // secondary data structure to keep track of where Nodes have a
--[ 2022.11.02.10.35.40.108.0 ]--
r 90         // secondary data structure to keep track of where Nodes have al
--[ 2022.11.02.10.35.40.224.0 ]--
r 90         // secondary data structure to keep track of where Nodes have alr
--[ 2022.11.02.10.35.40.267.0 ]--
r 90         // secondary data structure to keep track of where Nodes have alre
--[ 2022.11.02.10.35.40.346.0 ]--
r 90         // secondary data structure to keep track of where Nodes have alrea
--[ 2022.11.02.10.35.40.485.0 ]--
r 90         // secondary data structure to keep track of where Nodes have alread
--[ 2022.11.02.10.35.40.605.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already
--[ 2022.11.02.10.35.40.699.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already 
--[ 2022.11.02.10.35.41.025.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already b
--[ 2022.11.02.10.35.41.169.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already be
--[ 2022.11.02.10.35.41.564.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already bee
--[ 2022.11.02.10.35.41.676.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already been
--[ 2022.11.02.10.35.41.782.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already been 
--[ 2022.11.02.10.35.42.127.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already been
--[ 2022.11.02.10.35.42.634.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already bee
--[ 2022.11.02.10.35.42.711.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already be
--[ 2022.11.02.10.35.42.796.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already b
--[ 2022.11.02.10.35.42.880.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already 
--[ 2022.11.02.10.35.42.963.0 ]--
r 90         // secondary data structure to keep track of where Nodes have already
--[ 2022.11.02.10.35.43.051.0 ]--
r 90         // secondary data structure to keep track of where Nodes have alread
--[ 2022.11.02.10.35.43.129.0 ]--
r 90         // secondary data structure to keep track of where Nodes have alrea
--[ 2022.11.02.10.35.43.216.0 ]--
r 90         // secondary data structure to keep track of where Nodes have alre
--[ 2022.11.02.10.35.43.296.0 ]--
r 90         // secondary data structure to keep track of where Nodes have alr
--[ 2022.11.02.10.35.43.382.0 ]--
r 90         // secondary data structure to keep track of where Nodes have al
--[ 2022.11.02.10.35.43.466.0 ]--
r 90         // secondary data structure to keep track of where Nodes have a
--[ 2022.11.02.10.35.43.550.0 ]--
r 90         // secondary data structure to keep track of where Nodes have 
--[ 2022.11.02.10.35.43.633.0 ]--
r 90         // secondary data structure to keep track of where Nodes have
--[ 2022.11.02.10.35.43.718.0 ]--
r 90         // secondary data structure to keep track of where Nodes hav
--[ 2022.11.02.10.35.43.802.0 ]--
r 90         // secondary data structure to keep track of where Nodes ha
--[ 2022.11.02.10.35.43.887.0 ]--
r 90         // secondary data structure to keep track of where Nodes h
--[ 2022.11.02.10.35.43.971.0 ]--
r 90         // secondary data structure to keep track of where Nodes 
--[ 2022.11.02.10.35.44.053.0 ]--
r 90         // secondary data structure to keep track of where Nodes
--[ 2022.11.02.10.35.44.138.0 ]--
r 90         // secondary data structure to keep track of where Node
--[ 2022.11.02.10.35.44.221.0 ]--
r 90         // secondary data structure to keep track of where Nod
--[ 2022.11.02.10.35.44.305.0 ]--
r 90         // secondary data structure to keep track of where No
--[ 2022.11.02.10.35.44.556.0 ]--
r 90         // secondary data structure to keep track of where N
--[ 2022.11.02.10.35.45.113.0 ]--
r 90         // secondary data structure to keep track of where 
--[ 2022.11.02.10.35.45.591.0 ]--
r 90         // secondary data structure to keep track of where I
--[ 2022.11.02.10.35.45.671.0 ]--
r 90         // secondary data structure to keep track of where I 
--[ 2022.11.02.10.35.45.817.0 ]--
r 90         // secondary data structure to keep track of where I h
--[ 2022.11.02.10.35.45.889.0 ]--
r 90         // secondary data structure to keep track of where I ha
--[ 2022.11.02.10.35.45.974.0 ]--
r 90         // secondary data structure to keep track of where I hav
--[ 2022.11.02.10.35.46.166.0 ]--
r 90         // secondary data structure to keep track of where I have
--[ 2022.11.02.10.35.46.264.0 ]--
r 90         // secondary data structure to keep track of where I have 
--[ 2022.11.02.10.35.46.399.0 ]--
r 90         // secondary data structure to keep track of where I have a
--[ 2022.11.02.10.35.46.499.0 ]--
r 90         // secondary data structure to keep track of where I have al
--[ 2022.11.02.10.35.46.740.0 ]--
r 90         // secondary data structure to keep track of where I have ale
--[ 2022.11.02.10.35.46.845.0 ]--
r 90         // secondary data structure to keep track of where I have alea
--[ 2022.11.02.10.35.47.164.0 ]--
r 90         // secondary data structure to keep track of where I have ale
--[ 2022.11.02.10.35.47.317.0 ]--
r 90         // secondary data structure to keep track of where I have al
--[ 2022.11.02.10.35.47.386.0 ]--
r 90         // secondary data structure to keep track of where I have alr
--[ 2022.11.02.10.35.47.435.0 ]--
r 90         // secondary data structure to keep track of where I have alre
--[ 2022.11.02.10.35.47.526.0 ]--
r 90         // secondary data structure to keep track of where I have alrea
--[ 2022.11.02.10.35.47.641.0 ]--
r 90         // secondary data structure to keep track of where I have alread
--[ 2022.11.02.10.35.47.762.0 ]--
r 90         // secondary data structure to keep track of where I have already
--[ 2022.11.02.10.35.47.845.0 ]--
r 90         // secondary data structure to keep track of where I have already 
--[ 2022.11.02.10.35.48.045.0 ]--
r 90         // secondary data structure to keep track of where I have already c
--[ 2022.11.02.10.35.48.172.0 ]--
r 90         // secondary data structure to keep track of where I have already ch
--[ 2022.11.02.10.35.48.222.0 ]--
r 90         // secondary data structure to keep track of where I have already che
--[ 2022.11.02.10.35.48.384.0 ]--
r 90         // secondary data structure to keep track of where I have already chec
--[ 2022.11.02.10.35.48.503.0 ]--
r 90         // secondary data structure to keep track of where I have already check
--[ 2022.11.02.10.35.48.586.0 ]--
r 90         // secondary data structure to keep track of where I have already checke
--[ 2022.11.02.10.35.48.698.0 ]--
r 90         // secondary data structure to keep track of where I have already checked
--[ 2022.11.02.10.35.48.948.0 ]--
r 90         // secondary data structure to keep track of where I have already checked.
--[ 2022.11.02.10.35.54.331.0 ]--
r 92 
--[ 2022.11.02.10.38.22.738.0 ]--
- 92
--[ 2022.11.02.10.38.50.257.0 ]--
r 125             /
--[ 2022.11.02.10.38.50.410.0 ]--
r 125             
--[ 2022.11.02.10.38.58.377.0 ]--
r 122         while(!()) {
--[ 2022.11.02.10.38.59.378.0 ]--
r 122         while(!() {
--[ 2022.11.02.10.38.59.551.0 ]--
r 122         while(!) {
--[ 2022.11.02.10.38.59.760.0 ]--
r 122         while() {
--[ 2022.11.02.10.39.01.498.0 ]--
r 122         while(p) {
--[ 2022.11.02.10.39.01.883.0 ]--
r 122         while(pq) {
--[ 2022.11.02.10.39.02.316.0 ]--
r 122         while(pq.) {
--[ 2022.11.02.10.39.03.763.0 ]--
r 122         while(pq.isEmpty) {
--[ 2022.11.02.10.39.03.769.0 ]--
r 122         while(pq.isEmpty()) {
--[ 2022.11.02.10.39.06.369.0 ]--
r 122         while(!pq.isEmpty()) {
--[ 2022.11.02.10.39.09.785.0 ]--
+ 122         
--[ 2022.11.02.10.39.10.312.0 ]--
r 122         w
--[ 2022.11.02.10.39.10.406.0 ]--
r 122         wh
--[ 2022.11.02.10.39.10.622.0 ]--
r 122         whi
--[ 2022.11.02.10.39.10.707.0 ]--
r 122         whil
--[ 2022.11.02.10.39.10.842.0 ]--
r 122         while
--[ 2022.11.02.10.39.10.926.0 ]--
r 122         while 
--[ 2022.11.02.10.39.12.073.0 ]--
r 122         while
--[ 2022.11.02.10.39.12.224.0 ]--
r 122         whil
--[ 2022.11.02.10.39.12.388.0 ]--
r 122         whi
--[ 2022.11.02.10.39.12.551.0 ]--
r 122         wh
--[ 2022.11.02.10.39.12.718.0 ]--
r 122         w
--[ 2022.11.02.10.39.12.873.0 ]--
r 122         
--[ 2022.11.02.10.39.13.247.0 ]--
r 122         /
--[ 2022.11.02.10.39.13.427.0 ]--
r 122         //
--[ 2022.11.02.10.39.13.860.0 ]--
r 122         // 
--[ 2022.11.02.10.39.14.166.0 ]--
r 122         // w
--[ 2022.11.02.10.39.14.272.0 ]--
r 122         // wh
--[ 2022.11.02.10.39.14.333.0 ]--
r 122         // whi
--[ 2022.11.02.10.39.14.425.0 ]--
r 122         // whil
--[ 2022.11.02.10.39.14.484.0 ]--
r 122         // while
--[ 2022.11.02.10.39.14.615.0 ]--
r 122         // while 
--[ 2022.11.02.10.39.14.833.0 ]--
r 122         // while p
--[ 2022.11.02.10.39.15.003.0 ]--
r 122         // while pr
--[ 2022.11.02.10.39.15.713.0 ]--
r 122         // while pri
--[ 2022.11.02.10.39.15.832.0 ]--
r 122         // while prio
--[ 2022.11.02.10.39.16.181.0 ]--
r 122         // while prior
--[ 2022.11.02.10.39.16.232.0 ]--
r 122         // while priori
--[ 2022.11.02.10.39.16.389.0 ]--
r 122         // while priorit
--[ 2022.11.02.10.39.16.456.0 ]--
r 122         // while priority
--[ 2022.11.02.10.39.16.625.0 ]--
r 122         // while priority 
--[ 2022.11.02.10.39.16.800.0 ]--
r 122         // while priority q
--[ 2022.11.02.10.39.16.888.0 ]--
r 122         // while priority qu
--[ 2022.11.02.10.39.18.348.0 ]--
r 122         // while priority q
--[ 2022.11.02.10.39.18.494.0 ]--
r 122         // while priority 
--[ 2022.11.02.10.39.18.636.0 ]--
r 122         // while priority Q
--[ 2022.11.02.10.39.18.959.0 ]--
r 122         // while priority Q 
--[ 2022.11.02.10.39.19.160.0 ]--
r 122         // while priority Q i
--[ 2022.11.02.10.39.19.244.0 ]--
r 122         // while priority Q is
--[ 2022.11.02.10.39.19.336.0 ]--
r 122         // while priority Q is 
--[ 2022.11.02.10.39.19.584.0 ]--
r 122         // while priority Q is n
--[ 2022.11.02.10.39.19.681.0 ]--
r 122         // while priority Q is no
--[ 2022.11.02.10.39.19.756.0 ]--
r 122         // while priority Q is not
--[ 2022.11.02.10.39.19.882.0 ]--
r 122         // while priority Q is not 
--[ 2022.11.02.10.39.20.553.0 ]--
r 122         // while priority Q is not e
--[ 2022.11.02.10.39.20.644.0 ]--
r 122         // while priority Q is not em
--[ 2022.11.02.10.39.20.735.0 ]--
r 122         // while priority Q is not emp
--[ 2022.11.02.10.39.20.849.0 ]--
r 122         // while priority Q is not empt
--[ 2022.11.02.10.39.20.962.0 ]--
r 122         // while priority Q is not empty
--[ 2022.11.02.10.39.21.487.0 ]--
r 122         // while priority Q is not empty,
--[ 2022.11.02.10.39.21.969.0 ]--
r 122         // while priority Q is not empty, 
--[ 2022.11.02.10.39.22.270.0 ]--
r 122         // while priority Q is not empty, i
--[ 2022.11.02.10.39.22.334.0 ]--
r 122         // while priority Q is not empty, it
--[ 2022.11.02.10.39.22.420.0 ]--
r 122         // while priority Q is not empty, ite
--[ 2022.11.02.10.39.22.496.0 ]--
r 122         // while priority Q is not empty, iter
--[ 2022.11.02.10.39.22.609.0 ]--
r 122         // while priority Q is not empty, itera
--[ 2022.11.02.10.39.22.737.0 ]--
r 122         // while priority Q is not empty, iterat
--[ 2022.11.02.10.39.23.200.0 ]--
r 122         // while priority Q is not empty, iterate
--[ 2022.11.02.10.39.23.313.0 ]--
r 122         // while priority Q is not empty, iterate 
--[ 2022.11.02.10.39.23.485.0 ]--
r 122         // while priority Q is not empty, iterate t
--[ 2022.11.02.10.39.23.599.0 ]--
r 122         // while priority Q is not empty, iterate th
--[ 2022.11.02.10.39.23.667.0 ]--
r 122         // while priority Q is not empty, iterate thr
--[ 2022.11.02.10.39.23.750.0 ]--
r 122         // while priority Q is not empty, iterate thro
--[ 2022.11.02.10.39.23.872.0 ]--
r 122         // while priority Q is not empty, iterate throu
--[ 2022.11.02.10.39.23.922.0 ]--
r 122         // while priority Q is not empty, iterate throug
--[ 2022.11.02.10.39.24.185.0 ]--
r 122         // while priority Q is not empty, iterate through
--[ 2022.11.02.10.39.24.451.0 ]--
r 122         // while priority Q is not empty, iterate through 
--[ 2022.11.02.10.39.24.572.0 ]--
r 122         // while priority Q is not empty, iterate through t
--[ 2022.11.02.10.39.24.658.0 ]--
r 122         // while priority Q is not empty, iterate through th
--[ 2022.11.02.10.39.24.709.0 ]--
r 122         // while priority Q is not empty, iterate through the
--[ 2022.11.02.10.39.24.794.0 ]--
r 122         // while priority Q is not empty, iterate through the 
--[ 2022.11.02.10.39.25.412.0 ]--
r 122         // while priority Q is not empty, iterate through the f
--[ 2022.11.02.10.39.25.519.0 ]--
r 122         // while priority Q is not empty, iterate through the fi
--[ 2022.11.02.10.39.25.592.0 ]--
r 122         // while priority Q is not empty, iterate through the fir
--[ 2022.11.02.10.39.25.677.0 ]--
r 122         // while priority Q is not empty, iterate through the firs
--[ 2022.11.02.10.39.25.813.0 ]--
r 122         // while priority Q is not empty, iterate through the first
--[ 2022.11.02.10.39.26.963.0 ]--
r 122         // while priority Q is not empty, iterate through the firs
--[ 2022.11.02.10.39.27.455.0 ]--
r 122         // while priority Q is not empty, iterate through the fir
--[ 2022.11.02.10.39.27.538.0 ]--
r 122         // while priority Q is not empty, iterate through the fi
--[ 2022.11.02.10.39.27.621.0 ]--
r 122         // while priority Q is not empty, iterate through the f
--[ 2022.11.02.10.39.27.705.0 ]--
r 122         // while priority Q is not empty, iterate through the 
--[ 2022.11.02.10.39.27.788.0 ]--
r 122         // while priority Q is not empty, iterate through the
--[ 2022.11.02.10.39.27.872.0 ]--
r 122         // while priority Q is not empty, iterate through th
--[ 2022.11.02.10.39.27.954.0 ]--
r 122         // while priority Q is not empty, iterate through t
--[ 2022.11.02.10.39.28.037.0 ]--
r 122         // while priority Q is not empty, iterate through 
--[ 2022.11.02.10.39.28.121.0 ]--
r 122         // while priority Q is not empty, iterate through
--[ 2022.11.02.10.39.28.205.0 ]--
r 122         // while priority Q is not empty, iterate throug
--[ 2022.11.02.10.39.28.288.0 ]--
r 122         // while priority Q is not empty, iterate throu
--[ 2022.11.02.10.39.28.371.0 ]--
r 122         // while priority Q is not empty, iterate thro
--[ 2022.11.02.10.39.28.455.0 ]--
r 122         // while priority Q is not empty, iterate thr
--[ 2022.11.02.10.39.28.538.0 ]--
r 122         // while priority Q is not empty, iterate th
--[ 2022.11.02.10.39.28.621.0 ]--
r 122         // while priority Q is not empty, iterate t
--[ 2022.11.02.10.39.28.705.0 ]--
r 122         // while priority Q is not empty, iterate 
--[ 2022.11.02.10.39.28.788.0 ]--
r 122         // while priority Q is not empty, iterate
--[ 2022.11.02.10.39.28.872.0 ]--
r 122         // while priority Q is not empty, iterat
--[ 2022.11.02.10.39.28.955.0 ]--
r 122         // while priority Q is not empty, itera
--[ 2022.11.02.10.39.29.037.0 ]--
r 122         // while priority Q is not empty, iter
--[ 2022.11.02.10.39.29.121.0 ]--
r 122         // while priority Q is not empty, ite
--[ 2022.11.02.10.39.29.205.0 ]--
r 122         // while priority Q is not empty, it
--[ 2022.11.02.10.39.29.288.0 ]--
r 122         // while priority Q is not empty, i
--[ 2022.11.02.10.39.29.372.0 ]--
r 122         // while priority Q is not empty, 
--[ 2022.11.02.10.39.30.542.0 ]--
r 122         // while priority Q is not empty, d
--[ 2022.11.02.10.39.30.746.0 ]--
r 122         // while priority Q is not empty, de
--[ 2022.11.02.10.39.31.413.0 ]--
r 122         // while priority Q is not empty, deq
--[ 2022.11.02.10.39.31.552.0 ]--
r 122         // while priority Q is not empty, dequ
--[ 2022.11.02.10.39.31.665.0 ]--
r 122         // while priority Q is not empty, deque
--[ 2022.11.02.10.39.31.764.0 ]--
r 122         // while priority Q is not empty, dequeu
--[ 2022.11.02.10.39.31.884.0 ]--
r 122         // while priority Q is not empty, dequeue
--[ 2022.11.02.10.39.31.960.0 ]--
r 122         // while priority Q is not empty, dequeue 
--[ 2022.11.02.10.39.32.057.0 ]--
r 122         // while priority Q is not empty, dequeue t
--[ 2022.11.02.10.39.32.140.0 ]--
r 122         // while priority Q is not empty, dequeue th
--[ 2022.11.02.10.39.32.167.0 ]--
r 122         // while priority Q is not empty, dequeue the
--[ 2022.11.02.10.39.32.278.0 ]--
r 122         // while priority Q is not empty, dequeue the 
--[ 2022.11.02.10.39.32.470.0 ]--
r 122         // while priority Q is not empty, dequeue the f
--[ 2022.11.02.10.39.32.623.0 ]--
r 122         // while priority Q is not empty, dequeue the fr
--[ 2022.11.02.10.39.32.754.0 ]--
r 122         // while priority Q is not empty, dequeue the fro
--[ 2022.11.02.10.39.32.868.0 ]--
r 122         // while priority Q is not empty, dequeue the fron
--[ 2022.11.02.10.39.32.935.0 ]--
r 122         // while priority Q is not empty, dequeue the front
--[ 2022.11.02.10.39.33.056.0 ]--
r 122         // while priority Q is not empty, dequeue the front 
--[ 2022.11.02.10.39.33.629.0 ]--
r 122         // while priority Q is not empty, dequeue the front
--[ 2022.11.02.10.39.33.783.0 ]--
r 122         // while priority Q is not empty, dequeue the fron
--[ 2022.11.02.10.39.33.947.0 ]--
r 122         // while priority Q is not empty, dequeue the fro
--[ 2022.11.02.10.39.34.132.0 ]--
r 122         // while priority Q is not empty, dequeue the fr
--[ 2022.11.02.10.39.34.308.0 ]--
r 122         // while priority Q is not empty, dequeue the f
--[ 2022.11.02.10.39.34.425.0 ]--
r 122         // while priority Q is not empty, dequeue the fi
--[ 2022.11.02.10.39.34.494.0 ]--
r 122         // while priority Q is not empty, dequeue the fir
--[ 2022.11.02.10.39.34.606.0 ]--
r 122         // while priority Q is not empty, dequeue the firs
--[ 2022.11.02.10.39.34.714.0 ]--
r 122         // while priority Q is not empty, dequeue the first
--[ 2022.11.02.10.39.34.766.0 ]--
r 122         // while priority Q is not empty, dequeue the first 
--[ 2022.11.02.10.39.35.041.0 ]--
r 122         // while priority Q is not empty, dequeue the first t
--[ 2022.11.02.10.39.35.114.0 ]--
r 122         // while priority Q is not empty, dequeue the first ti
--[ 2022.11.02.10.39.35.217.0 ]--
r 122         // while priority Q is not empty, dequeue the first tie
--[ 2022.11.02.10.39.35.313.0 ]--
r 122         // while priority Q is not empty, dequeue the first tiem
--[ 2022.11.02.10.39.35.410.0 ]--
r 122         // while priority Q is not empty, dequeue the first tiem 
--[ 2022.11.02.10.39.35.523.0 ]--
r 122         // while priority Q is not empty, dequeue the first tiem a
--[ 2022.11.02.10.39.35.601.0 ]--
r 122         // while priority Q is not empty, dequeue the first tiem an
--[ 2022.11.02.10.39.35.891.0 ]--
r 122         // while priority Q is not empty, dequeue the first tiem a
--[ 2022.11.02.10.39.36.042.0 ]--
r 122         // while priority Q is not empty, dequeue the first tiem 
--[ 2022.11.02.10.39.36.189.0 ]--
r 122         // while priority Q is not empty, dequeue the first tiem
--[ 2022.11.02.10.39.36.357.0 ]--
r 122         // while priority Q is not empty, dequeue the first tie
--[ 2022.11.02.10.39.36.517.0 ]--
r 122         // while priority Q is not empty, dequeue the first ti
--[ 2022.11.02.10.39.36.687.0 ]--
r 122         // while priority Q is not empty, dequeue the first t
--[ 2022.11.02.10.39.36.849.0 ]--
r 122         // while priority Q is not empty, dequeue the first 
--[ 2022.11.02.10.39.36.944.0 ]--
r 122         // while priority Q is not empty, dequeue the first i
--[ 2022.11.02.10.39.37.079.0 ]--
r 122         // while priority Q is not empty, dequeue the first it
--[ 2022.11.02.10.39.37.193.0 ]--
r 122         // while priority Q is not empty, dequeue the first ite
--[ 2022.11.02.10.39.37.236.0 ]--
r 122         // while priority Q is not empty, dequeue the first item
--[ 2022.11.02.10.39.37.449.0 ]--
r 122         // while priority Q is not empty, dequeue the first item 
--[ 2022.11.02.10.39.37.558.0 ]--
r 122         // while priority Q is not empty, dequeue the first item a
--[ 2022.11.02.10.39.37.679.0 ]--
r 122         // while priority Q is not empty, dequeue the first item an
--[ 2022.11.02.10.39.37.735.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and
--[ 2022.11.02.10.39.37.842.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and 
--[ 2022.11.02.10.39.38.024.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and p
--[ 2022.11.02.10.39.38.107.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and pr
--[ 2022.11.02.10.39.38.163.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and pro
--[ 2022.11.02.10.39.38.341.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and proc
--[ 2022.11.02.10.39.38.500.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and proce
--[ 2022.11.02.10.39.38.652.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and proces
--[ 2022.11.02.10.39.38.783.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and process
--[ 2022.11.02.10.39.38.861.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and process 
--[ 2022.11.02.10.39.39.003.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and process i
--[ 2022.11.02.10.39.39.091.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and process it
--[ 2022.11.02.10.39.39.315.0 ]--
r 122         // while priority Q is not empty, dequeue the first item and process it.
--[ 2022.11.02.10.39.56.077.0 ]--
r 126 
--[ 2022.11.02.10.40.02.187.0 ]--
r 126     
--[ 2022.11.02.10.40.02.354.0 ]--
r 126         
--[ 2022.11.02.10.40.02.550.0 ]--
r 126             
--[ 2022.11.03.09.29.13.158.0 ]--
r 126             p
--[ 2022.11.03.09.29.13.256.0 ]--
r 126             pq
--[ 2022.11.03.09.29.13.767.0 ]--
r 126             p
--[ 2022.11.03.09.29.13.956.0 ]--
r 126             
--[ 2022.11.03.09.29.16.458.0 ]--
r 126             n
--[ 2022.11.03.09.29.16.562.0 ]--
r 126             ne
--[ 2022.11.03.09.29.16.702.0 ]--
r 126             nex
--[ 2022.11.03.09.29.17.105.0 ]--
r 126             ne
--[ 2022.11.03.09.29.17.290.0 ]--
r 126             n
--[ 2022.11.03.09.29.17.443.0 ]--
r 126             
--[ 2022.11.03.09.29.18.310.0 ]--
r 126             P
--[ 2022.11.03.09.29.18.727.0 ]--
r 126             PF
--[ 2022.11.03.09.29.19.524.0 ]--
r 126             PFNode
--[ 2022.11.03.09.29.20.131.0 ]--
r 126             PFNode 
--[ 2022.11.03.09.29.22.539.0 ]--
r 126             PFNode n
--[ 2022.11.03.09.29.22.615.0 ]--
r 126             PFNode ne
--[ 2022.11.03.09.29.22.813.0 ]--
r 126             PFNode nex
--[ 2022.11.03.09.29.22.954.0 ]--
r 126             PFNode next
--[ 2022.11.03.09.29.23.090.0 ]--
r 126             PFNode next 
--[ 2022.11.03.09.29.23.263.0 ]--
r 126             PFNode next =
--[ 2022.11.03.09.29.23.355.0 ]--
r 126             PFNode next = 
--[ 2022.11.03.09.29.24.293.0 ]--
r 126             PFNode next =
--[ 2022.11.03.09.29.24.478.0 ]--
r 126             PFNode next 
--[ 2022.11.03.09.29.24.658.0 ]--
r 126             PFNode next
--[ 2022.11.03.09.29.24.841.0 ]--
r 126             PFNode nex
--[ 2022.11.03.09.29.25.555.0 ]--
r 126             PFNode next
--[ 2022.11.03.09.29.26.424.0 ]--
r 126             PFNode nextT
--[ 2022.11.03.09.29.26.528.0 ]--
r 126             PFNode nextTi
--[ 2022.11.03.09.29.26.617.0 ]--
r 126             PFNode nextTil
--[ 2022.11.03.09.29.26.738.0 ]--
r 126             PFNode nextTile
--[ 2022.11.03.09.29.27.486.0 ]--
r 126             PFNode nextTile 
--[ 2022.11.03.09.29.27.571.0 ]--
r 126             PFNode nextTile =
--[ 2022.11.03.09.29.27.683.0 ]--
r 126             PFNode nextTile = 
--[ 2022.11.03.09.29.29.135.0 ]--
r 126             PFNode nextTile = p
--[ 2022.11.03.09.29.29.225.0 ]--
r 126             PFNode nextTile = pq
--[ 2022.11.03.09.29.29.424.0 ]--
r 126             PFNode nextTile = pq.
--[ 2022.11.03.09.29.29.727.0 ]--
r 126             PFNode nextTile = pq.m
--[ 2022.11.03.09.29.29.870.0 ]--
r 126             PFNode nextTile = pq.mi
--[ 2022.11.03.09.29.30.275.0 ]--
r 126             PFNode nextTile = pq.min
--[ 2022.11.03.09.29.30.280.0 ]--
r 126             PFNode nextTile = pq.min()
--[ 2022.11.03.09.29.30.819.0 ]--
r 126             PFNode nextTile = pq.min();
--[ 2022.11.03.10.51.46.229.0 ]--
DisposeComponent
--[ 2022.11.03.14.12.22.561.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.03.14.12.22.595.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2022.11.03.14.12.22.599.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.03.14.12.22.599.1 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq = new MinPQ<>();
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        boolean searched, found;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.getCost(heuristic) > that.getCost(heuristic)) {
                return 1;
            }
            else if (this.getCost(heuristic) < that.getCost(heuristic)) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            this.cost = prevNode.getCost(0)
                    + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                    + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
            return this.cost;
        }

        // returns if this PFNode is still valid
        public boolean isValid() {
            if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(), t.getN()) )) {
                return true;
            }
            return false;
        }

        // invalidates the PFNode
        public void invalidate() {
        }

        // returns if the PFNode has been used
        public boolean isUsed() {
            return true;
        }

        // uses the PFNode
        public void use() {
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        int n = t.getN();
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[n][n];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
    }

    public void computePath() {
        // while priority Q is not empty, dequeue the first item and process it.
        while(!pq.isEmpty()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.min();
        }
    }

    public boolean foundPath() {
        return false;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {return false;
    }
}

--[ 2022.11.03.14.12.22.600.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.03.14.12.22.611.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[2];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.03.14.12.22.611.1 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.03.14.12.22.611.2 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.03.14.12.22.612.0 ]--
InitFile: /.cos265


--[ 2022.11.03.14.12.22.612.1 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.03.14.12.22.612.2 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2022.11.03.14.12.36.701.0 ]--
:/src/Pathfinder.java
+ 127             
--[ 2022.11.03.14.12.38.108.0 ]--
r 127             i
--[ 2022.11.03.14.12.38.127.0 ]--
r 127             if
--[ 2022.11.03.14.12.38.441.0 ]--
r 127             if 
--[ 2022.11.03.14.12.39.244.0 ]--
r 127             if ()
--[ 2022.11.03.14.12.42.525.0 ]--
r 127             if (n)
--[ 2022.11.03.14.12.42.538.0 ]--
r 127             if (ne)
--[ 2022.11.03.14.12.42.727.0 ]--
r 127             if (nex)
--[ 2022.11.03.14.12.42.863.0 ]--
r 127             if (next)
--[ 2022.11.03.14.12.43.454.0 ]--
r 127             if (nextTile)
--[ 2022.11.03.14.12.43.767.0 ]--
r 127             if (nextTile.)
--[ 2022.11.03.14.12.45.787.0 ]--
r 127             if (nextTile.l)
--[ 2022.11.03.14.12.45.969.0 ]--
r 127             if (nextTile.lo)
--[ 2022.11.03.14.12.46.621.0 ]--
r 127             if (nextTile.l)
--[ 2022.11.03.14.12.46.775.0 ]--
r 127             if (nextTile.)
--[ 2022.11.03.14.12.59.378.0 ]--
r 127             if (nextTile.c)
--[ 2022.11.03.14.12.59.468.0 ]--
r 127             if (nextTile.cu)
--[ 2022.11.03.14.12.59.580.0 ]--
r 127             if (nextTile.cur)
--[ 2022.11.03.14.12.59.982.0 ]--
r 127             if (nextTile.currentTile)
--[ 2022.11.03.14.13.01.351.0 ]--
r 127             if (nextTile.currentTile[])
--[ 2022.11.03.14.13.39.505.0 ]--
r 127             if (nextTile.currentTile)
--[ 2022.11.03.14.14.35.198.0 ]--
r 127             if (nextTile.currentTile[])
--[ 2022.11.03.14.14.36.718.0 ]--
r 127             if (nextTile.currentTile[]p)
--[ 2022.11.03.14.14.37.602.0 ]--
r 127             if (nextTile.currentTile[])
--[ 2022.11.03.14.14.37.944.0 ]--
r 127             if (nextTile.currentTile[][])
--[ 2022.11.03.14.15.00.482.0 ]--
r 127             if (nextTile.currentTile[])
--[ 2022.11.03.14.15.00.650.0 ]--
r 127             if (nextTile.currentTile[)
--[ 2022.11.03.14.15.01.003.0 ]--
r 127             if (nextTile.currentTile)
--[ 2022.11.03.14.15.02.140.0 ]--
r 127             if (nextTile.currentTile.)
--[ 2022.11.03.14.15.02.800.0 ]--
r 127             if (nextTile.currentTile.j)
--[ 2022.11.03.14.15.09.120.0 ]--
r 127             if (nextTile.currentTile.)
--[ 2022.11.03.14.15.09.901.0 ]--
r 127             if (nextTile.currentTile.g)
--[ 2022.11.03.14.15.10.016.0 ]--
r 127             if (nextTile.currentTile.ge)
--[ 2022.11.03.14.15.10.150.0 ]--
r 127             if (nextTile.currentTile.get)
--[ 2022.11.03.14.15.10.686.0 ]--
r 127             if (nextTile.currentTile.getI)
--[ 2022.11.03.14.15.10.697.0 ]--
r 127             if (nextTile.currentTile.getI())
--[ 2022.11.03.14.15.11.660.0 ]--
r 127             if (nextTile.currentTile.getI() )
--[ 2022.11.03.14.15.11.787.0 ]--
r 127             if (nextTile.currentTile.getI() =)
--[ 2022.11.03.14.15.11.936.0 ]--
r 127             if (nextTile.currentTile.getI() ==)
--[ 2022.11.03.14.15.12.052.0 ]--
r 127             if (nextTile.currentTile.getI() == )
--[ 2022.11.03.14.15.14.720.0 ]--
r 127             if (nextTile.currentTile.getI() ==)
--[ 2022.11.03.14.15.14.944.0 ]--
r 127             if (nextTile.currentTile.getI() =)
--[ 2022.11.03.14.15.15.105.0 ]--
r 127             if (nextTile.currentTile.getI() )
--[ 2022.11.03.14.15.16.356.0 ]--
r 127             if (nextTile.currentTile.getI() +)
--[ 2022.11.03.14.15.16.815.0 ]--
r 127             if (nextTile.currentTile.getI() + )
--[ 2022.11.03.14.15.17.222.0 ]--
r 127             if (nextTile.currentTile.getI() +  )
--[ 2022.11.03.14.15.17.575.0 ]--
r 127             if (nextTile.currentTile.getI() + )
--[ 2022.11.03.14.15.17.640.0 ]--
r 127             if (nextTile.currentTile.getI() + 1)
--[ 2022.11.03.14.15.17.728.0 ]--
r 127             if (nextTile.currentTile.getI() + 1 )
--[ 2022.11.03.14.15.18.303.0 ]--
r 127             if (nextTile.currentTile.getI() + 1 =)
--[ 2022.11.03.14.15.19.383.0 ]--
r 127             if (nextTile.currentTile.getI() + 1 ==)
--[ 2022.11.03.14.15.19.697.0 ]--
r 127             if (nextTile.currentTile.getI() + 1 == )
--[ 2022.11.03.14.15.21.598.0 ]--
r 127             if (nextTile.currentTile.getI() + 1 ==)
--[ 2022.11.03.14.15.21.781.0 ]--
r 127             if (nextTile.currentTile.getI() + 1 =)
--[ 2022.11.03.14.15.21.960.0 ]--
r 127             if (nextTile.currentTile.getI() + 1 )
--[ 2022.11.03.14.15.22.137.0 ]--
r 127             if (nextTile.currentTile.getI() + 1)
--[ 2022.11.03.14.15.41.811.0 ]--
r 127             if (anextTile.currentTile.getI() + 1)
--[ 2022.11.03.14.15.42.005.0 ]--
r 127             if (arnextTile.currentTile.getI() + 1)
--[ 2022.11.03.14.15.42.146.0 ]--
r 127             if (arrnextTile.currentTile.getI() + 1)
--[ 2022.11.03.14.15.42.230.0 ]--
r 127             if (arranextTile.currentTile.getI() + 1)
--[ 2022.11.03.14.15.42.320.0 ]--
r 127             if (arraynextTile.currentTile.getI() + 1)
--[ 2022.11.03.14.15.44.013.0 ]--
r 127             if (array[nextTile.currentTile.getI() + 1)
--[ 2022.11.03.14.15.46.810.0 ]--
r 127             if (array[nextTile.currentTile.getI() + 1])
--[ 2022.11.03.14.15.48.278.0 ]--
r 127             if (array[nextTile.currentTile.getI() + 1][])
--[ 2022.11.03.14.15.49.753.0 ]--
r 127             if (array[nextTile.currentTile.getI() + 1])
--[ 2022.11.03.14.15.49.929.0 ]--
r 127             if (array[nextTile.currentTile.getI() + 1)
--[ 2022.11.03.14.15.50.096.0 ]--
r 127             if (array[nextTile.currentTile.getI() + )
--[ 2022.11.03.14.15.50.272.0 ]--
r 127             if (array[nextTile.currentTile.getI() +)
--[ 2022.11.03.14.15.50.431.0 ]--
r 127             if (array[nextTile.currentTile.getI() )
--[ 2022.11.03.14.15.50.898.0 ]--
r 127             if (array[nextTile.currentTile.getI())
--[ 2022.11.03.14.15.56.080.0 ]--
r 127             if (array[nextTile.currentTile.getI()])
--[ 2022.11.03.14.15.56.817.0 ]--
r 127             if (array[nextTile.currentTile.getI()][])
--[ 2022.11.03.14.15.58.262.0 ]--
r 127             if (array[nextTile.currentTile.getI()][n])
--[ 2022.11.03.14.15.58.325.0 ]--
r 127             if (array[nextTile.currentTile.getI()][ne])
--[ 2022.11.03.14.15.58.508.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nex])
--[ 2022.11.03.14.15.58.652.0 ]--
r 127             if (array[nextTile.currentTile.getI()][next])
--[ 2022.11.03.14.15.58.821.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nexti])
--[ 2022.11.03.14.15.58.906.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextil])
--[ 2022.11.03.14.15.59.158.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile])
--[ 2022.11.03.14.15.59.538.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.])
--[ 2022.11.03.14.16.00.246.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.c])
--[ 2022.11.03.14.16.00.311.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.cu])
--[ 2022.11.03.14.16.00.481.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile])
--[ 2022.11.03.14.16.00.830.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile.])
--[ 2022.11.03.14.16.01.465.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile.g])
--[ 2022.11.03.14.16.01.546.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile.ge])
--[ 2022.11.03.14.16.01.694.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile.get])
--[ 2022.11.03.14.16.02.647.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile.getj])
--[ 2022.11.03.14.16.03.008.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile.getJ])
--[ 2022.11.03.14.16.03.016.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()])
--[ 2022.11.03.14.16.04.656.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+])
--[ 2022.11.03.14.16.05.344.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1])
--[ 2022.11.03.14.16.08.113.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) 
--[ 2022.11.03.14.16.08.348.0 ]--
r 127             if (array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.03.14.16.08.576.0 ]--
+ 128 
+ 129 }
--[ 2022.11.03.14.16.08.603.0 ]--
r 129             }
--[ 2022.11.03.14.16.08.626.0 ]--
r 128                 
--[ 2022.11.03.14.16.18.603.0 ]--
r 128                 m
--[ 2022.11.03.14.16.18.731.0 ]--
r 128                 mi
--[ 2022.11.03.14.16.18.826.0 ]--
r 128                 min
--[ 2022.11.03.14.16.19.415.0 ]--
r 128                 mi
--[ 2022.11.03.14.16.19.596.0 ]--
r 128                 m
--[ 2022.11.03.14.16.20.053.0 ]--
r 128                 
--[ 2022.11.03.14.16.20.295.0 ]--
r 128                 p
--[ 2022.11.03.14.16.20.448.0 ]--
r 128                 pq
--[ 2022.11.03.14.16.20.675.0 ]--
r 128                 pq.
--[ 2022.11.03.14.16.21.483.0 ]--
r 128                 pq.e
--[ 2022.11.03.14.16.21.564.0 ]--
r 128                 pq.en
--[ 2022.11.03.14.16.22.355.0 ]--
r 128                 pq.e
--[ 2022.11.03.14.16.22.521.0 ]--
r 128                 pq.
--[ 2022.11.03.14.16.23.803.0 ]--
r 128                 pq
--[ 2022.11.03.14.16.24.162.0 ]--
r 128                 pq.
--[ 2022.11.03.14.16.28.956.0 ]--
r 128                 pq.insert
--[ 2022.11.03.14.16.28.965.0 ]--
r 128                 pq.insert()
--[ 2022.11.03.14.16.28.970.0 ]--
r 128                 pq.insert();
--[ 2022.11.03.14.16.44.640.0 ]--
+ 128                 
--[ 2022.11.03.14.16.49.917.0 ]--
r 128                 N
--[ 2022.11.03.14.16.50.020.0 ]--
r 128                 No
--[ 2022.11.03.14.16.50.172.0 ]--
r 128                 Nod
--[ 2022.11.03.14.16.50.985.0 ]--
r 128                 PFNode
--[ 2022.11.03.14.16.52.332.0 ]--
r 128                 PFNode 
--[ 2022.11.03.14.16.54.664.0 ]--
r 128                 PFNode l
--[ 2022.11.03.14.16.55.405.0 ]--
r 128                 PFNode le
--[ 2022.11.03.14.16.55.509.0 ]--
r 128                 PFNode lef
--[ 2022.11.03.14.16.55.747.0 ]--
r 128                 PFNode left
--[ 2022.11.03.14.16.57.469.0 ]--
r 128                 PFNode left 
--[ 2022.11.03.14.16.57.589.0 ]--
r 128                 PFNode left =
--[ 2022.11.03.14.16.57.707.0 ]--
r 128                 PFNode left = 
--[ 2022.11.03.14.16.58.533.0 ]--
r 128                 PFNode left = n
--[ 2022.11.03.14.16.58.621.0 ]--
r 128                 PFNode left = ne
--[ 2022.11.03.14.16.58.676.0 ]--
r 128                 PFNode left = new
--[ 2022.11.03.14.16.58.825.0 ]--
r 128                 PFNode left = new 
--[ 2022.11.03.14.16.59.333.0 ]--
r 128                 PFNode left = new P
--[ 2022.11.03.14.16.59.988.0 ]--
r 128                 PFNode left = new PFNode
--[ 2022.11.03.14.16.59.994.0 ]--
r 128                 PFNode left = new PFNode()
--[ 2022.11.03.14.17.02.124.0 ]--
r 128                 PFNode left = new PFNode();
--[ 2022.11.03.14.17.20.510.0 ]--
r 128                 PFNode left = new PFNode(C);
--[ 2022.11.03.14.17.20.750.0 ]--
r 128                 PFNode left = new PFNode(Co);
--[ 2022.11.03.14.17.20.871.0 ]--
r 128                 PFNode left = new PFNode(Coo);
--[ 2022.11.03.14.17.20.960.0 ]--
r 128                 PFNode left = new PFNode(Coor);
--[ 2022.11.03.14.17.21.076.0 ]--
r 128                 PFNode left = new PFNode(Coord);
--[ 2022.11.03.14.17.22.066.0 ]--
r 128                 PFNode left = new PFNode(Coord());
--[ 2022.11.03.14.17.24.970.0 ]--
r 128                 PFNode left = new PFNode(Coord(g));
--[ 2022.11.03.14.17.25.123.0 ]--
r 128                 PFNode left = new PFNode(Coord(ge));
--[ 2022.11.03.14.17.25.234.0 ]--
r 128                 PFNode left = new PFNode(Coord(get));
--[ 2022.11.03.14.17.26.403.0 ]--
r 128                 PFNode left = new PFNode(Coord(geti));
--[ 2022.11.03.14.17.27.090.0 ]--
r 128                 PFNode left = new PFNode(Coord(get));
--[ 2022.11.03.14.17.27.263.0 ]--
r 128                 PFNode left = new PFNode(Coord(ge));
--[ 2022.11.03.14.17.27.433.0 ]--
r 128                 PFNode left = new PFNode(Coord(g));
--[ 2022.11.03.14.17.27.604.0 ]--
r 128                 PFNode left = new PFNode(Coord());
--[ 2022.11.03.14.17.28.171.0 ]--
r 128                 PFNode left = new PFNode(Coord(n));
--[ 2022.11.03.14.17.28.238.0 ]--
r 128                 PFNode left = new PFNode(Coord(ne));
--[ 2022.11.03.14.17.28.980.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile));
--[ 2022.11.03.14.17.29.331.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.));
--[ 2022.11.03.14.17.32.243.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile));
--[ 2022.11.03.14.17.36.386.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTil));
--[ 2022.11.03.14.17.36.874.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTi));
--[ 2022.11.03.14.17.36.958.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentT));
--[ 2022.11.03.14.17.37.039.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.current));
--[ 2022.11.03.14.17.37.125.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.curren));
--[ 2022.11.03.14.17.37.207.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.curre));
--[ 2022.11.03.14.17.37.293.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.curr));
--[ 2022.11.03.14.17.37.377.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.cur));
--[ 2022.11.03.14.17.37.461.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.cu));
--[ 2022.11.03.14.17.37.545.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.c));
--[ 2022.11.03.14.17.37.630.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.));
--[ 2022.11.03.14.17.37.713.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile));
--[ 2022.11.03.14.17.37.798.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTil));
--[ 2022.11.03.14.17.37.881.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTi));
--[ 2022.11.03.14.17.37.964.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextT));
--[ 2022.11.03.14.17.38.053.0 ]--
r 128                 PFNode left = new PFNode(Coord(next));
--[ 2022.11.03.14.17.38.130.0 ]--
r 128                 PFNode left = new PFNode(Coord(nex));
--[ 2022.11.03.14.17.38.213.0 ]--
r 128                 PFNode left = new PFNode(Coord(ne));
--[ 2022.11.03.14.17.38.295.0 ]--
r 128                 PFNode left = new PFNode(Coord(n));
--[ 2022.11.03.14.17.38.681.0 ]--
r 128                 PFNode left = new PFNode(Coord());
--[ 2022.11.03.14.18.12.098.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile.getI()));
--[ 2022.11.03.14.18.12.195.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile.getI()nextTile.currentTile.getI()));
--[ 2022.11.03.14.18.14.606.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile.getI()));
--[ 2022.11.03.14.18.16.190.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile.getI(),));
--[ 2022.11.03.14.18.16.345.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile.getI(), ));
--[ 2022.11.03.14.18.22.878.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1));
--[ 2022.11.03.14.18.34.143.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1),);
--[ 2022.11.03.14.18.35.322.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), );
--[ 2022.11.03.14.18.37.421.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), n);
--[ 2022.11.03.14.18.37.495.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), ne);
--[ 2022.11.03.14.18.38.641.0 ]--
r 128                 PFNode left = new PFNode(Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.03.14.19.55.242.0 ]--
r 129                 pq.insert(l);
--[ 2022.11.03.14.19.55.282.0 ]--
r 129                 pq.insert(le);
--[ 2022.11.03.14.19.55.457.0 ]--
r 129                 pq.insert(lef);
--[ 2022.11.03.14.19.55.710.0 ]--
r 129                 pq.insert(left);
--[ 2022.11.03.14.20.29.252.0 ]--
r 127             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.03.14.21.15.185.0 ]--
r 128                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.03.14.22.27.983.0 ]--
+ 129                 
--[ 2022.11.03.14.22.28.919.0 ]--
r 129                 a
--[ 2022.11.03.14.22.29.311.0 ]--
r 129                 
--[ 2022.11.03.14.22.29.387.0 ]--
r 129                 z
--[ 2022.11.03.14.22.29.513.0 ]--
r 129                 zf
--[ 2022.11.03.14.22.29.951.0 ]--
r 129                 z
--[ 2022.11.03.14.22.30.136.0 ]--
r 129                 
--[ 2022.11.03.14.22.30.548.0 ]--
r 129                 a
--[ 2022.11.03.14.22.30.678.0 ]--
r 129                 ar
--[ 2022.11.03.14.22.30.986.0 ]--
r 129                 arr
--[ 2022.11.03.14.22.31.073.0 ]--
r 129                 arra
--[ 2022.11.03.14.22.31.161.0 ]--
r 129                 array
--[ 2022.11.03.14.22.31.842.0 ]--
r 129                 array[]
--[ 2022.11.03.14.22.33.607.0 ]--
r 129                 array[][]
--[ 2022.11.03.14.22.42.894.0 ]--
r 129                 array[][
--[ 2022.11.03.14.22.43.055.0 ]--
r 129                 array[]
--[ 2022.11.03.14.22.43.225.0 ]--
r 129                 array[
--[ 2022.11.03.14.22.43.405.0 ]--
r 129                 array
--[ 2022.11.03.14.22.48.983.0 ]--
r 129                 arraynextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]
--[ 2022.11.03.14.22.52.047.0 ]--
r 129                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]
--[ 2022.11.03.14.22.54.768.0 ]--
r 129                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] 
--[ 2022.11.03.14.22.54.870.0 ]--
r 129                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] =
--[ 2022.11.03.14.22.55.011.0 ]--
r 129                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = 
--[ 2022.11.03.14.22.55.694.0 ]--
r 129                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = t
--[ 2022.11.03.14.22.55.854.0 ]--
r 129                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = tr
--[ 2022.11.03.14.22.55.950.0 ]--
r 129                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = tru
--[ 2022.11.03.14.22.56.022.0 ]--
r 129                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = true
--[ 2022.11.03.14.22.56.370.0 ]--
r 129                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = true;
--[ 2022.11.03.14.28.43.364.0 ]--
r 151     public boolean wasSearched(Coord loc) {return a;
--[ 2022.11.03.14.28.43.507.0 ]--
r 151     public boolean wasSearched(Coord loc) {return ar;
--[ 2022.11.03.14.28.43.649.0 ]--
r 151     public boolean wasSearched(Coord loc) {return arr;
--[ 2022.11.03.14.28.43.763.0 ]--
r 151     public boolean wasSearched(Coord loc) {return arra;
--[ 2022.11.03.14.28.43.824.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array;
--[ 2022.11.03.14.28.44.342.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[];
--[ 2022.11.03.14.28.45.384.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[l];
--[ 2022.11.03.14.28.45.552.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[lo];
--[ 2022.11.03.14.28.45.643.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc];
--[ 2022.11.03.14.28.45.831.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.];
--[ 2022.11.03.14.28.46.366.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.g];
--[ 2022.11.03.14.28.46.466.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.ge];
--[ 2022.11.03.14.28.47.274.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.gei];
--[ 2022.11.03.14.28.47.462.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI];
--[ 2022.11.03.14.28.47.470.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI()];
--[ 2022.11.03.14.28.48.682.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI(),];
--[ 2022.11.03.14.28.49.086.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI(),l];
--[ 2022.11.03.14.28.49.264.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI(),lo];
--[ 2022.11.03.14.28.49.363.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI(),loc];
--[ 2022.11.03.14.28.49.658.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI(),loc.];
--[ 2022.11.03.14.28.50.394.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI(),loc.g];
--[ 2022.11.03.14.28.50.517.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI(),loc.ge];
--[ 2022.11.03.14.28.50.654.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI(),loc.get];
--[ 2022.11.03.14.28.50.846.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI(),loc.getj];
--[ 2022.11.03.14.28.51.301.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI(),loc.getJ];
--[ 2022.11.03.14.28.51.309.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI(),loc.getJ()];
--[ 2022.11.03.14.28.57.831.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI()],loc.getJ()];
--[ 2022.11.03.14.28.58.586.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI()]loc.getJ()];
--[ 2022.11.03.14.28.59.367.0 ]--
r 151     public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
--[ 2022.11.03.14.31.20.553.0 ]--
+ 127             
--[ 2022.11.03.14.31.20.776.0 ]--
r 127             /
--[ 2022.11.03.14.31.20.921.0 ]--
r 127             //
--[ 2022.11.03.14.31.21.717.0 ]--
r 127             // 
--[ 2022.11.03.14.31.22.121.0 ]--
r 127             // l
--[ 2022.11.03.14.31.22.210.0 ]--
r 127             // le
--[ 2022.11.03.14.31.22.337.0 ]--
r 127             // lef
--[ 2022.11.03.14.31.22.535.0 ]--
r 127             // left
--[ 2022.11.03.14.31.22.653.0 ]--
r 127             // left 
--[ 2022.11.03.14.31.23.293.0 ]--
r 127             // left o
--[ 2022.11.03.14.31.23.360.0 ]--
r 127             // left of
--[ 2022.11.03.14.31.23.475.0 ]--
r 127             // left of 
--[ 2022.11.03.14.31.23.637.0 ]--
r 127             // left of c
--[ 2022.11.03.14.31.23.736.0 ]--
r 127             // left of cu
--[ 2022.11.03.14.31.23.857.0 ]--
r 127             // left of cur
--[ 2022.11.03.14.31.24.015.0 ]--
r 127             // left of curr
--[ 2022.11.03.14.31.24.051.0 ]--
r 127             // left of curre
--[ 2022.11.03.14.31.24.170.0 ]--
r 127             // left of curren
--[ 2022.11.03.14.31.24.258.0 ]--
r 127             // left of current
--[ 2022.11.03.14.31.24.363.0 ]--
r 127             // left of current 
--[ 2022.11.03.14.31.25.066.0 ]--
r 127             // left of current t
--[ 2022.11.03.14.31.25.132.0 ]--
r 127             // left of current ti
--[ 2022.11.03.14.31.25.221.0 ]--
r 127             // left of current til
--[ 2022.11.03.14.31.25.262.0 ]--
r 127             // left of current tile
--[ 2022.11.03.14.31.27.597.0 ]--
+ 133             
--[ 2022.11.03.14.31.28.283.0 ]--
r 133             /
--[ 2022.11.03.14.31.28.632.0 ]--
r 133             //
--[ 2022.11.03.14.31.29.575.0 ]--
r 133             // 
--[ 2022.11.03.14.31.31.203.0 ]--
r 133             // r
--[ 2022.11.03.14.31.31.259.0 ]--
r 133             // ri
--[ 2022.11.03.14.31.31.389.0 ]--
r 133             // rig
--[ 2022.11.03.14.31.31.499.0 ]--
r 133             // righ
--[ 2022.11.03.14.31.31.564.0 ]--
r 133             // right
--[ 2022.11.03.14.31.31.691.0 ]--
r 133             // right 
--[ 2022.11.03.14.31.31.819.0 ]--
r 133             // right o
--[ 2022.11.03.14.31.31.898.0 ]--
r 133             // right of
--[ 2022.11.03.14.31.32.025.0 ]--
r 133             // right of 
--[ 2022.11.03.14.31.32.223.0 ]--
r 133             // right of c
--[ 2022.11.03.14.31.32.337.0 ]--
r 133             // right of cu
--[ 2022.11.03.14.31.32.416.0 ]--
r 133             // right of cur
--[ 2022.11.03.14.31.32.578.0 ]--
r 133             // right of curr
--[ 2022.11.03.14.31.32.665.0 ]--
r 133             // right of curre
--[ 2022.11.03.14.31.32.764.0 ]--
r 133             // right of curren
--[ 2022.11.03.14.31.32.854.0 ]--
r 133             // right of current
--[ 2022.11.03.14.31.32.936.0 ]--
r 133             // right of current 
--[ 2022.11.03.14.31.33.056.0 ]--
r 133             // right of current t
--[ 2022.11.03.14.31.33.099.0 ]--
r 133             // right of current ti
--[ 2022.11.03.14.31.33.191.0 ]--
r 133             // right of current til
--[ 2022.11.03.14.31.33.243.0 ]--
r 133             // right of current tile
--[ 2022.11.03.14.31.37.815.0 ]--
+ 134             
--[ 2022.11.03.14.31.39.016.0 ]--
r 134             /
--[ 2022.11.03.14.31.39.271.0 ]--
r 134             //
--[ 2022.11.03.14.31.39.938.0 ]--
r 134             // 
--[ 2022.11.03.14.31.45.136.0 ]--
r 134             // a
--[ 2022.11.03.14.31.45.439.0 ]--
r 134             // av
--[ 2022.11.03.14.31.45.587.0 ]--
r 134             // avo
--[ 2022.11.03.14.31.45.723.0 ]--
r 134             // avoe
--[ 2022.11.03.14.31.46.214.0 ]--
r 134             // avo
--[ 2022.11.03.14.31.46.381.0 ]--
r 134             // av
--[ 2022.11.03.14.31.46.539.0 ]--
r 134             // a
--[ 2022.11.03.14.31.46.687.0 ]--
r 134             // ab
--[ 2022.11.03.14.31.46.784.0 ]--
r 134             // abo
--[ 2022.11.03.14.31.47.179.0 ]--
r 134             // abov
--[ 2022.11.03.14.31.47.368.0 ]--
r 134             // above
--[ 2022.11.03.14.31.47.451.0 ]--
r 134             // above 
--[ 2022.11.03.14.31.47.715.0 ]--
r 134             // above c
--[ 2022.11.03.14.31.47.836.0 ]--
r 134             // above cu
--[ 2022.11.03.14.31.47.928.0 ]--
r 134             // above cur
--[ 2022.11.03.14.31.48.074.0 ]--
r 134             // above curr
--[ 2022.11.03.14.31.48.142.0 ]--
r 134             // above curre
--[ 2022.11.03.14.31.48.269.0 ]--
r 134             // above curren
--[ 2022.11.03.14.31.48.348.0 ]--
r 134             // above current
--[ 2022.11.03.14.31.48.487.0 ]--
r 134             // above current 
--[ 2022.11.03.14.31.48.671.0 ]--
r 134             // above current t
--[ 2022.11.03.14.31.48.756.0 ]--
r 134             // above current ti
--[ 2022.11.03.14.31.48.859.0 ]--
r 134             // above current til
--[ 2022.11.03.14.31.48.899.0 ]--
r 134             // above current tile
--[ 2022.11.03.14.31.49.169.0 ]--
+ 135             
--[ 2022.11.03.14.31.49.737.0 ]--
r 135             /
--[ 2022.11.03.14.31.49.899.0 ]--
r 135             //
--[ 2022.11.03.14.31.50.035.0 ]--
r 135             // 
--[ 2022.11.03.14.31.50.166.0 ]--
r 135             // b
--[ 2022.11.03.14.31.50.292.0 ]--
r 135             // be
--[ 2022.11.03.14.31.50.323.0 ]--
r 135             // bel
--[ 2022.11.03.14.31.50.515.0 ]--
r 135             // belo
--[ 2022.11.03.14.31.50.576.0 ]--
r 135             // below
--[ 2022.11.03.14.31.50.782.0 ]--
r 135             // below 
--[ 2022.11.03.14.31.50.952.0 ]--
r 135             // below c
--[ 2022.11.03.14.31.51.099.0 ]--
r 135             // below cu
--[ 2022.11.03.14.31.51.177.0 ]--
r 135             // below cur
--[ 2022.11.03.14.31.51.335.0 ]--
r 135             // below curr
--[ 2022.11.03.14.31.51.411.0 ]--
r 135             // below curre
--[ 2022.11.03.14.31.51.448.0 ]--
r 135             // below curren
--[ 2022.11.03.14.31.51.571.0 ]--
r 135             // below current
--[ 2022.11.03.14.31.51.682.0 ]--
r 135             // below current 
--[ 2022.11.03.14.31.51.820.0 ]--
r 135             // below current t
--[ 2022.11.03.14.31.51.864.0 ]--
r 135             // below current ti
--[ 2022.11.03.14.31.51.912.0 ]--
r 135             // below current til
--[ 2022.11.03.14.31.51.988.0 ]--
r 135             // below current tile
--[ 2022.11.03.14.32.41.224.0 ]--
r 123         while(!i) {
--[ 2022.11.03.14.32.41.286.0 ]--
r 123         while(!is) {
--[ 2022.11.03.14.32.42.359.0 ]--
r 123         while(!i) {
--[ 2022.11.03.14.32.42.498.0 ]--
r 123         while(!) {
--[ 2022.11.03.14.32.42.613.0 ]--
r 123         while(!f) {
--[ 2022.11.03.14.32.42.714.0 ]--
r 123         while(!fo) {
--[ 2022.11.03.14.32.42.805.0 ]--
r 123         while(!fou) {
--[ 2022.11.03.14.32.43.340.0 ]--
r 123         while(!foundPath) {
--[ 2022.11.03.14.32.43.347.0 ]--
r 123         while(!foundPath()) {
--[ 2022.11.03.14.33.02.996.0 ]--
+ 15     
--[ 2022.11.03.14.33.03.901.0 ]--
r 15     b
--[ 2022.11.03.14.33.03.988.0 ]--
r 15     bo
--[ 2022.11.03.14.33.04.108.0 ]--
r 15     boo
--[ 2022.11.03.14.33.04.287.0 ]--
r 15     bool
--[ 2022.11.03.14.33.04.389.0 ]--
r 15     boole
--[ 2022.11.03.14.33.04.512.0 ]--
r 15     boolen
--[ 2022.11.03.14.33.04.570.0 ]--
r 15     boolena
--[ 2022.11.03.14.33.05.251.0 ]--
r 15     boolen
--[ 2022.11.03.14.33.05.369.0 ]--
r 15     boole
--[ 2022.11.03.14.33.05.423.0 ]--
r 15     boolea
--[ 2022.11.03.14.33.05.491.0 ]--
r 15     boolean
--[ 2022.11.03.14.33.06.394.0 ]--
r 15     boolean 
--[ 2022.11.03.14.33.07.540.0 ]--
r 15     boolean f
--[ 2022.11.03.14.33.07.609.0 ]--
r 15     boolean fo
--[ 2022.11.03.14.33.07.669.0 ]--
r 15     boolean fou
--[ 2022.11.03.14.33.07.879.0 ]--
r 15     boolean foun
--[ 2022.11.03.14.33.07.952.0 ]--
r 15     boolean found
--[ 2022.11.03.14.33.08.064.0 ]--
r 15     boolean found 
--[ 2022.11.03.14.33.08.199.0 ]--
r 15     boolean found =
--[ 2022.11.03.14.33.08.312.0 ]--
r 15     boolean found = 
--[ 2022.11.03.14.33.08.733.0 ]--
r 15     boolean found = f
--[ 2022.11.03.14.33.08.848.0 ]--
r 15     boolean found = fa
--[ 2022.11.03.14.33.08.906.0 ]--
r 15     boolean found = fal
--[ 2022.11.03.14.33.09.121.0 ]--
r 15     boolean found = fale
--[ 2022.11.03.14.33.09.407.0 ]--
r 15     boolean found = fal
--[ 2022.11.03.14.33.09.767.0 ]--
r 15     boolean found = fals
--[ 2022.11.03.14.33.09.850.0 ]--
r 15     boolean found = false
--[ 2022.11.03.14.33.10.146.0 ]--
r 15     boolean found = false;
--[ 2022.11.03.14.38.39.046.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.03.14.39.19.411.0 ]--
+ 123         
--[ 2022.11.03.14.39.33.768.0 ]--
- 123
--[ 2022.11.03.14.40.04.191.0 ]--
+ 123         
--[ 2022.11.03.14.40.05.621.0 ]--
r 123         P
--[ 2022.11.03.14.40.05.857.0 ]--
r 123         PF
--[ 2022.11.03.14.40.06.501.0 ]--
r 123         PFNode
--[ 2022.11.03.14.40.07.166.0 ]--
r 123         PFNode 
--[ 2022.11.03.14.40.08.268.0 ]--
r 123         PFNode b
--[ 2022.11.03.14.40.08.454.0 ]--
r 123         PFNode be
--[ 2022.11.03.14.40.08.544.0 ]--
r 123         PFNode beg
--[ 2022.11.03.14.40.08.746.0 ]--
r 123         PFNode beg 
--[ 2022.11.03.14.40.08.990.0 ]--
r 123         PFNode beg =
--[ 2022.11.03.14.40.09.052.0 ]--
r 123         PFNode beg = 
--[ 2022.11.03.14.40.09.654.0 ]--
r 123         PFNode beg =
--[ 2022.11.03.14.40.09.832.0 ]--
r 123         PFNode beg 
--[ 2022.11.03.14.40.09.982.0 ]--
r 123         PFNode beg
--[ 2022.11.03.14.40.10.133.0 ]--
r 123         PFNode be
--[ 2022.11.03.14.40.10.438.0 ]--
r 123         PFNode b
--[ 2022.11.03.14.40.10.758.0 ]--
r 123         PFNode 
--[ 2022.11.03.14.40.10.887.0 ]--
r 123         PFNode s
--[ 2022.11.03.14.40.10.984.0 ]--
r 123         PFNode s 
--[ 2022.11.03.14.40.11.091.0 ]--
r 123         PFNode s -
--[ 2022.11.03.14.40.11.220.0 ]--
r 123         PFNode s - 
--[ 2022.11.03.14.40.11.726.0 ]--
r 123         PFNode s -
--[ 2022.11.03.14.40.11.905.0 ]--
r 123         PFNode s 
--[ 2022.11.03.14.40.12.113.0 ]--
r 123         PFNode s =
--[ 2022.11.03.14.40.12.236.0 ]--
r 123         PFNode s = 
--[ 2022.11.03.14.40.12.580.0 ]--
r 123         PFNode s = s
--[ 2022.11.03.14.40.12.678.0 ]--
r 123         PFNode s = st
--[ 2022.11.03.14.40.12.811.0 ]--
r 123         PFNode s = sta
--[ 2022.11.03.14.40.12.890.0 ]--
r 123         PFNode s = star
--[ 2022.11.03.14.40.13.076.0 ]--
r 123         PFNode s = start
--[ 2022.11.03.14.40.13.344.0 ]--
r 123         PFNode s = start;
--[ 2022.11.03.14.40.30.601.0 ]--
r 123         
--[ 2022.11.03.14.40.30.752.0 ]--
- 123
--[ 2022.11.03.14.40.37.311.0 ]--
+ 100         
--[ 2022.11.03.14.40.43.345.0 ]--
- 100
--[ 2022.11.03.14.40.50.747.0 ]--
+ 96         
--[ 2022.11.03.14.40.56.790.0 ]--
r 96         P
--[ 2022.11.03.14.40.56.967.0 ]--
r 96         PF
--[ 2022.11.03.14.40.57.434.0 ]--
r 96         PFNode
--[ 2022.11.03.14.40.57.929.0 ]--
r 96         PFNode 
--[ 2022.11.03.14.41.00.308.0 ]--
r 96         PFNode s
--[ 2022.11.03.14.41.00.611.0 ]--
r 96         PFNode s 
--[ 2022.11.03.14.41.00.713.0 ]--
r 96         PFNode s =
--[ 2022.11.03.14.41.00.810.0 ]--
r 96         PFNode s = 
--[ 2022.11.03.14.41.01.504.0 ]--
r 96         PFNode s = n
--[ 2022.11.03.14.41.01.616.0 ]--
r 96         PFNode s = ne
--[ 2022.11.03.14.41.01.657.0 ]--
r 96         PFNode s = new
--[ 2022.11.03.14.41.01.797.0 ]--
r 96         PFNode s = new 
--[ 2022.11.03.14.41.03.257.0 ]--
r 96         PFNode s = new PFNode
--[ 2022.11.03.14.41.03.267.0 ]--
r 96         PFNode s = new PFNode()
--[ 2022.11.03.14.41.13.404.0 ]--
r 96         PFNode s = new PFNode(s)
--[ 2022.11.03.14.41.13.565.0 ]--
r 96         PFNode s = new PFNode(st)
--[ 2022.11.03.14.41.13.696.0 ]--
r 96         PFNode s = new PFNode(sta)
--[ 2022.11.03.14.41.13.814.0 ]--
r 96         PFNode s = new PFNode(star)
--[ 2022.11.03.14.41.14.051.0 ]--
r 96         PFNode s = new PFNode(start)
--[ 2022.11.03.14.41.14.620.0 ]--
r 96         PFNode s = new PFNode(star)
--[ 2022.11.03.14.41.14.777.0 ]--
r 96         PFNode s = new PFNode(sta)
--[ 2022.11.03.14.41.14.939.0 ]--
r 96         PFNode s = new PFNode(st)
--[ 2022.11.03.14.41.15.097.0 ]--
r 96         PFNode s = new PFNode(s)
--[ 2022.11.03.14.41.15.473.0 ]--
r 96         PFNode s = new PFNode()
--[ 2022.11.03.14.41.15.653.0 ]--
r 96         PFNode s = new PFNode(l)
--[ 2022.11.03.14.41.15.882.0 ]--
r 96         PFNode s = new PFNode(lo)
--[ 2022.11.03.14.41.16.251.0 ]--
r 96         PFNode s = new PFNode(l)
--[ 2022.11.03.14.41.16.420.0 ]--
r 96         PFNode s = new PFNode()
--[ 2022.11.03.14.41.17.577.0 ]--
r 96         PFNode s = new PFNode(l)
--[ 2022.11.03.14.41.17.807.0 ]--
r 96         PFNode s = new PFNode(lo)
--[ 2022.11.03.14.41.17.924.0 ]--
r 96         PFNode s = new PFNode(loc)
--[ 2022.11.03.14.41.18.693.0 ]--
r 96         PFNode s = new PFNode(loc,)
--[ 2022.11.03.14.41.18.832.0 ]--
r 96         PFNode s = new PFNode(loc, )
--[ 2022.11.03.14.41.21.918.0 ]--
r 96         PFNode s = new PFNode(loc, n)
--[ 2022.11.03.14.41.22.093.0 ]--
r 96         PFNode s = new PFNode(loc, nu)
--[ 2022.11.03.14.41.22.180.0 ]--
r 96         PFNode s = new PFNode(loc, nul)
--[ 2022.11.03.14.41.22.318.0 ]--
r 96         PFNode s = new PFNode(loc, null)
--[ 2022.11.03.14.41.23.821.0 ]--
r 96         PFNode s = new PFNode(loc, null);
--[ 2022.11.03.14.41.35.068.0 ]--
+ 97         
--[ 2022.11.03.14.41.36.622.0 ]--
r 97         p
--[ 2022.11.03.14.41.36.740.0 ]--
r 97         pq
--[ 2022.11.03.14.41.37.057.0 ]--
r 97         pq.
--[ 2022.11.03.14.41.37.897.0 ]--
r 97         pq.i
--[ 2022.11.03.14.41.38.118.0 ]--
r 97         pq.insert
--[ 2022.11.03.14.41.38.124.0 ]--
r 97         pq.insert()
--[ 2022.11.03.14.41.38.129.0 ]--
r 97         pq.insert();
--[ 2022.11.03.14.41.38.738.0 ]--
r 97         pq.insert(s);
--[ 2022.11.03.14.43.27.179.0 ]--
- 101
r 101     public Coord getPathStart() {return start;
--[ 2022.11.03.14.44.56.987.0 ]--
r 142         return f;
--[ 2022.11.03.14.44.57.088.0 ]--
r 142         return fo;
--[ 2022.11.03.14.44.57.129.0 ]--
r 142         return fou;
--[ 2022.11.03.14.44.57.353.0 ]--
r 142         return foun;
--[ 2022.11.03.14.44.57.416.0 ]--
r 142         return found;
--[ 2022.11.03.14.45.13.982.0 ]--
+ 129             
--[ 2022.11.03.14.45.15.344.0 ]--
r 129             j
--[ 2022.11.03.14.45.16.075.0 ]--
r 129             ji
--[ 2022.11.03.14.45.16.132.0 ]--
r 129             j
--[ 2022.11.03.14.45.16.638.0 ]--
r 129             
--[ 2022.11.03.14.45.16.799.0 ]--
- 129
--[ 2022.11.03.14.45.16.863.0 ]--
r 128             PFNode nextTile = pq.min();i
--[ 2022.11.03.14.45.17.689.0 ]--
r 128             PFNode nextTile = pq.min();
--[ 2022.11.03.14.45.17.923.0 ]--
+ 129             
--[ 2022.11.03.14.45.18.148.0 ]--
r 129             i
--[ 2022.11.03.14.45.18.283.0 ]--
r 129             if
--[ 2022.11.03.14.45.18.855.0 ]--
r 129             if ()
--[ 2022.11.03.14.45.21.443.0 ]--
r 129             if (n)
--[ 2022.11.03.14.45.21.535.0 ]--
r 129             if (ne)
--[ 2022.11.03.14.45.21.677.0 ]--
r 129             if (nextTile.found)
--[ 2022.11.03.14.45.21.682.0 ]--
r 129             if (nextTile;)
--[ 2022.11.03.14.45.21.689.0 ]--
r 129             if (nextTile.found)
--[ 2022.11.03.14.45.22.084.0 ]--
r 129             if (nextTile.found).
--[ 2022.11.03.14.45.23.114.0 ]--
r 129             if (nextTile.found)
--[ 2022.11.03.14.45.23.279.0 ]--
r 129             if (nextTile.found
--[ 2022.11.03.14.45.23.438.0 ]--
r 129             if (nextTile.foun
--[ 2022.11.03.14.45.23.627.0 ]--
r 129             if (nextTile.fou
--[ 2022.11.03.14.45.23.791.0 ]--
r 129             if (nextTile.fo
--[ 2022.11.03.14.45.23.962.0 ]--
r 129             if (nextTile.f
--[ 2022.11.03.14.45.24.121.0 ]--
r 129             if (nextTile.
--[ 2022.11.03.14.45.24.562.0 ]--
r 129             if (nextTile
--[ 2022.11.03.14.45.25.126.0 ]--
r 129             if (nextTile.
--[ 2022.11.03.14.45.27.413.0 ]--
r 129             if (nextTile.currentTile
--[ 2022.11.03.14.45.28.279.0 ]--
r 129             if (nextTile.currentTile.
--[ 2022.11.03.14.45.49.463.0 ]--
r 129             if (nextTile.currentTile
--[ 2022.11.03.14.45.50.412.0 ]--
r 129             if (nextTile.currentTile 
--[ 2022.11.03.14.45.51.116.0 ]--
r 129             if (nextTile.currentTile =
--[ 2022.11.03.14.45.51.307.0 ]--
r 129             if (nextTile.currentTile ==
--[ 2022.11.03.14.45.53.108.0 ]--
r 129             if (nextTile.currentTile == 
--[ 2022.11.03.14.45.53.321.0 ]--
r 129             if (nextTile.currentTile == e
--[ 2022.11.03.14.45.53.429.0 ]--
r 129             if (nextTile.currentTile == en
--[ 2022.11.03.14.45.53.509.0 ]--
r 129             if (nextTile.currentTile == end
--[ 2022.11.03.14.45.53.925.0 ]--
r 129             if (nextTile.currentTile == end)
--[ 2022.11.03.14.45.54.381.0 ]--
r 129             if (nextTile.currentTile == end) 
--[ 2022.11.03.14.45.54.515.0 ]--
r 129             if (nextTile.currentTile == end) {
--[ 2022.11.03.14.45.54.727.0 ]--
+ 130 
+ 131 }
--[ 2022.11.03.14.45.54.741.0 ]--
r 131             }
--[ 2022.11.03.14.45.54.755.0 ]--
r 130                 
--[ 2022.11.03.14.45.56.603.0 ]--
r 130                 f
--[ 2022.11.03.14.45.56.682.0 ]--
r 130                 fo
--[ 2022.11.03.14.45.56.767.0 ]--
r 130                 fou
--[ 2022.11.03.14.45.57.452.0 ]--
r 130                 foun
--[ 2022.11.03.14.45.57.586.0 ]--
r 130                 found
--[ 2022.11.03.14.45.57.742.0 ]--
r 130                 found 
--[ 2022.11.03.14.45.58.257.0 ]--
r 130                 found =
--[ 2022.11.03.14.45.58.423.0 ]--
r 130                 found = 
--[ 2022.11.03.14.45.59.224.0 ]--
r 130                 found = t
--[ 2022.11.03.14.45.59.380.0 ]--
r 130                 found = tr
--[ 2022.11.03.14.45.59.418.0 ]--
r 130                 found = tru
--[ 2022.11.03.14.45.59.578.0 ]--
r 130                 found = true
--[ 2022.11.03.14.46.00.057.0 ]--
r 130                 found = true;
--[ 2022.11.03.14.46.10.719.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.03.14.46.55.942.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] ) {
--[ 2022.11.03.14.46.57.303.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] &) {
--[ 2022.11.03.14.46.57.410.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] &&) {
--[ 2022.11.03.14.46.57.593.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && ) {
--[ 2022.11.03.14.46.58.715.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && n) {
--[ 2022.11.03.14.46.58.773.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && ne) {
--[ 2022.11.03.14.46.59.185.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.found) {
--[ 2022.11.03.14.46.59.190.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile;) {
--[ 2022.11.03.14.46.59.197.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.found) {
--[ 2022.11.03.14.46.59.674.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.found.) {
--[ 2022.11.03.14.47.00.161.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.found) {
--[ 2022.11.03.14.47.00.336.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.foun) {
--[ 2022.11.03.14.47.00.501.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.fou) {
--[ 2022.11.03.14.47.00.673.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.fo) {
--[ 2022.11.03.14.47.00.845.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.f) {
--[ 2022.11.03.14.47.01.021.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.) {
--[ 2022.11.03.14.47.01.286.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.c) {
--[ 2022.11.03.14.47.01.366.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.cu) {
--[ 2022.11.03.14.47.01.480.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.cur) {
--[ 2022.11.03.14.47.02.899.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.currentTile) {
--[ 2022.11.03.14.47.07.067.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.currentTil) {
--[ 2022.11.03.14.47.07.554.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.currentTi) {
--[ 2022.11.03.14.47.07.638.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.currentT) {
--[ 2022.11.03.14.47.07.722.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.current) {
--[ 2022.11.03.14.47.07.807.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.curren) {
--[ 2022.11.03.14.47.07.888.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.curre) {
--[ 2022.11.03.14.47.07.973.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.curr) {
--[ 2022.11.03.14.47.08.055.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.cur) {
--[ 2022.11.03.14.47.08.140.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.cu) {
--[ 2022.11.03.14.47.08.223.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.c) {
--[ 2022.11.03.14.47.08.537.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile.) {
--[ 2022.11.03.14.47.09.331.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTile) {
--[ 2022.11.03.14.47.09.499.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTil) {
--[ 2022.11.03.14.47.09.658.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextTi) {
--[ 2022.11.03.14.47.09.820.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nextT) {
--[ 2022.11.03.14.47.09.990.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && next) {
--[ 2022.11.03.14.47.10.107.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && nex) {
--[ 2022.11.03.14.47.10.307.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && ne) {
--[ 2022.11.03.14.47.10.454.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && n) {
--[ 2022.11.03.14.47.10.607.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && ) {
--[ 2022.11.03.14.47.35.262.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] &&) {
--[ 2022.11.03.14.47.35.498.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] &) {
--[ 2022.11.03.14.47.35.806.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] ) {
--[ 2022.11.03.14.47.36.451.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.03.14.47.40.837.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] ) {
--[ 2022.11.03.14.47.42.328.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] &) {
--[ 2022.11.03.14.47.42.508.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] &&) {
--[ 2022.11.03.14.47.43.187.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] && ) {
--[ 2022.11.03.14.48.29.002.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] &&) {
--[ 2022.11.03.14.48.29.174.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] &) {
--[ 2022.11.03.14.48.29.336.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] ) {
--[ 2022.11.03.14.48.29.881.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.03.14.48.35.164.0 ]--
+ 134                 
--[ 2022.11.03.14.48.36.147.0 ]--
r 134                 i
--[ 2022.11.03.14.48.36.258.0 ]--
r 134                 if
--[ 2022.11.03.14.48.36.950.0 ]--
r 134                 if ()
--[ 2022.11.03.14.48.49.675.0 ]--
r 134                 if (new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile))
--[ 2022.11.03.14.48.52.941.0 ]--
r 134                 if (new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile).)
--[ 2022.11.03.14.48.53.341.0 ]--
r 134                 if (new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile).i)
--[ 2022.11.03.14.48.53.420.0 ]--
r 134                 if (new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile).is)
--[ 2022.11.03.14.48.55.051.0 ]--
r 134                 if (new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile).isValid)
--[ 2022.11.03.14.48.55.058.0 ]--
r 134                 if (new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile).isValid())
--[ 2022.11.03.14.49.02.930.0 ]--
r 135                     PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
r 136                     array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = true;
r 137                     pq.insert(left);
--[ 2022.11.03.14.49.11.652.0 ]--
r 135                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
r 136                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = true;
r 137                 pq.insert(left);
--[ 2022.11.03.14.49.12.005.0 ]--
r 134                 if (new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile).is)
--[ 2022.11.03.14.49.12.359.0 ]--
r 134                 if (new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile))
--[ 2022.11.03.14.49.12.715.0 ]--
r 134                 if ()
--[ 2022.11.03.14.49.13.024.0 ]--
r 134                 if
--[ 2022.11.03.14.49.13.359.0 ]--
r 134                 
--[ 2022.11.03.14.49.13.701.0 ]--
- 134
--[ 2022.11.04.08.05.21.352.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.04.08.33.32.901.0 ]--
+ 139             
--[ 2022.11.04.08.33.33.974.0 ]--
+ 139             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
+ 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
+ 141                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = true;
r 142                 pq.insert(left);
--[ 2022.11.04.08.33.38.234.0 ]--
r 139             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()1]) {
--[ 2022.11.04.08.33.38.388.0 ]--
r 139             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.04.08.33.52.895.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+]) {
--[ 2022.11.04.08.33.53.102.0 ]--
r 133             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]) {
--[ 2022.11.04.08.33.55.809.0 ]--
r 133             if (!array[nextTile.currentTile.getI()+][nextTile.currentTile.getJ()]) {
--[ 2022.11.04.08.33.56.367.0 ]--
r 133             if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.04.08.33.59.045.0 ]--
r 134                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+), nextTile);
--[ 2022.11.04.08.33.59.191.0 ]--
r 134                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.34.01.850.0 ]--
r 134                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI()+, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.34.02.415.0 ]--
r 134                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI()+1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.34.06.943.0 ]--
r 135                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+] = true;
--[ 2022.11.04.08.34.07.101.0 ]--
r 135                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.34.10.098.0 ]--
r 135                 array[nextTile.currentTile.getI()+][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.34.10.627.0 ]--
r 135                 array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.34.16.830.0 ]--
r 139             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-]) {
--[ 2022.11.04.08.34.16.983.0 ]--
r 139             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]) {
--[ 2022.11.04.08.34.19.546.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-][nextTile.currentTile.getJ()]) {
--[ 2022.11.04.08.34.20.049.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.04.08.34.23.307.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+), nextTile);
--[ 2022.11.04.08.34.23.457.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.34.25.909.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI()-, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.34.26.434.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.34.28.846.0 ]--
r 141                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+] = true;
--[ 2022.11.04.08.34.28.959.0 ]--
r 141                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.34.31.326.0 ]--
r 141                 array[nextTile.currentTile.getI()-][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.34.31.786.0 ]--
r 141                 array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.34.34.417.0 ]--
r 140                 PFNode r = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.34.34.473.0 ]--
r 140                 PFNode ri = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.34.34.623.0 ]--
r 140                 PFNode rig = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.34.34.731.0 ]--
r 140                 PFNode righ = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.34.34.784.0 ]--
r 140                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.34.37.447.0 ]--
r 142                 pq.insert(r);
--[ 2022.11.04.08.34.37.536.0 ]--
r 142                 pq.insert(ri);
--[ 2022.11.04.08.34.37.654.0 ]--
r 142                 pq.insert(rig);
--[ 2022.11.04.08.34.37.766.0 ]--
r 142                 pq.insert(righ);
--[ 2022.11.04.08.34.37.833.0 ]--
r 142                 pq.insert(right);
--[ 2022.11.04.08.35.38.326.0 ]--
+ 143                 
--[ 2022.11.04.08.35.40.459.0 ]--
r 143                 }
--[ 2022.11.04.08.35.40.493.0 ]--
r 140                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() -1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.35.40.497.0 ]--
r 140                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() - 1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.35.40.500.0 ]--
r 141                 array[nextTile.currentTile.getI() -1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.35.40.503.0 ]--
r 141                 array[nextTile.currentTile.getI() - 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.35.40.505.0 ]--
r 143             }
--[ 2022.11.04.08.37.50.630.0 ]--
+ 145             
--[ 2022.11.04.08.37.51.392.0 ]--
+ 145             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
+ 146                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() - 1, nextTile.currentTile.getJ()), nextTile);
+ 147                 array[nextTile.currentTile.getI() - 1][nextTile.currentTile.getJ()] = true;
+ 148                 pq.insert(right);
r 149             }
--[ 2022.11.04.08.39.15.155.0 ]--
r 145             if (!array[nextTile.currentTile.getI()-][nextTile.currentTile.getJ()]) {
--[ 2022.11.04.08.39.15.265.0 ]--
r 145             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]) {
--[ 2022.11.04.08.39.17.620.0 ]--
r 145             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]+) {
--[ 2022.11.04.08.39.17.930.0 ]--
r 145             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]+1) {
--[ 2022.11.04.08.39.20.474.0 ]--
r 145             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]+) {
--[ 2022.11.04.08.39.20.591.0 ]--
r 145             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]) {
--[ 2022.11.04.08.39.21.851.0 ]--
r 145             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+]) {
--[ 2022.11.04.08.39.22.068.0 ]--
r 145             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.04.08.39.25.290.0 ]--
r 146                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() - , nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.39.25.436.0 ]--
r 146                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() -, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.39.25.627.0 ]--
r 146                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() , nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.39.26.087.0 ]--
r 146                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.39.28.877.0 ]--
r 146                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+), nextTile);
--[ 2022.11.04.08.39.29.107.0 ]--
r 146                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.04.08.39.32.402.0 ]--
r 147                 array[nextTile.currentTile.getI() - 1][nextTile.currentTile.getJ()+] = true;
--[ 2022.11.04.08.39.32.584.0 ]--
r 147                 array[nextTile.currentTile.getI() - 1][nextTile.currentTile.getJ()+1] = true;
--[ 2022.11.04.08.39.35.363.0 ]--
r 147                 array[nextTile.currentTile.getI() - ][nextTile.currentTile.getJ()+1] = true;
--[ 2022.11.04.08.39.35.505.0 ]--
r 147                 array[nextTile.currentTile.getI() -][nextTile.currentTile.getJ()+1] = true;
--[ 2022.11.04.08.39.35.701.0 ]--
r 147                 array[nextTile.currentTile.getI() ][nextTile.currentTile.getJ()+1] = true;
--[ 2022.11.04.08.39.35.870.0 ]--
r 147                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = true;
--[ 2022.11.04.08.39.43.982.0 ]--
r 146                 PFNode a = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.04.08.39.44.150.0 ]--
r 146                 PFNode ab = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.04.08.39.44.233.0 ]--
r 146                 PFNode abo = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.04.08.39.44.464.0 ]--
r 146                 PFNode abov = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.04.08.39.44.917.0 ]--
r 146                 PFNode above = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.04.08.39.46.363.0 ]--
r 148                 pq.insert(a);
--[ 2022.11.04.08.39.46.570.0 ]--
r 148                 pq.insert(ab);
--[ 2022.11.04.08.39.46.694.0 ]--
r 148                 pq.insert(abo);
--[ 2022.11.04.08.39.46.896.0 ]--
r 148                 pq.insert(abov);
--[ 2022.11.04.08.39.46.937.0 ]--
r 148                 pq.insert(above);
--[ 2022.11.04.08.39.53.749.0 ]--
+ 151             
--[ 2022.11.04.08.39.54.095.0 ]--
+ 151             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
+ 152                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() - 1, nextTile.currentTile.getJ()), nextTile);
+ 153                 array[nextTile.currentTile.getI() - 1][nextTile.currentTile.getJ()] = true;
+ 154                 pq.insert(right);
r 155             }
--[ 2022.11.04.08.39.57.812.0 ]--
r 151             if (!array[nextTile.currentTile.getI()-][nextTile.currentTile.getJ()]) {
--[ 2022.11.04.08.39.57.968.0 ]--
r 151             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]) {
--[ 2022.11.04.08.40.01.234.0 ]--
r 151             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-]) {
--[ 2022.11.04.08.40.01.290.0 ]--
r 151             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.04.08.40.04.422.0 ]--
r 152                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() - , nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.40.04.594.0 ]--
r 152                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() -, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.40.04.768.0 ]--
r 152                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() , nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.40.04.943.0 ]--
r 152                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.04.08.40.07.789.0 ]--
r 152                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-), nextTile);
--[ 2022.11.04.08.40.07.876.0 ]--
r 152                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.40.11.604.0 ]--
r 153                 array[nextTile.currentTile.getI() - ][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.40.11.735.0 ]--
r 153                 array[nextTile.currentTile.getI() -][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.40.11.912.0 ]--
r 153                 array[nextTile.currentTile.getI() ][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.40.12.079.0 ]--
r 153                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()] = true;
--[ 2022.11.04.08.40.14.344.0 ]--
r 153                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-] = true;
--[ 2022.11.04.08.40.14.438.0 ]--
r 153                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1] = true;
--[ 2022.11.04.08.43.00.567.0 ]--
r 152                 PFNode b = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.00.703.0 ]--
r 152                 PFNode bw = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.00.807.0 ]--
r 152                 PFNode bwl = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.00.880.0 ]--
r 152                 PFNode bwll = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.01.013.0 ]--
r 152                 PFNode bwllo = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.01.098.0 ]--
r 152                 PFNode bwllow = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.01.427.0 ]--
r 152                 PFNode bwllo = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.01.581.0 ]--
r 152                 PFNode bwll = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.01.753.0 ]--
r 152                 PFNode bwl = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.01.931.0 ]--
r 152                 PFNode bw = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.04.530.0 ]--
r 152                 PFNode b = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.04.626.0 ]--
r 152                 PFNode be = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.04.736.0 ]--
r 152                 PFNode bel = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.04.946.0 ]--
r 152                 PFNode belo = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.05.023.0 ]--
r 152                 PFNode below = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.04.08.43.07.011.0 ]--
r 154                 pq.insert(b);
--[ 2022.11.04.08.43.07.182.0 ]--
r 154                 pq.insert(bw);
--[ 2022.11.04.08.43.07.263.0 ]--
r 154                 pq.insert(bwl);
--[ 2022.11.04.08.43.07.437.0 ]--
r 154                 pq.insert(bwlo);
--[ 2022.11.04.08.43.07.518.0 ]--
r 154                 pq.insert(bwloe);
--[ 2022.11.04.08.43.07.899.0 ]--
r 154                 pq.insert(bwlo);
--[ 2022.11.04.08.43.08.073.0 ]--
r 154                 pq.insert(bwl);
--[ 2022.11.04.08.43.08.252.0 ]--
r 154                 pq.insert(bw);
--[ 2022.11.04.08.43.08.408.0 ]--
r 154                 pq.insert(b);
--[ 2022.11.04.08.43.08.501.0 ]--
r 154                 pq.insert(be);
--[ 2022.11.04.08.43.08.636.0 ]--
r 154                 pq.insert(bel);
--[ 2022.11.04.08.43.08.820.0 ]--
r 154                 pq.insert(belo);
--[ 2022.11.04.08.43.08.929.0 ]--
r 154                 pq.insert(below);
--[ 2022.11.04.12.28.08.714.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.04.12.29.02.372.0 ]--
+ 56             
--[ 2022.11.04.12.29.04.462.0 ]--
r 56             s
--[ 2022.11.04.12.29.04.557.0 ]--
r 56             so
--[ 2022.11.04.12.29.04.626.0 ]--
r 56             sou
--[ 2022.11.04.12.29.04.702.0 ]--
r 56             sout
--[ 2022.11.04.12.29.04.838.0 ]--
r 56             System.out.println();
--[ 2022.11.04.12.29.05.375.0 ]--
r 56             System.out.println("");
--[ 2022.11.04.12.29.06.545.0 ]--
r 56             System.out.println("t");
--[ 2022.11.04.12.29.06.599.0 ]--
r 56             System.out.println("th");
--[ 2022.11.04.12.29.06.687.0 ]--
r 56             System.out.println("thi");
--[ 2022.11.04.12.29.06.754.0 ]--
r 56             System.out.println("this");
--[ 2022.11.04.12.29.06.967.0 ]--
r 56             System.out.println("this.");
--[ 2022.11.04.12.29.07.380.0 ]--
r 56             System.out.println("this");
--[ 2022.11.04.12.29.07.545.0 ]--
r 56             System.out.println("thi");
--[ 2022.11.04.12.29.07.702.0 ]--
r 56             System.out.println("th");
--[ 2022.11.04.12.29.07.873.0 ]--
r 56             System.out.println("t");
--[ 2022.11.04.12.29.08.423.0 ]--
r 56             System.out.println("");
--[ 2022.11.04.12.29.08.698.0 ]--
r 56             System.out.println("C");
--[ 2022.11.04.12.29.08.791.0 ]--
r 56             System.out.println("Co");
--[ 2022.11.04.12.29.08.908.0 ]--
r 56             System.out.println("Cos");
--[ 2022.11.04.12.29.09.050.0 ]--
r 56             System.out.println("Cost");
--[ 2022.11.04.12.29.10.212.0 ]--
r 56             System.out.println("Cost);
--[ 2022.11.04.12.29.11.282.0 ]--
r 56             System.out.println("Cost );
--[ 2022.11.04.12.29.11.462.0 ]--
r 56             System.out.println("Cost ");
--[ 2022.11.04.12.29.11.589.0 ]--
r 56             System.out.println("Cost " );
--[ 2022.11.04.12.29.11.893.0 ]--
r 56             System.out.println("Cost " +);
--[ 2022.11.04.12.29.11.986.0 ]--
r 56             System.out.println("Cost " + );
--[ 2022.11.04.12.29.13.234.0 ]--
r 56             System.out.println("Cost " + t);
--[ 2022.11.04.12.29.13.345.0 ]--
r 56             System.out.println("Cost " + th);
--[ 2022.11.04.12.29.13.398.0 ]--
r 56             System.out.println("Cost " + thi);
--[ 2022.11.04.12.29.13.437.0 ]--
r 56             System.out.println("Cost " + this);
--[ 2022.11.04.12.29.13.625.0 ]--
r 56             System.out.println("Cost " + this.);
--[ 2022.11.04.12.29.13.839.0 ]--
r 56             System.out.println("Cost " + this.c);
--[ 2022.11.04.12.29.13.902.0 ]--
r 56             System.out.println("Cost " + this.co);
--[ 2022.11.04.12.29.14.000.0 ]--
r 56             System.out.println("Cost " + this.cos);
--[ 2022.11.04.12.29.14.119.0 ]--
r 56             System.out.println("Cost " + this.cost);
--[ 2022.11.04.12.29.20.088.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.15.26.911.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.15.50.363.0 ]--
+ 53             
--[ 2022.11.06.14.15.51.345.0 ]--
r 53             i
--[ 2022.11.06.14.15.51.479.0 ]--
r 53             if
--[ 2022.11.06.14.15.52.185.0 ]--
r 53             if()
--[ 2022.11.06.14.15.52.706.0 ]--
r 53             if(p)
--[ 2022.11.06.14.15.52.840.0 ]--
r 53             if(pr)
--[ 2022.11.06.14.15.52.890.0 ]--
r 53             if(pre)
--[ 2022.11.06.14.15.53.088.0 ]--
r 53             if(prev)
--[ 2022.11.06.14.15.54.401.0 ]--
r 53             if(prevN)
--[ 2022.11.06.14.15.54.506.0 ]--
r 53             if(prevNo)
--[ 2022.11.06.14.15.54.736.0 ]--
r 53             if(prevNode.isUsed)
--[ 2022.11.06.14.15.54.743.0 ]--
r 53             if(prevNode;)
--[ 2022.11.06.14.15.54.751.0 ]--
r 53             if(prevNode.isUsed)
--[ 2022.11.06.14.15.54.758.0 ]--
r 53             if(prevNode.isUsed())
--[ 2022.11.06.14.15.55.504.0 ]--
r 53             if(prevNode.isUsed()
--[ 2022.11.06.14.15.56.004.0 ]--
r 53             if(prevNode.isUsed(
--[ 2022.11.06.14.15.56.088.0 ]--
r 53             if(prevNode.isUsed
--[ 2022.11.06.14.15.56.170.0 ]--
r 53             if(prevNode.isUse
--[ 2022.11.06.14.15.56.256.0 ]--
r 53             if(prevNode.isUs
--[ 2022.11.06.14.15.56.338.0 ]--
r 53             if(prevNode.isU
--[ 2022.11.06.14.15.56.421.0 ]--
r 53             if(prevNode.is
--[ 2022.11.06.14.15.56.506.0 ]--
r 53             if(prevNode.i
--[ 2022.11.06.14.15.56.591.0 ]--
r 53             if(prevNode.
--[ 2022.11.06.14.15.56.670.0 ]--
r 53             if(prevNode
--[ 2022.11.06.14.15.56.920.0 ]--
r 53             if(prevNod
--[ 2022.11.06.14.15.57.635.0 ]--
r 53             if(prevNode
--[ 2022.11.06.14.15.57.753.0 ]--
r 53             if(prevNode 
--[ 2022.11.06.14.15.58.236.0 ]--
r 53             if(prevNode !
--[ 2022.11.06.14.15.58.512.0 ]--
r 53             if(prevNode !-
--[ 2022.11.06.14.15.58.670.0 ]--
r 53             if(prevNode !- 
--[ 2022.11.06.14.15.59.197.0 ]--
r 53             if(prevNode !-
--[ 2022.11.06.14.15.59.326.0 ]--
r 53             if(prevNode !
--[ 2022.11.06.14.15.59.581.0 ]--
r 53             if(prevNode !-
--[ 2022.11.06.14.16.00.006.0 ]--
r 53             if(prevNode !
--[ 2022.11.06.14.16.00.227.0 ]--
r 53             if(prevNode !=
--[ 2022.11.06.14.16.00.542.0 ]--
r 53             if(prevNode != 
--[ 2022.11.06.14.16.00.654.0 ]--
r 53             if(prevNode != n
--[ 2022.11.06.14.16.00.862.0 ]--
r 53             if(prevNode != nu
--[ 2022.11.06.14.16.00.973.0 ]--
r 53             if(prevNode != nul
--[ 2022.11.06.14.16.01.114.0 ]--
r 53             if(prevNode != null
--[ 2022.11.06.14.16.02.664.0 ]--
r 53             if(prevNode != null)
--[ 2022.11.06.14.16.02.884.0 ]--
r 53             if(prevNode != null) 
--[ 2022.11.06.14.16.03.172.0 ]--
r 53             if(prevNode != null) P
--[ 2022.11.06.14.16.04.037.0 ]--
r 53             if(prevNode != null) 
--[ 2022.11.06.14.16.04.244.0 ]--
r 53             if(prevNode != null) {
--[ 2022.11.06.14.16.09.659.0 ]--
+ 59             
--[ 2022.11.06.14.16.09.871.0 ]--
r 59             }
--[ 2022.11.06.14.16.09.879.0 ]--
r 54                 this.cost = prevNode.getCost(0)
--[ 2022.11.06.14.16.09.881.0 ]--
r 55                         + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
--[ 2022.11.06.14.16.09.883.0 ]--
r 56                         + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
--[ 2022.11.06.14.16.09.885.0 ]--
r 57                 System.out.println("Cost " + this.cost);
--[ 2022.11.06.14.16.09.887.0 ]--
r 58                 return this.cost;
--[ 2022.11.06.14.16.11.185.0 ]--
+ 60             
--[ 2022.11.06.14.16.12.159.0 ]--
r 60             r
--[ 2022.11.06.14.16.12.243.0 ]--
r 60             re
--[ 2022.11.06.14.16.12.410.0 ]--
r 60             ret
--[ 2022.11.06.14.16.12.477.0 ]--
r 60             retu
--[ 2022.11.06.14.16.12.599.0 ]--
r 60             retur
--[ 2022.11.06.14.16.12.723.0 ]--
r 60             return
--[ 2022.11.06.14.16.12.896.0 ]--
r 60             return 
--[ 2022.11.06.14.16.13.646.0 ]--
r 60             return 0
--[ 2022.11.06.14.16.13.840.0 ]--
r 60             return 0.
--[ 2022.11.06.14.16.13.982.0 ]--
r 60             return 0.0
--[ 2022.11.06.14.16.15.038.0 ]--
r 60             return 0.0l
--[ 2022.11.06.14.16.15.829.0 ]--
r 60             return 0.0
--[ 2022.11.06.14.16.16.050.0 ]--
r 60             return 0.0;
--[ 2022.11.06.14.16.17.674.0 ]--
r 60             return 0.0
--[ 2022.11.06.14.16.17.809.0 ]--
r 60             return 0.
--[ 2022.11.06.14.16.18.251.0 ]--
r 60             return 0
--[ 2022.11.06.14.16.18.937.0 ]--
r 60             return 0;
--[ 2022.11.06.14.16.22.717.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.17.11.787.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.19.25.775.0 ]--
r 53             if(prevNode = null) {
--[ 2022.11.06.14.19.26.392.0 ]--
r 53             if(prevNode == null) {
--[ 2022.11.06.14.19.28.413.0 ]--
r 59             
--[ 2022.11.06.14.19.28.638.0 ]--
- 59
--[ 2022.11.06.14.19.30.947.0 ]--
r 59           
--[ 2022.11.06.14.19.31.329.0 ]--
- 59
--[ 2022.11.06.14.19.34.393.0 ]--
+ 54 
+ 55 }
--[ 2022.11.06.14.19.34.399.0 ]--
r 55             }
--[ 2022.11.06.14.19.34.410.0 ]--
r 54                 
--[ 2022.11.06.14.19.34.810.0 ]--
r 54                 }
--[ 2022.11.06.14.19.34.820.0 ]--
r 54             }
--[ 2022.11.06.14.19.37.864.0 ]--
r 55             
--[ 2022.11.06.14.19.38.283.0 ]--
- 55
--[ 2022.11.06.14.19.40.128.0 ]--
+ 54                 
--[ 2022.11.06.14.19.41.531.0 ]--
r 54                 r
--[ 2022.11.06.14.19.41.640.0 ]--
r 54                 re
--[ 2022.11.06.14.19.41.788.0 ]--
r 54                 ret
--[ 2022.11.06.14.19.41.856.0 ]--
r 54                 retu
--[ 2022.11.06.14.19.42.001.0 ]--
r 54                 retur
--[ 2022.11.06.14.19.42.095.0 ]--
r 54                 return
--[ 2022.11.06.14.19.42.226.0 ]--
r 54                 return 
--[ 2022.11.06.14.19.43.296.0 ]--
r 54                 return 0
--[ 2022.11.06.14.19.43.928.0 ]--
r 54                 return 0;
--[ 2022.11.06.14.19.47.420.0 ]--
r 56             this.cost = prevNode.getCost(0)
r 57                     + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
r 58                     + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
r 59             System.out.println("Cost " + this.cost);
r 60             return this.cost;
--[ 2022.11.06.14.19.53.816.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.20.37.476.0 ]--
+ 60             
--[ 2022.11.06.14.20.38.123.0 ]--
r 60             s
--[ 2022.11.06.14.20.38.230.0 ]--
r 60             so
--[ 2022.11.06.14.20.38.329.0 ]--
r 60             sou
--[ 2022.11.06.14.20.38.422.0 ]--
r 60             sout
--[ 2022.11.06.14.20.38.495.0 ]--
r 60             System.out.println();
--[ 2022.11.06.14.20.39.481.0 ]--
r 60             System.out.println("");
--[ 2022.11.06.14.20.40.107.0 ]--
r 60             System.out.println("P");
--[ 2022.11.06.14.20.40.371.0 ]--
r 60             System.out.println("Pe");
--[ 2022.11.06.14.20.40.437.0 ]--
r 60             System.out.println("Per");
--[ 2022.11.06.14.20.40.638.0 ]--
r 60             System.out.println("Pere");
--[ 2022.11.06.14.20.40.831.0 ]--
r 60             System.out.println("Perev");
--[ 2022.11.06.14.20.41.078.0 ]--
r 60             System.out.println("Pere");
--[ 2022.11.06.14.20.41.245.0 ]--
r 60             System.out.println("Per");
--[ 2022.11.06.14.20.41.412.0 ]--
r 60             System.out.println("Pe");
--[ 2022.11.06.14.20.41.559.0 ]--
r 60             System.out.println("P");
--[ 2022.11.06.14.20.41.591.0 ]--
r 60             System.out.println("Pr");
--[ 2022.11.06.14.20.41.711.0 ]--
r 60             System.out.println("Pre");
--[ 2022.11.06.14.20.41.904.0 ]--
r 60             System.out.println("Prev");
--[ 2022.11.06.14.20.42.246.0 ]--
r 60             System.out.println("PrevN");
--[ 2022.11.06.14.20.42.336.0 ]--
r 60             System.out.println("PrevNo");
--[ 2022.11.06.14.20.42.408.0 ]--
r 60             System.out.println("PrevNod");
--[ 2022.11.06.14.20.42.547.0 ]--
r 60             System.out.println("PrevNode");
--[ 2022.11.06.14.20.42.953.0 ]--
r 60             System.out.println("PrevNode:");
--[ 2022.11.06.14.20.43.399.0 ]--
r 60             System.out.println("PrevNode");
--[ 2022.11.06.14.20.43.803.0 ]--
r 60             System.out.println("PrevNode:");
--[ 2022.11.06.14.20.43.987.0 ]--
r 60             System.out.println("PrevNode: ");
--[ 2022.11.06.14.20.44.676.0 ]--
r 60             System.out.println("PrevNode: " );
--[ 2022.11.06.14.20.44.862.0 ]--
r 60             System.out.println("PrevNode: " +);
--[ 2022.11.06.14.20.44.952.0 ]--
r 60             System.out.println("PrevNode: " + );
--[ 2022.11.06.14.20.45.812.0 ]--
r 60             System.out.println("PrevNode: " + p);
--[ 2022.11.06.14.20.45.878.0 ]--
r 60             System.out.println("PrevNode: " + pr);
--[ 2022.11.06.14.20.45.921.0 ]--
r 60             System.out.println("PrevNode: " + pre);
--[ 2022.11.06.14.20.46.401.0 ]--
r 60             System.out.println("PrevNode: " + prevNode);
--[ 2022.11.06.14.20.48.165.0 ]--
r 60             System.out.println("PrevNode: " + prevNode.);
--[ 2022.11.06.14.20.52.805.0 ]--
r 60             System.out.println("PrevNode: " + prevNode.c);
--[ 2022.11.06.14.20.53.918.0 ]--
r 60             System.out.println("PrevNode: " + prevNode.);
--[ 2022.11.06.14.20.57.829.0 ]--
r 60             System.out.println("PrevNode: " + prevNode.c);
--[ 2022.11.06.14.20.58.290.0 ]--
r 60             System.out.println("PrevNode: " + prevNode.);
--[ 2022.11.06.14.20.59.839.0 ]--
r 60             System.out.println("PrevNode: " + prevNode.c);
--[ 2022.11.06.14.21.01.055.0 ]--
r 60             System.out.println("PrevNode: " + prevNode.cu);
--[ 2022.11.06.14.21.01.591.0 ]--
r 60             System.out.println("PrevNode: " + prevNode.currentTile);
--[ 2022.11.06.14.21.04.471.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.21.36.267.0 ]--
r 60             System.out.println("PrevNode: " + prevNode.);
--[ 2022.11.06.14.21.36.506.0 ]--
r 60             System.out.println("PrevNode: " + prevNode);
--[ 2022.11.06.14.21.39.156.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.21.47.098.0 ]--
r 60             System.out.println("PrevNode: " + tprevNode);
--[ 2022.11.06.14.21.47.157.0 ]--
r 60             System.out.println("PrevNode: " + thprevNode);
--[ 2022.11.06.14.21.47.239.0 ]--
r 60             System.out.println("PrevNode: " + thiprevNode);
--[ 2022.11.06.14.21.47.319.0 ]--
r 60             System.out.println("PrevNode: " + thisprevNode);
--[ 2022.11.06.14.21.47.494.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode);
--[ 2022.11.06.14.22.15.774.0 ]--
r 56             this.cost = tprevNode.getCost(0)
--[ 2022.11.06.14.22.15.842.0 ]--
r 56             this.cost = thprevNode.getCost(0)
--[ 2022.11.06.14.22.15.908.0 ]--
r 56             this.cost = thiprevNode.getCost(0)
--[ 2022.11.06.14.22.15.999.0 ]--
r 56             this.cost = thisprevNode.getCost(0)
--[ 2022.11.06.14.22.16.155.0 ]--
r 56             this.cost = this.prevNode.getCost(0)
--[ 2022.11.06.14.22.19.623.0 ]--
r 53             if(tprevNode == null) {
--[ 2022.11.06.14.22.19.724.0 ]--
r 53             if(thprevNode == null) {
--[ 2022.11.06.14.22.19.775.0 ]--
r 53             if(thiprevNode == null) {
--[ 2022.11.06.14.22.19.864.0 ]--
r 53             if(thisprevNode == null) {
--[ 2022.11.06.14.22.20.024.0 ]--
r 53             if(this.prevNode == null) {
--[ 2022.11.06.14.22.24.687.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.22.33.041.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.22.36.949.0 ]--
DisposeComponent
--[ 2022.11.06.14.22.38.670.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.06.14.22.38.672.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2022.11.06.14.22.38.672.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.06.14.22.38.673.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq = new MinPQ<>();
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        boolean searched, found;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.getCost(heuristic) > that.getCost(heuristic)) {
                return 1;
            }
            else if (this.getCost(heuristic) < that.getCost(heuristic)) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if(this.prevNode == null) {
                return 0;
            }
            this.cost = this.prevNode.getCost(0)
                    + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                    + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
            System.out.println("Cost " + this.cost);
            System.out.println("PrevNode: " + this.prevNode);
            return this.cost;
        }

        // returns if this PFNode is still valid
        public boolean isValid() {
            if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(), t.getN()) )) {
                return true;
            }
            return false;
        }

        // invalidates the PFNode
        public void invalidate() {
        }

        // returns if the PFNode has been used
        public boolean isUsed() {
            return true;
        }

        // uses the PFNode
        public void use() {
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        int n = t.getN();
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[n][n];
    }

    public void setPathStart(Coord loc) {
        PFNode s = new PFNode(loc, null);
        pq.insert(s);
        start = loc;
    }

    public Coord getPathStart() {return start;
    }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
    }

    public void computePath() {
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.min();
            if (nextTile.currentTile == end) {
                found = true;
            }
            // left of current tile
            if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI()+1, nextTile.currentTile.getJ()), nextTile);
                array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()] = true;
                pq.insert(left);
            }
            // right of current tile
            if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() - 1, nextTile.currentTile.getJ()), nextTile);
                array[nextTile.currentTile.getI() - 1][nextTile.currentTile.getJ()] = true;
                pq.insert(right);
            }
            // above current tile
            if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
                PFNode above = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = true;
                pq.insert(above);
            }
            // below current tile
            if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1] = true;
                pq.insert(below);
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.11.06.14.22.38.673.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.06.14.22.38.673.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[2];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.06.14.22.38.673.3 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.06.14.22.38.673.4 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.06.14.22.38.673.5 ]--
InitFile: /.cos265


--[ 2022.11.06.14.22.38.673.6 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.06.14.22.38.674.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2022.11.06.14.22.47.922.0 ]--
:/src/Pathfinder.java
r 60             System.out.println("PrevNode: " + this.prevNode.);
--[ 2022.11.06.14.22.58.227.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode.isValid);
--[ 2022.11.06.14.22.58.232.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode.isValid());
--[ 2022.11.06.14.23.02.584.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.23.10.750.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode.isValid();
--[ 2022.11.06.14.23.10.890.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode.isValid);
--[ 2022.11.06.14.23.11.042.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode.isVali);
--[ 2022.11.06.14.23.11.211.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode.isVal);
--[ 2022.11.06.14.23.11.374.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode.isVa);
--[ 2022.11.06.14.23.11.530.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode.isV);
--[ 2022.11.06.14.23.11.695.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode.is);
--[ 2022.11.06.14.23.11.852.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode.i);
--[ 2022.11.06.14.23.12.028.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode.);
--[ 2022.11.06.14.23.12.221.0 ]--
r 60             System.out.println("PrevNode: " + this.prevNode);
--[ 2022.11.06.14.24.11.749.0 ]--
r 54                 return ;
--[ 2022.11.06.14.24.12.751.0 ]--
r 54                 return t;
--[ 2022.11.06.14.24.12.834.0 ]--
r 54                 return th;
--[ 2022.11.06.14.24.12.893.0 ]--
r 54                 return thi;
--[ 2022.11.06.14.24.12.972.0 ]--
r 54                 return this;
--[ 2022.11.06.14.24.13.174.0 ]--
r 54                 return this.;
--[ 2022.11.06.14.24.13.564.0 ]--
r 54                 return this.c;
--[ 2022.11.06.14.24.13.628.0 ]--
r 54                 return this.co;
--[ 2022.11.06.14.24.13.764.0 ]--
r 54                 return this.cos;
--[ 2022.11.06.14.24.13.879.0 ]--
r 54                 return this.cost;
--[ 2022.11.06.14.24.18.418.0 ]--
r 54                 return this.cost ;
--[ 2022.11.06.14.24.18.521.0 ]--
r 54                 return this.cost =;
--[ 2022.11.06.14.24.18.700.0 ]--
r 54                 return this.cost = ;
--[ 2022.11.06.14.24.19.846.0 ]--
r 54                 return this.cost = 0;
--[ 2022.11.06.14.24.25.068.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.26.25.882.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.26.46.374.0 ]--
r 54                 return this.cost = ;
--[ 2022.11.06.14.26.46.553.0 ]--
r 54                 return this.cost =;
--[ 2022.11.06.14.26.46.752.0 ]--
r 54                 return this.cost ;
--[ 2022.11.06.14.26.47.034.0 ]--
r 54                 return this.cost;
--[ 2022.11.06.14.26.47.661.0 ]--
r 54                 return this.cos;
--[ 2022.11.06.14.26.48.164.0 ]--
r 54                 return this.co;
--[ 2022.11.06.14.26.48.243.0 ]--
r 54                 return this.c;
--[ 2022.11.06.14.26.48.328.0 ]--
r 54                 return this.;
--[ 2022.11.06.14.26.48.736.0 ]--
r 54                 return this;
--[ 2022.11.06.14.27.04.712.0 ]--
r 54                 return this.;
--[ 2022.11.06.14.27.04.871.0 ]--
r 54                 return this.c;
--[ 2022.11.06.14.27.04.964.0 ]--
r 54                 return this.co;
--[ 2022.11.06.14.27.05.056.0 ]--
r 54                 return this.cos;
--[ 2022.11.06.14.27.05.204.0 ]--
r 54                 return this.cost;
--[ 2022.11.06.14.27.08.062.0 ]--
+ 53             
--[ 2022.11.06.14.27.09.177.0 ]--
r 53             s
--[ 2022.11.06.14.27.09.284.0 ]--
r 53             so
--[ 2022.11.06.14.27.09.388.0 ]--
r 53             sou
--[ 2022.11.06.14.27.09.548.0 ]--
r 53             sout
--[ 2022.11.06.14.27.09.592.0 ]--
r 53             System.out.println();
--[ 2022.11.06.14.27.10.686.0 ]--
r 53             System.out.println('');
--[ 2022.11.06.14.27.11.750.0 ]--
r 53             System.out.println('t');
--[ 2022.11.06.14.27.11.855.0 ]--
r 53             System.out.println('th');
--[ 2022.11.06.14.27.11.898.0 ]--
r 53             System.out.println('thi');
--[ 2022.11.06.14.27.11.995.0 ]--
r 53             System.out.println('this');
--[ 2022.11.06.14.27.12.796.0 ]--
r 53             System.out.println('this"');
--[ 2022.11.06.14.27.13.013.0 ]--
r 53             System.out.println('this" ');
--[ 2022.11.06.14.27.13.419.0 ]--
r 53             System.out.println('this" +');
--[ 2022.11.06.14.27.13.616.0 ]--
r 53             System.out.println('this" + ');
--[ 2022.11.06.14.27.14.389.0 ]--
r 53             System.out.println('this" +');
--[ 2022.11.06.14.27.14.556.0 ]--
r 53             System.out.println('this" ');
--[ 2022.11.06.14.27.14.713.0 ]--
r 53             System.out.println('this"');
--[ 2022.11.06.14.27.14.892.0 ]--
r 53             System.out.println('this');
--[ 2022.11.06.14.27.15.051.0 ]--
r 53             System.out.println('thi');
--[ 2022.11.06.14.27.15.220.0 ]--
r 53             System.out.println('th');
--[ 2022.11.06.14.27.15.390.0 ]--
r 53             System.out.println('t');
--[ 2022.11.06.14.27.15.560.0 ]--
r 53             System.out.println('');
--[ 2022.11.06.14.27.15.974.0 ]--
r 53             System.out.println();
--[ 2022.11.06.14.27.16.878.0 ]--
r 53             System.out.println("");
--[ 2022.11.06.14.27.17.407.0 ]--
r 53             System.out.println("T");
--[ 2022.11.06.14.27.17.440.0 ]--
r 53             System.out.println("TH");
--[ 2022.11.06.14.27.17.519.0 ]--
r 53             System.out.println("THi");
--[ 2022.11.06.14.27.17.639.0 ]--
r 53             System.out.println("THis");
--[ 2022.11.06.14.27.18.322.0 ]--
r 53             System.out.println("THi");
--[ 2022.11.06.14.27.18.459.0 ]--
r 53             System.out.println("TH");
--[ 2022.11.06.14.27.18.605.0 ]--
r 53             System.out.println("T");
--[ 2022.11.06.14.27.18.693.0 ]--
r 53             System.out.println("Th");
--[ 2022.11.06.14.27.18.763.0 ]--
r 53             System.out.println("Thi");
--[ 2022.11.06.14.27.18.835.0 ]--
r 53             System.out.println("This");
--[ 2022.11.06.14.27.19.046.0 ]--
r 53             System.out.println("This:");
--[ 2022.11.06.14.27.19.263.0 ]--
r 53             System.out.println("This: ");
--[ 2022.11.06.14.27.19.780.0 ]--
r 53             System.out.println("This: " );
--[ 2022.11.06.14.27.20.714.0 ]--
r 53             System.out.println("This: " t);
--[ 2022.11.06.14.27.20.787.0 ]--
r 53             System.out.println("This: " th);
--[ 2022.11.06.14.27.20.875.0 ]--
r 53             System.out.println("This: " thi);
--[ 2022.11.06.14.27.20.953.0 ]--
r 53             System.out.println("This: " this);
--[ 2022.11.06.14.27.23.301.0 ]--
UpdateTree (AD): 0 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.23.301.1 ]--
CompilationStatus (AEW): 0 3 0
[Ljava.lang.String;@70adbe28
--[ 2022.11.06.14.27.27.237.0 ]--
r 53             System.out.println("This: " this.);
--[ 2022.11.06.14.27.27.238.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.27.247.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.28.187.0 ]--
r 53             System.out.println("This: " this);
--[ 2022.11.06.14.27.28.188.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.28.192.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.30.192.0 ]--
r 53             System.out.println("This: " +this);
--[ 2022.11.06.14.27.30.192.1 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.30.195.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.30.198.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.30.199.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.30.200.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.30.342.0 ]--
r 53             System.out.println("This: " + this);
--[ 2022.11.06.14.27.30.343.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.30.346.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.33.413.0 ]--
UpdateTree (AD): 2 0
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.06.14.27.33.413.1 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.28.09.916.0 ]--
r 55                 return 0-;
--[ 2022.11.06.14.28.10.899.0 ]--
r 55                 return 0;
--[ 2022.11.06.14.28.13.023.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.29.55.529.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.30.08.556.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.31.30.825.0 ]--
r 39             if (this.c(heuristic) > that.getCost(heuristic)) {
--[ 2022.11.06.14.31.30.928.0 ]--
r 39             if (this.co(heuristic) > that.getCost(heuristic)) {
--[ 2022.11.06.14.31.30.985.0 ]--
r 39             if (this.cos(heuristic) > that.getCost(heuristic)) {
--[ 2022.11.06.14.31.31.116.0 ]--
r 39             if (this.cost(heuristic) > that.getCost(heuristic)) {
--[ 2022.11.06.14.31.33.915.0 ]--
r 39             if (this.cost(heuristic) > that.c(heuristic)) {
--[ 2022.11.06.14.31.34.048.0 ]--
r 39             if (this.cost(heuristic) > that.co(heuristic)) {
--[ 2022.11.06.14.31.34.098.0 ]--
r 39             if (this.cost(heuristic) > that.cos(heuristic)) {
--[ 2022.11.06.14.31.34.210.0 ]--
r 39             if (this.cost(heuristic) > that.cost(heuristic)) {
--[ 2022.11.06.14.31.36.979.0 ]--
r 39             if (this.cost(heuristic) > that.cost()) {
--[ 2022.11.06.14.31.37.751.0 ]--
r 39             if (this.cost(heuristic) > that.cost() {
--[ 2022.11.06.14.31.37.960.0 ]--
r 39             if (this.cost(heuristic) > that.cost) {
--[ 2022.11.06.14.31.39.952.0 ]--
r 39             if (this.cost(heuristic > that.cost) {
--[ 2022.11.06.14.31.40.094.0 ]--
r 39             if (this.cost(heuristi > that.cost) {
--[ 2022.11.06.14.31.40.237.0 ]--
r 39             if (this.cost(heurist > that.cost) {
--[ 2022.11.06.14.31.40.390.0 ]--
r 39             if (this.cost(heuris > that.cost) {
--[ 2022.11.06.14.31.40.521.0 ]--
r 39             if (this.cost(heuri > that.cost) {
--[ 2022.11.06.14.31.40.683.0 ]--
r 39             if (this.cost(heur > that.cost) {
--[ 2022.11.06.14.31.40.824.0 ]--
r 39             if (this.cost(heu > that.cost) {
--[ 2022.11.06.14.31.40.974.0 ]--
r 39             if (this.cost(he > that.cost) {
--[ 2022.11.06.14.31.41.140.0 ]--
r 39             if (this.cost(h > that.cost) {
--[ 2022.11.06.14.31.41.318.0 ]--
r 39             if (this.cost( > that.cost) {
--[ 2022.11.06.14.31.41.780.0 ]--
r 39             if (this.cost > that.cost) {
--[ 2022.11.06.14.31.45.606.0 ]--
r 42             else if (this.c(heuristic) < that.getCost(heuristic)) {
--[ 2022.11.06.14.31.45.731.0 ]--
r 42             else if (this.co(heuristic) < that.getCost(heuristic)) {
--[ 2022.11.06.14.31.45.821.0 ]--
r 42             else if (this.cos(heuristic) < that.getCost(heuristic)) {
--[ 2022.11.06.14.31.45.910.0 ]--
r 42             else if (this.cost(heuristic) < that.getCost(heuristic)) {
--[ 2022.11.06.14.31.47.450.0 ]--
r 42             else if (this.cost() < that.getCost(heuristic)) {
--[ 2022.11.06.14.31.47.742.0 ]--
r 42             else if (this.cost( < that.getCost(heuristic)) {
--[ 2022.11.06.14.31.47.928.0 ]--
r 42             else if (this.cost < that.getCost(heuristic)) {
--[ 2022.11.06.14.31.49.869.0 ]--
r 42             else if (this.cost < that.getCost()) {
--[ 2022.11.06.14.31.50.178.0 ]--
r 42             else if (this.cost < that.getCost() {
--[ 2022.11.06.14.31.50.390.0 ]--
r 42             else if (this.cost < that.getCost) {
--[ 2022.11.06.14.31.50.788.0 ]--
r 42             else if (this.cost < that.getCos) {
--[ 2022.11.06.14.31.50.931.0 ]--
r 42             else if (this.cost < that.getCo) {
--[ 2022.11.06.14.31.51.117.0 ]--
r 42             else if (this.cost < that.getC) {
--[ 2022.11.06.14.31.51.290.0 ]--
r 42             else if (this.cost < that.get) {
--[ 2022.11.06.14.31.51.466.0 ]--
r 42             else if (this.cost < that.ge) {
--[ 2022.11.06.14.31.51.629.0 ]--
r 42             else if (this.cost < that.g) {
--[ 2022.11.06.14.31.52.036.0 ]--
r 42             else if (this.cost < that.) {
--[ 2022.11.06.14.31.52.511.0 ]--
r 42             else if (this.cost < that.c) {
--[ 2022.11.06.14.31.52.630.0 ]--
r 42             else if (this.cost < that.co) {
--[ 2022.11.06.14.31.52.673.0 ]--
r 42             else if (this.cost < that.cos) {
--[ 2022.11.06.14.31.52.792.0 ]--
r 42             else if (this.cost < that.cost) {
--[ 2022.11.06.14.31.58.080.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.34.11.938.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.34.49.299.0 ]--
+ 141                 
--[ 2022.11.06.14.34.52.421.0 ]--
r 141                 l
--[ 2022.11.06.14.34.52.516.0 ]--
r 141                 le
--[ 2022.11.06.14.34.52.853.0 ]--
r 141                 lef
--[ 2022.11.06.14.34.53.071.0 ]--
r 141                 left
--[ 2022.11.06.14.34.53.174.0 ]--
r 141                 left.
--[ 2022.11.06.14.34.53.580.0 ]--
r 141                 left.g
--[ 2022.11.06.14.34.53.695.0 ]--
r 141                 left.ge
--[ 2022.11.06.14.34.53.817.0 ]--
r 141                 left.get
--[ 2022.11.06.14.34.54.551.0 ]--
r 141                 left.getCost
--[ 2022.11.06.14.34.54.558.0 ]--
r 141                 left.getCost()
--[ 2022.11.06.14.34.56.532.0 ]--
r 141                 left.getCost();
--[ 2022.11.06.14.35.06.630.0 ]--
r 141                 left.getCost(h);
--[ 2022.11.06.14.35.06.696.0 ]--
r 141                 left.getCost(he);
--[ 2022.11.06.14.35.07.362.0 ]--
r 141                 left.getCost(heuristic);
--[ 2022.11.06.14.35.45.262.0 ]--
r 139             if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()] ) {
--[ 2022.11.06.14.35.45.839.0 ]--
r 139             if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()] &) {
--[ 2022.11.06.14.35.45.977.0 ]--
r 139             if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()] &&) {
--[ 2022.11.06.14.35.46.175.0 ]--
r 139             if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()] && ) {
--[ 2022.11.06.14.35.55.766.0 ]--
r 139             if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()] &&) {
--[ 2022.11.06.14.35.56.020.0 ]--
r 139             if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()] &) {
--[ 2022.11.06.14.35.56.214.0 ]--
r 139             if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()] ) {
--[ 2022.11.06.14.35.56.437.0 ]--
r 139             if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.14.36.33.103.0 ]--
+ 148                 
--[ 2022.11.06.14.36.35.093.0 ]--
r 148                 r
--[ 2022.11.06.14.36.35.159.0 ]--
r 148                 ri
--[ 2022.11.06.14.36.35.268.0 ]--
r 148                 rig
--[ 2022.11.06.14.36.35.408.0 ]--
r 148                 righ
--[ 2022.11.06.14.36.35.472.0 ]--
r 148                 right
--[ 2022.11.06.14.36.35.701.0 ]--
r 148                 right.
--[ 2022.11.06.14.36.36.778.0 ]--
r 148                 right.g
--[ 2022.11.06.14.36.36.908.0 ]--
r 148                 right.ge
--[ 2022.11.06.14.36.36.996.0 ]--
r 148                 right.get
--[ 2022.11.06.14.36.37.411.0 ]--
r 148                 right.getCost
--[ 2022.11.06.14.36.37.415.0 ]--
r 148                 right.getCost()
--[ 2022.11.06.14.36.38.044.0 ]--
r 148                 right.getCost(h)
--[ 2022.11.06.14.36.38.130.0 ]--
r 148                 right.getCost(he)
--[ 2022.11.06.14.36.38.673.0 ]--
r 148                 right.getCost(heuristic)
--[ 2022.11.06.14.36.41.322.0 ]--
r 148                 right.getCost(heuristic);
--[ 2022.11.06.14.36.44.017.0 ]--
+ 156                 
--[ 2022.11.06.14.36.45.874.0 ]--
r 156                 a
--[ 2022.11.06.14.36.46.051.0 ]--
r 156                 ab
--[ 2022.11.06.14.36.46.129.0 ]--
r 156                 abo
--[ 2022.11.06.14.36.46.583.0 ]--
r 156                 above
--[ 2022.11.06.14.36.46.870.0 ]--
r 156                 above.
--[ 2022.11.06.14.36.47.132.0 ]--
r 156                 above.g
--[ 2022.11.06.14.36.47.280.0 ]--
r 156                 above.ge
--[ 2022.11.06.14.36.47.387.0 ]--
r 156                 above.get
--[ 2022.11.06.14.36.47.671.0 ]--
r 156                 above.getCost
--[ 2022.11.06.14.36.47.675.0 ]--
r 156                 above.getCost()
--[ 2022.11.06.14.36.48.226.0 ]--
r 156                 above.getCost(h)
--[ 2022.11.06.14.36.48.273.0 ]--
r 156                 above.getCost(he)
--[ 2022.11.06.14.36.48.523.0 ]--
r 156                 above.getCost(heuristic)
--[ 2022.11.06.14.36.50.196.0 ]--
r 156                 above.getCost(heuristic);
--[ 2022.11.06.14.36.52.584.0 ]--
+ 163                 
--[ 2022.11.06.14.36.54.028.0 ]--
r 163                 b
--[ 2022.11.06.14.36.54.148.0 ]--
r 163                 be
--[ 2022.11.06.14.36.54.205.0 ]--
r 163                 bel
--[ 2022.11.06.14.36.54.344.0 ]--
r 163                 belo
--[ 2022.11.06.14.36.54.406.0 ]--
r 163                 below
--[ 2022.11.06.14.36.56.357.0 ]--
r 163                 below.
--[ 2022.11.06.14.36.57.206.0 ]--
r 163                 below.g
--[ 2022.11.06.14.36.57.319.0 ]--
r 163                 below.ge
--[ 2022.11.06.14.36.57.414.0 ]--
r 163                 below.get
--[ 2022.11.06.14.36.59.059.0 ]--
r 163                 below.getCost
--[ 2022.11.06.14.36.59.062.0 ]--
r 163                 below.getCost()
--[ 2022.11.06.14.37.00.997.0 ]--
r 163                 below.getCost(h)
--[ 2022.11.06.14.37.01.045.0 ]--
r 163                 below.getCost(he)
--[ 2022.11.06.14.37.01.267.0 ]--
r 163                 below.getCost(heuristic)
--[ 2022.11.06.14.37.02.769.0 ]--
r 163                 below.getCost(heuristic);
--[ 2022.11.06.14.37.08.901.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.37.48.577.0 ]--
r 57             this.cost = this.prevNode.c(0)
--[ 2022.11.06.14.37.48.667.0 ]--
r 57             this.cost = this.prevNode.co(0)
--[ 2022.11.06.14.37.48.742.0 ]--
r 57             this.cost = this.prevNode.cos(0)
--[ 2022.11.06.14.37.48.853.0 ]--
r 57             this.cost = this.prevNode.cost(0)
--[ 2022.11.06.14.37.52.015.0 ]--
r 57             this.cost = this.prevNode.cost(0
--[ 2022.11.06.14.37.52.196.0 ]--
r 57             this.cost = this.prevNode.cost(
--[ 2022.11.06.14.37.52.414.0 ]--
r 57             this.cost = this.prevNode.cost
--[ 2022.11.06.14.37.56.037.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.38.31.753.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.39.37.644.0 ]--
r 34             cost = -;
--[ 2022.11.06.14.39.37.810.0 ]--
r 34             cost = ;
--[ 2022.11.06.14.39.38.099.0 ]--
r 34             cost = 0;
--[ 2022.11.06.14.39.46.531.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.40.01.203.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.44.01.877.0 ]--
r 153             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()1]) {
--[ 2022.11.06.14.44.02.213.0 ]--
r 153             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.14.44.05.957.0 ]--
r 155                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()1] = true;
--[ 2022.11.06.14.44.06.123.0 ]--
r 155                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1] = true;
--[ 2022.11.06.14.44.08.514.0 ]--
r 160             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()1]) {
--[ 2022.11.06.14.44.08.832.0 ]--
r 160             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.14.44.10.855.0 ]--
r 162                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()1] = true;
--[ 2022.11.06.14.44.11.126.0 ]--
r 162                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = true;
--[ 2022.11.06.14.44.20.777.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.47.01.632.0 ]--
r 139             if (!array[nextTile.currentTile.getI()1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.14.47.01.725.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.14.47.04.002.0 ]--
r 142                 array[nextTile.currentTile.getI()1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.14.47.04.045.0 ]--
r 142                 array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.14.47.06.671.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI()1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.47.06.741.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.47.47.509.0 ]--
r 146             if (!array[nextTile.currentTile.getI()1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.14.47.47.916.0 ]--
r 146             if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.14.47.50.257.0 ]--
r 147                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI()  1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.47.50.538.0 ]--
r 147                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.47.53.670.0 ]--
r 149                 array[nextTile.currentTile.getI()  1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.14.47.53.930.0 ]--
r 149                 array[nextTile.currentTile.getI() + 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.14.48.13.675.0 ]--
r 154                 PFNode above = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()1), nextTile);
--[ 2022.11.06.14.48.13.770.0 ]--
r 154                 PFNode above = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.06.14.48.45.833.0 ]--
r 161                 PFNode below = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()1), nextTile);
--[ 2022.11.06.14.48.45.993.0 ]--
r 161                 PFNode below = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.06.14.48.55.950.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.49.16.607.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.49.40.783.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.50.03.476.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.52.37.945.0 ]--
r 139             if (!array[nextTile.currentTile.get()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.14.52.38.203.0 ]--
r 139             if (!array[nextTile.currentTile.getJ()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.14.52.40.489.0 ]--
r 139             if (!array[nextTile.currentTile.getJ()-1][nextTile.currentTile.get()]) {
--[ 2022.11.06.14.52.40.901.0 ]--
r 139             if (!array[nextTile.currentTile.getJ()-1][nextTile.currentTile.getI()]) {
--[ 2022.11.06.14.52.46.426.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.get()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.52.46.842.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getJ()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.52.49.039.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getJ()-1, nextTile.currentTile.get()), nextTile);
--[ 2022.11.06.14.52.49.425.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getJ()-1, nextTile.currentTile.getI()), nextTile);
--[ 2022.11.06.14.52.52.178.0 ]--
r 142                 array[nextTile.currentTile.get()-1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.14.52.52.518.0 ]--
r 142                 array[nextTile.currentTile.getJ()-1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.14.52.54.497.0 ]--
r 142                 array[nextTile.currentTile.getJ()-1][nextTile.currentTile.get()] = true;
--[ 2022.11.06.14.52.54.911.0 ]--
r 142                 array[nextTile.currentTile.getJ()-1][nextTile.currentTile.getI()] = true;
--[ 2022.11.06.14.52.59.749.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.54.12.244.0 ]--
r 139             if (!array[nextTile.currentTile.get()-1][nextTile.currentTile.getI()]) {
--[ 2022.11.06.14.54.12.835.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getI()]) {
--[ 2022.11.06.14.54.15.411.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.get()]) {
--[ 2022.11.06.14.54.15.761.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getK()]) {
--[ 2022.11.06.14.54.16.313.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.get()]) {
--[ 2022.11.06.14.54.16.614.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.14.54.21.497.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.get()-1, nextTile.currentTile.getI()), nextTile);
--[ 2022.11.06.14.54.21.817.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getI()), nextTile);
--[ 2022.11.06.14.54.23.874.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.get()), nextTile);
--[ 2022.11.06.14.54.24.272.0 ]--
r 140                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.54.27.003.0 ]--
r 142                 array[nextTile.currentTile.get()-1][nextTile.currentTile.getI()] = true;
--[ 2022.11.06.14.54.27.364.0 ]--
r 142                 array[nextTile.currentTile.getI()-1][nextTile.currentTile.getI()] = true;
--[ 2022.11.06.14.54.29.543.0 ]--
r 142                 array[nextTile.currentTile.getI()-1][nextTile.currentTile.get()] = true;
--[ 2022.11.06.14.54.31.430.0 ]--
r 142                 array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.14.54.43.772.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.54.58.246.0 ]--
r 138             // a of current tile
--[ 2022.11.06.14.54.58.654.0 ]--
r 138             // ab of current tile
--[ 2022.11.06.14.54.58.743.0 ]--
r 138             // abo of current tile
--[ 2022.11.06.14.54.58.975.0 ]--
r 138             // aboe of current tile
--[ 2022.11.06.14.54.59.372.0 ]--
r 138             // abo of current tile
--[ 2022.11.06.14.54.59.430.0 ]--
r 138             // abov of current tile
--[ 2022.11.06.14.54.59.494.0 ]--
r 138             // above of current tile
--[ 2022.11.06.14.55.01.476.0 ]--
r 140                 PFNode a = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.55.01.736.0 ]--
r 140                 PFNode ab = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.55.01.849.0 ]--
r 140                 PFNode abo = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.55.01.981.0 ]--
r 140                 PFNode abov = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.55.02.115.0 ]--
r 140                 PFNode above = new PFNode(new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.55.03.709.0 ]--
r 141                 a.getCost(heuristic);
--[ 2022.11.06.14.55.03.930.0 ]--
r 141                 ab.getCost(heuristic);
--[ 2022.11.06.14.55.04.048.0 ]--
r 141                 abo.getCost(heuristic);
--[ 2022.11.06.14.55.04.144.0 ]--
r 141                 abov.getCost(heuristic);
--[ 2022.11.06.14.55.04.250.0 ]--
r 141                 above.getCost(heuristic);
--[ 2022.11.06.14.55.05.759.0 ]--
r 143                 pq.insert(a);
--[ 2022.11.06.14.55.05.983.0 ]--
r 143                 pq.insert(ab);
--[ 2022.11.06.14.55.06.096.0 ]--
r 143                 pq.insert(abo);
--[ 2022.11.06.14.55.06.200.0 ]--
r 143                 pq.insert(abov);
--[ 2022.11.06.14.55.06.306.0 ]--
r 143                 pq.insert(above);
--[ 2022.11.06.14.55.12.006.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.55.38.982.0 ]--
r 145             // b of current tile
--[ 2022.11.06.14.55.39.189.0 ]--
r 145             // bw of current tile
--[ 2022.11.06.14.55.39.406.0 ]--
r 145             // bwl of current tile
--[ 2022.11.06.14.55.39.577.0 ]--
r 145             // bwlo of current tile
--[ 2022.11.06.14.55.39.867.0 ]--
r 145             // bwl of current tile
--[ 2022.11.06.14.55.40.033.0 ]--
r 145             // bw of current tile
--[ 2022.11.06.14.55.40.180.0 ]--
r 145             // b of current tile
--[ 2022.11.06.14.55.40.278.0 ]--
r 145             // be of current tile
--[ 2022.11.06.14.55.40.357.0 ]--
r 145             // bel of current tile
--[ 2022.11.06.14.55.40.543.0 ]--
r 145             // belo of current tile
--[ 2022.11.06.14.55.40.607.0 ]--
r 145             // below of current tile
--[ 2022.11.06.14.55.43.284.0 ]--
r 147                 PFNode b = new PFNode(new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.55.43.474.0 ]--
r 147                 PFNode be = new PFNode(new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.55.43.837.0 ]--
r 147                 PFNode bel = new PFNode(new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.55.44.027.0 ]--
r 147                 PFNode belo = new PFNode(new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.55.44.129.0 ]--
r 147                 PFNode below = new PFNode(new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.14.55.45.891.0 ]--
r 150                 pq.insert(b);
--[ 2022.11.06.14.55.46.039.0 ]--
r 150                 pq.insert(be);
--[ 2022.11.06.14.55.46.617.0 ]--
r 150                 pq.insert(b);
--[ 2022.11.06.14.55.47.143.0 ]--
r 150                 pq.insert(be);
--[ 2022.11.06.14.55.47.226.0 ]--
r 150                 pq.insert(bel);
--[ 2022.11.06.14.55.47.412.0 ]--
r 150                 pq.insert(belo);
--[ 2022.11.06.14.55.47.512.0 ]--
r 150                 pq.insert(below);
--[ 2022.11.06.14.55.50.536.0 ]--
r 148                 b.getCost(heuristic);
--[ 2022.11.06.14.55.50.664.0 ]--
r 148                 be.getCost(heuristic);
--[ 2022.11.06.14.55.50.773.0 ]--
r 148                 bel.getCost(heuristic);
--[ 2022.11.06.14.55.50.946.0 ]--
r 148                 belo.getCost(heuristic);
--[ 2022.11.06.14.55.50.998.0 ]--
r 148                 below.getCost(heuristic);
--[ 2022.11.06.14.55.56.382.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.56.24.432.0 ]--
r 152             // l current tile
--[ 2022.11.06.14.56.24.479.0 ]--
r 152             // le current tile
--[ 2022.11.06.14.56.24.618.0 ]--
r 152             // lef current tile
--[ 2022.11.06.14.56.24.819.0 ]--
r 152             // left current tile
--[ 2022.11.06.14.56.27.120.0 ]--
r 154                 PFNode l = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.06.14.56.27.211.0 ]--
r 154                 PFNode le = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.06.14.56.27.302.0 ]--
r 154                 PFNode lef = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.06.14.56.27.524.0 ]--
r 154                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1), nextTile);
--[ 2022.11.06.14.56.29.554.0 ]--
r 156                 l.getCost(heuristic);
--[ 2022.11.06.14.56.29.617.0 ]--
r 156                 le.getCost(heuristic);
--[ 2022.11.06.14.56.29.742.0 ]--
r 156                 lef.getCost(heuristic);
--[ 2022.11.06.14.56.30.005.0 ]--
r 156                 left.getCost(heuristic);
--[ 2022.11.06.14.56.31.521.0 ]--
r 157                 pq.insert(l);
--[ 2022.11.06.14.56.31.626.0 ]--
r 157                 pq.insert(le);
--[ 2022.11.06.14.56.31.705.0 ]--
r 157                 pq.insert(lef);
--[ 2022.11.06.14.56.31.966.0 ]--
r 157                 pq.insert(left);
--[ 2022.11.06.14.56.43.724.0 ]--
r 159             // r current tile
--[ 2022.11.06.14.56.43.776.0 ]--
r 159             // ri current tile
--[ 2022.11.06.14.56.43.918.0 ]--
r 159             // rig current tile
--[ 2022.11.06.14.56.44.029.0 ]--
r 159             // righ current tile
--[ 2022.11.06.14.56.44.091.0 ]--
r 159             // right current tile
--[ 2022.11.06.14.56.46.218.0 ]--
r 161                 PFNode r = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.06.14.56.46.286.0 ]--
r 161                 PFNode ri = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.06.14.56.46.390.0 ]--
r 161                 PFNode rig = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.06.14.56.46.549.0 ]--
r 161                 PFNode righ = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.06.14.56.46.595.0 ]--
r 161                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.06.14.56.50.050.0 ]--
r 163                 r.getCost(heuristic);
--[ 2022.11.06.14.56.50.108.0 ]--
r 163                 ri.getCost(heuristic);
--[ 2022.11.06.14.56.50.259.0 ]--
r 163                 rig.getCost(heuristic);
--[ 2022.11.06.14.56.50.405.0 ]--
r 163                 righ.getCost(heuristic);
--[ 2022.11.06.14.56.50.462.0 ]--
r 163                 right.getCost(heuristic);
--[ 2022.11.06.14.56.52.056.0 ]--
r 164                 pq.insert(r);
--[ 2022.11.06.14.56.52.103.0 ]--
r 164                 pq.insert(ri);
--[ 2022.11.06.14.56.52.257.0 ]--
r 164                 pq.insert(rig);
--[ 2022.11.06.14.56.52.376.0 ]--
r 164                 pq.insert(righ);
--[ 2022.11.06.14.56.52.467.0 ]--
r 164                 pq.insert(right);
--[ 2022.11.06.14.57.31.871.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.57.45.835.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.58.27.211.0 ]--
r 134             PFNode nextTile = pq.d();
--[ 2022.11.06.14.58.27.357.0 ]--
r 134             PFNode nextTile = pq.de();
--[ 2022.11.06.14.58.27.424.0 ]--
r 134             PFNode nextTile = pq.del();
--[ 2022.11.06.14.58.27.563.0 ]--
r 134             PFNode nextTile = pq.dele();
--[ 2022.11.06.14.58.28.111.0 ]--
r 134             PFNode nextTile = pq.del();
--[ 2022.11.06.14.58.28.424.0 ]--
r 134             PFNode nextTile = pq.delM();
--[ 2022.11.06.14.58.28.629.0 ]--
r 134             PFNode nextTile = pq.delMi();
--[ 2022.11.06.14.58.28.709.0 ]--
r 134             PFNode nextTile = pq.delMin();
--[ 2022.11.06.14.58.33.596.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.14.59.00.266.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] ) {
--[ 2022.11.06.14.59.00.496.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] &) {
--[ 2022.11.06.14.59.00.609.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] &&) {
--[ 2022.11.06.14.59.01.333.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] && ) {
--[ 2022.11.06.14.59.04.602.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] &&) {
--[ 2022.11.06.14.59.04.985.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] &) {
--[ 2022.11.06.14.59.05.200.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] ) {
--[ 2022.11.06.14.59.05.557.0 ]--
r 139             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.14.59.15.423.0 ]--
+ 141                 
--[ 2022.11.06.14.59.25.830.0 ]--
r 141                 i
--[ 2022.11.06.14.59.25.895.0 ]--
r 141                 if
--[ 2022.11.06.14.59.26.350.0 ]--
r 141                 if()
--[ 2022.11.06.14.59.26.808.0 ]--
r 141                 if
--[ 2022.11.06.14.59.26.879.0 ]--
r 141                 if 
--[ 2022.11.06.14.59.26.990.0 ]--
r 141                 if ()
--[ 2022.11.06.14.59.27.196.0 ]--
r 141                 if ( )
--[ 2022.11.06.14.59.27.682.0 ]--
r 141                 if ()
--[ 2022.11.06.14.59.27.793.0 ]--
r 141                 if (t)
--[ 2022.11.06.14.59.27.901.0 ]--
r 141                 if (th)
--[ 2022.11.06.14.59.28.204.0 ]--
r 141                 if (t)
--[ 2022.11.06.14.59.28.360.0 ]--
r 141                 if ()
--[ 2022.11.06.14.59.28.567.0 ]--
r 141                 if (a)
--[ 2022.11.06.14.59.28.742.0 ]--
r 141                 if (ab)
--[ 2022.11.06.14.59.28.842.0 ]--
r 141                 if (abo)
--[ 2022.11.06.14.59.28.949.0 ]--
r 141                 if (abov)
--[ 2022.11.06.14.59.29.062.0 ]--
r 141                 if (above)
--[ 2022.11.06.14.59.29.228.0 ]--
r 141                 if (above.)
--[ 2022.11.06.14.59.33.216.0 ]--
r 141                 if (above.i)
--[ 2022.11.06.14.59.33.337.0 ]--
r 141                 if (above.is)
--[ 2022.11.06.14.59.34.138.0 ]--
r 141                 if (above.i)
--[ 2022.11.06.14.59.34.299.0 ]--
r 141                 if (above.)
--[ 2022.11.06.14.59.35.316.0 ]--
r 141                 if (above.c)
--[ 2022.11.06.14.59.35.406.0 ]--
r 141                 if (above.cu)
--[ 2022.11.06.14.59.35.970.0 ]--
r 141                 if (above.currentTile)
--[ 2022.11.06.14.59.36.345.0 ]--
r 141                 if (above.currentTile.)
--[ 2022.11.06.14.59.36.527.0 ]--
r 141                 if (above.currentTile.i)
--[ 2022.11.06.14.59.36.633.0 ]--
r 141                 if (above.currentTile.is)
--[ 2022.11.06.14.59.37.937.0 ]--
r 141                 if (above.currentTile.isInBounds)
--[ 2022.11.06.14.59.37.941.0 ]--
r 141                 if (above.currentTile.isInBounds())
--[ 2022.11.06.14.59.42.093.0 ]--
r 141                 if (above.currentTile.isInBounds(C))
--[ 2022.11.06.14.59.42.195.0 ]--
r 141                 if (above.currentTile.isInBounds(Co))
--[ 2022.11.06.14.59.42.380.0 ]--
r 141                 if (above.currentTile.isInBounds(Cor))
--[ 2022.11.06.14.59.43.075.0 ]--
r 141                 if (above.currentTile.isInBounds(Co))
--[ 2022.11.06.14.59.43.202.0 ]--
r 141                 if (above.currentTile.isInBounds(Coo))
--[ 2022.11.06.14.59.43.326.0 ]--
r 141                 if (above.currentTile.isInBounds(Coor))
--[ 2022.11.06.14.59.43.741.0 ]--
r 141                 if (above.currentTile.isInBounds(Coo))
--[ 2022.11.06.14.59.43.905.0 ]--
r 141                 if (above.currentTile.isInBounds(Co))
--[ 2022.11.06.14.59.44.097.0 ]--
r 141                 if (above.currentTile.isInBounds(C))
--[ 2022.11.06.14.59.44.259.0 ]--
r 141                 if (above.currentTile.isInBounds())
--[ 2022.11.06.14.59.45.451.0 ]--
r 141                 if (above.currentTile.isInBounds(C))
--[ 2022.11.06.14.59.45.757.0 ]--
r 141                 if (above.currentTile.isInBounds(Co))
--[ 2022.11.06.14.59.45.874.0 ]--
r 141                 if (above.currentTile.isInBounds(Coo))
--[ 2022.11.06.14.59.45.957.0 ]--
r 141                 if (above.currentTile.isInBounds(Coor))
--[ 2022.11.06.14.59.46.849.0 ]--
r 141                 if (above.currentTile.isInBounds(Coor()))
--[ 2022.11.06.14.59.48.291.0 ]--
r 141                 if (above.currentTile.isInBounds(Coor(0)))
--[ 2022.11.06.14.59.48.556.0 ]--
r 141                 if (above.currentTile.isInBounds(Coor(0,)))
--[ 2022.11.06.14.59.48.726.0 ]--
r 141                 if (above.currentTile.isInBounds(Coor(0,0)))
--[ 2022.11.06.14.59.52.194.0 ]--
r 141                 if (above.currentTile.isInBounds(nCoor(0,0)))
--[ 2022.11.06.14.59.52.249.0 ]--
r 141                 if (above.currentTile.isInBounds(neCoor(0,0)))
--[ 2022.11.06.14.59.52.361.0 ]--
r 141                 if (above.currentTile.isInBounds(newCoor(0,0)))
--[ 2022.11.06.14.59.52.447.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0)))
--[ 2022.11.06.14.59.56.362.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0),))
--[ 2022.11.06.14.59.57.128.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0), ))
--[ 2022.11.06.14.59.57.289.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0), n))
--[ 2022.11.06.14.59.57.339.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0), ne))
--[ 2022.11.06.14.59.57.445.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0), new))
--[ 2022.11.06.14.59.57.548.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0), new ))
--[ 2022.11.06.14.59.57.756.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0), new C))
--[ 2022.11.06.14.59.57.881.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0), new Co))
--[ 2022.11.06.14.59.58.456.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0), new Coo))
--[ 2022.11.06.14.59.58.534.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0), new Coor))
--[ 2022.11.06.14.59.58.987.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0), new Coord))
--[ 2022.11.06.15.00.03.262.0 ]--
r 141                 if (above.currentTile.isInBounds(new Coor(0,0), new Coord()))
--[ 2022.11.06.15.00.10.236.0 ]--
+ 30         
--[ 2022.11.06.15.00.11.139.0 ]--
r 30         i
--[ 2022.11.06.15.00.11.213.0 ]--
r 30         in
--[ 2022.11.06.15.00.11.292.0 ]--
r 30         int
--[ 2022.11.06.15.00.11.414.0 ]--
r 30         int 
--[ 2022.11.06.15.00.11.776.0 ]--
r 30         int N
--[ 2022.11.06.15.00.12.322.0 ]--
r 30         int N;
--[ 2022.11.06.15.00.35.677.0 ]--
r 30     
--[ 2022.11.06.15.00.35.951.0 ]--
- 30
--[ 2022.11.06.15.00.40.958.0 ]--
+ 11     
--[ 2022.11.06.15.00.41.463.0 ]--
r 11     n
--[ 2022.11.06.15.00.41.595.0 ]--
r 11     nt
--[ 2022.11.06.15.00.41.935.0 ]--
r 11     n
--[ 2022.11.06.15.00.42.085.0 ]--
r 11     
--[ 2022.11.06.15.00.42.209.0 ]--
r 11     i
--[ 2022.11.06.15.00.42.305.0 ]--
r 11     in
--[ 2022.11.06.15.00.42.384.0 ]--
r 11     int
--[ 2022.11.06.15.00.42.508.0 ]--
r 11     int 
--[ 2022.11.06.15.00.42.912.0 ]--
r 11     int N
--[ 2022.11.06.15.00.43.240.0 ]--
r 11     int N;
--[ 2022.11.06.15.00.56.371.0 ]--
r 97         int  = t.getN();
--[ 2022.11.06.15.00.56.672.0 ]--
r 97         int N = t.getN();
--[ 2022.11.06.15.00.58.922.0 ]--
r 99         array = new boolean[][n];
--[ 2022.11.06.15.00.59.648.0 ]--
r 99         array = new boolean[N][n];
--[ 2022.11.06.15.01.01.510.0 ]--
r 99         array = new boolean[N][];
--[ 2022.11.06.15.01.02.090.0 ]--
r 99         array = new boolean[N][N];
--[ 2022.11.06.15.01.06.624.0 ]--
r 97          N = t.getN();
--[ 2022.11.06.15.01.07.018.0 ]--
r 97         N = t.getN();
--[ 2022.11.06.15.01.16.628.0 ]--
r 142                 if (above.currentTile.isInBounds(new Coord(0,0), new Coord()))
--[ 2022.11.06.15.01.18.743.0 ]--
r 142                 if (above.currentTile.isInBounds(new Coord(0,0), new Coord(N)))
--[ 2022.11.06.15.01.19.058.0 ]--
r 142                 if (above.currentTile.isInBounds(new Coord(0,0), new Coord(N,)))
--[ 2022.11.06.15.01.19.249.0 ]--
r 142                 if (above.currentTile.isInBounds(new Coord(0,0), new Coord(N, )))
--[ 2022.11.06.15.01.19.621.0 ]--
r 142                 if (above.currentTile.isInBounds(new Coord(0,0), new Coord(N, N)))
--[ 2022.11.06.15.01.22.482.0 ]--
r 142                 if (above.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) 
--[ 2022.11.06.15.01.22.775.0 ]--
r 142                 if (above.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.25.887.0 ]--
+ 146                 
--[ 2022.11.06.15.01.26.231.0 ]--
r 146                 }
--[ 2022.11.06.15.01.26.244.0 ]--
r 143                     above.getCost(heuristic);
--[ 2022.11.06.15.01.26.247.0 ]--
r 144                     array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.01.26.249.0 ]--
r 144                     array[nextTile.currentTile.getI() -1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.01.26.251.0 ]--
r 144                     array[nextTile.currentTile.getI() - 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.01.26.253.0 ]--
r 145                     pq.insert(above);
--[ 2022.11.06.15.01.44.495.0 ]--
+ 151                 
--[ 2022.11.06.15.01.45.472.0 ]--
r 151                 if (above.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.48.339.0 ]--
r 151                 if (b.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.48.523.0 ]--
r 151                 if (bw.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.49.104.0 ]--
r 151                 if (b.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.49.189.0 ]--
r 151                 if (be.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.49.302.0 ]--
r 151                 if (bel.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.49.481.0 ]--
r 151                 if (belo.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.49.532.0 ]--
r 151                 if (below.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.52.563.0 ]--
+ 155                 
--[ 2022.11.06.15.01.52.946.0 ]--
r 155                 }
--[ 2022.11.06.15.01.52.957.0 ]--
r 152                     below.getCost(heuristic);
--[ 2022.11.06.15.01.52.959.0 ]--
r 153                     array[nextTile.currentTile.getI() + 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.01.52.961.0 ]--
r 154                     pq.insert(below);
--[ 2022.11.06.15.01.56.776.0 ]--
+ 160                 
--[ 2022.11.06.15.01.57.292.0 ]--
r 160                 if (above.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.59.390.0 ]--
r 160                 if (l.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.59.487.0 ]--
r 160                 if (le.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.59.588.0 ]--
r 160                 if (lef.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.01.59.760.0 ]--
r 160                 if (left.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.02.03.229.0 ]--
+ 164                 
--[ 2022.11.06.15.02.03.583.0 ]--
r 164                 }
--[ 2022.11.06.15.02.03.595.0 ]--
r 161                     array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1] = true;
--[ 2022.11.06.15.02.03.598.0 ]--
r 161                     array[nextTile.currentTile.getI()][nextTile.currentTile.getJ() -1] = true;
--[ 2022.11.06.15.02.03.600.0 ]--
r 161                     array[nextTile.currentTile.getI()][nextTile.currentTile.getJ() - 1] = true;
--[ 2022.11.06.15.02.03.602.0 ]--
r 162                     left.getCost(heuristic);
--[ 2022.11.06.15.02.03.604.0 ]--
r 163                     pq.insert(left);
--[ 2022.11.06.15.02.25.436.0 ]--
+ 169                 
--[ 2022.11.06.15.02.25.584.0 ]--
r 169                 if (above.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.02.28.539.0 ]--
r 169                 if (r.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.02.28.615.0 ]--
r 169                 if (ri.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.02.28.721.0 ]--
r 169                 if (rig.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.02.28.869.0 ]--
r 169                 if (righ.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.02.28.929.0 ]--
r 169                 if (right.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.02.33.688.0 ]--
+ 173                 
--[ 2022.11.06.15.02.34.046.0 ]--
r 173                 }
--[ 2022.11.06.15.02.34.059.0 ]--
r 170                     array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1] = true;
--[ 2022.11.06.15.02.34.061.0 ]--
r 170                     array[nextTile.currentTile.getI()][nextTile.currentTile.getJ() +1] = true;
--[ 2022.11.06.15.02.34.064.0 ]--
r 170                     array[nextTile.currentTile.getI()][nextTile.currentTile.getJ() + 1] = true;
--[ 2022.11.06.15.02.34.066.0 ]--
r 171                     right.getCost(heuristic);
--[ 2022.11.06.15.02.34.069.0 ]--
r 172                     pq.insert(right);
--[ 2022.11.06.15.02.37.827.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.03.20.470.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()].) {
--[ 2022.11.06.15.03.20.877.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()].i) {
--[ 2022.11.06.15.03.20.944.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()].is) {
--[ 2022.11.06.15.03.21.576.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()].i) {
--[ 2022.11.06.15.03.21.751.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()].) {
--[ 2022.11.06.15.03.22.650.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.03.786.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] ) {
--[ 2022.11.06.15.04.04.197.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] &) {
--[ 2022.11.06.15.04.04.317.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] &&) {
--[ 2022.11.06.15.04.04.578.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] && ) {
--[ 2022.11.06.15.04.07.902.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] &&) {
--[ 2022.11.06.15.04.08.076.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] &) {
--[ 2022.11.06.15.04.08.268.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()] ) {
--[ 2022.11.06.15.04.08.493.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.12.832.0 ]--
r 140             if (&!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.12.943.0 ]--
r 140             if (&&!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.13.570.0 ]--
r 140             if (&& !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.14.934.0 ]--
r 140             if ( && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.22.073.0 ]--
r 140             if (n && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.22.087.0 ]--
r 140             if (ne && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.22.308.0 ]--
r 140             if (nex && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.22.451.0 ]--
r 140             if (next && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.22.665.0 ]--
r 140             if (nextt && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.22.758.0 ]--
r 140             if (nextti && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.22.835.0 ]--
r 140             if (nexttil && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.22.935.0 ]--
r 140             if (nexttile && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.23.446.0 ]--
r 140             if (nexttil && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.26.764.0 ]--
r 140             if (nextti && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.27.154.0 ]--
r 140             if (nextt && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.27.353.0 ]--
r 140             if (next && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.29.026.0 ]--
r 140             if (nextT && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.29.294.0 ]--
r 140             if (nextTi && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.29.399.0 ]--
r 140             if (nextTil && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.29.501.0 ]--
r 140             if (nextTile && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.30.304.0 ]--
r 140             if (nextTile. && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.30.864.0 ]--
r 140             if (nextTile.c && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.30.967.0 ]--
r 140             if (nextTile.cu && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.31.106.0 ]--
r 140             if (nextTile.cur && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.31.254.0 ]--
r 140             if (nextTile.curr && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.31.427.0 ]--
r 140             if (nextTile.currentTile && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.32.091.0 ]--
r 140             if (nextTile.currentTile. && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.32.868.0 ]--
r 140             if (nextTile.currentTile.g && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.32.979.0 ]--
r 140             if (nextTile.currentTile.ge && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.34.453.0 ]--
r 140             if (nextTile.currentTile.getI && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.34.458.0 ]--
r 140             if (nextTile.currentTile.getI() && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.36.116.0 ]--
r 140             if (nextTile.currentTile.getI()- && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.36.659.0 ]--
r 140             if (nextTile.currentTile.getI()-1 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.38.279.0 ]--
r 140             if (nextTile.currentTile.getI()-1  && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.38.808.0 ]--
r 140             if (nextTile.currentTile.getI()-1 > && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.42.487.0 ]--
r 140             if (nextTile.currentTile.getI()-1 >= && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.42.727.0 ]--
r 140             if (nextTile.currentTile.getI()-1 >=  && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.42.840.0 ]--
r 140             if (nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.54.776.0 ]--
r 140             if (&nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.54.913.0 ]--
r 140             if (&&nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.55.291.0 ]--
r 140             if (&& nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.57.195.0 ]--
r 140             if ( && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.59.075.0 ]--
r 140             if (n && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.59.132.0 ]--
r 140             if (ne && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.59.307.0 ]--
r 140             if (nex && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.59.432.0 ]--
r 140             if (next && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.59.545.0 ]--
r 140             if (nexti && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.59.609.0 ]--
r 140             if (nextil && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.59.710.0 ]--
r 140             if (nextile && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.04.59.893.0 ]--
r 140             if (nextile. && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.00.729.0 ]--
r 140             if (nextile.c && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.00.819.0 ]--
r 140             if (nextile.cu && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.00.973.0 ]--
r 140             if (nextile.cur && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.01.189.0 ]--
r 140             if (nextTile.currentTile && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.01.194.0 ]--
r 140             if (nextTile; && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.01.204.0 ]--
r 140             if (nextTile.currentTile && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.02.374.0 ]--
r 140             if (nextTile.currentTile. && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.03.397.0 ]--
r 140             if (nextTile.currentTile.g && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.03.489.0 ]--
r 140             if (nextTile.currentTile.ge && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.04.924.0 ]--
r 140             if (nextTile.currentTile.getJ && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.04.929.0 ]--
r 140             if (nextTile.currentTile.getJ() && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.07.223.0 ]--
r 140             if (nextTile.currentTile.getJ()  && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.08.137.0 ]--
r 140             if (nextTile.currentTile.getJ() < && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.09.271.0 ]--
r 140             if (nextTile.currentTile.getJ()  && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.10.172.0 ]--
r 140             if (nextTile.currentTile.getJ() < && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.10.745.0 ]--
r 140             if (nextTile.currentTile.getJ() <= && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.11.137.0 ]--
r 140             if (nextTile.currentTile.getJ() <=  && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.11.356.0 ]--
r 140             if (nextTile.currentTile.getJ() <= N && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.44.848.0 ]--
r 140             if (nextTile.currentTile.getJ() <= (N && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.46.553.0 ]--
r 140             if (nextTile.currentTile.getJ() <= (N- && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.46.686.0 ]--
r 140             if (nextTile.currentTile.getJ() <= (N-1 && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.05.47.783.0 ]--
r 140             if (nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.06.20.461.0 ]--
r 149             if (nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()-1 >= 0 &&!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.06.22.000.0 ]--
r 149             if (nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.06.30.239.0 ]--
r 149             if (nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.06.30.731.0 ]--
r 149             if (nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.06.40.818.0 ]--
r 158             if ( !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.06.41.645.0 ]--
r 158             if (nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.06.48.094.0 ]--
r 158             if (nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()- >= 0 && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.06.48.289.0 ]--
r 158             if (nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI() >= 0 && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.06.51.445.0 ]--
r 158             if (nextTile.currentTile.getJ()- <= (N-1) && nextTile.currentTile.getI() >= 0 && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.06.51.610.0 ]--
r 158             if (nextTile.currentTile.getJ()-1 <= (N-1) && nextTile.currentTile.getI() >= 0 && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.06.56.509.0 ]--
r 167             if ( !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.06.57.663.0 ]--
r 167             if (nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()-1 >= 0 && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.07.03.684.0 ]--
r 167             if (nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()- >= 0 && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.07.03.846.0 ]--
r 167             if (nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI() >= 0 && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.07.06.573.0 ]--
r 167             if (nextTile.currentTile.getJ()+ <= (N-1) && nextTile.currentTile.getI() >= 0 && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.07.06.918.0 ]--
r 167             if (nextTile.currentTile.getJ()+1 <= (N-1) && nextTile.currentTile.getI() >= 0 && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.07.10.954.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.08.28.568.0 ]--
+ 196     
--[ 2022.11.06.15.08.29.089.0 ]--
+ 196     public boolean isInBounds(Coord min, Coord max) {
+ 197         return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
r 198     }
--[ 2022.11.06.15.08.46.559.0 ]--
r 197         return  >= min.i && i <= max.i && j >= min.j && j <= max.j;
--[ 2022.11.06.15.08.47.336.0 ]--
r 197         return g >= min.i && i <= max.i && j >= min.j && j <= max.j;
--[ 2022.11.06.15.08.47.479.0 ]--
r 197         return ge >= min.i && i <= max.i && j >= min.j && j <= max.j;
--[ 2022.11.06.15.08.47.575.0 ]--
r 197         return get >= min.i && i <= max.i && j >= min.j && j <= max.j;
--[ 2022.11.06.15.08.48.507.0 ]--
r 197         return ge >= min.i && i <= max.i && j >= min.j && j <= max.j;
--[ 2022.11.06.15.08.48.706.0 ]--
r 197         return g >= min.i && i <= max.i && j >= min.j && j <= max.j;
--[ 2022.11.06.15.08.49.657.0 ]--
r 197         return  >= min.i && i <= max.i && j >= min.j && j <= max.j;
--[ 2022.11.06.15.08.51.334.0 ]--
r 197         return get >= min.i && i <= max.i && j >= min.j && j <= max.j;
--[ 2022.11.06.15.08.52.131.0 ]--
r 197         return  >= min.i && i <= max.i && j >= min.j && j <= max.j;
--[ 2022.11.06.15.08.52.516.0 ]--
r 197         return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
--[ 2022.11.06.15.09.34.204.0 ]--
- 196
- 196
r 196     
--[ 2022.11.06.15.09.34.641.0 ]--
- 196
--[ 2022.11.06.15.10.11.420.0 ]--
r 140             if (!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.10.15.222.0 ]--
r 140             if (&!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.10.15.380.0 ]--
r 140             if (&&!array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.10.15.836.0 ]--
r 140             if (&& !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.05.883.0 ]--
r 140             if ( && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.51.170.0 ]--
r 140             if (C && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.51.363.0 ]--
r 140             if (Co && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.51.645.0 ]--
r 140             if (Coo && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.51.779.0 ]--
r 140             if (Coor && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.52.200.0 ]--
r 140             if (Coord && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.52.829.0 ]--
r 140             if (Coord() && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.54.390.0 ]--
r 140             if (Coord(n) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.54.468.0 ]--
r 140             if (Coord(ne) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.54.747.0 ]--
r 140             if (Coord(net) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.54.881.0 ]--
r 140             if (Coord(neti) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.54.986.0 ]--
r 140             if (Coord(netil) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.55.264.0 ]--
r 140             if (Coord(neti) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.55.422.0 ]--
r 140             if (Coord(net) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.55.585.0 ]--
r 140             if (Coord(ne) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.55.674.0 ]--
r 140             if (Coord(nex) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.55.744.0 ]--
r 140             if (Coord(next) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.55.880.0 ]--
r 140             if (Coord(nexti) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.55.994.0 ]--
r 140             if (Coord(nextie) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.57.253.0 ]--
r 140             if (Coord(nexti) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.57.431.0 ]--
r 140             if (Coord(next) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.57.573.0 ]--
r 140             if (Coord(nex) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.57.685.0 ]--
r 140             if (Coord(ne) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.57.808.0 ]--
r 140             if (Coord(n) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.57.947.0 ]--
r 140             if (Coord() && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.58.081.0 ]--
r 140             if (Coord && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.58.189.0 ]--
r 140             if (Coor && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.58.345.0 ]--
r 140             if (Coo && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.58.473.0 ]--
r 140             if (Co && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.58.614.0 ]--
r 140             if (C && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.11.58.746.0 ]--
r 140             if ( && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.07.897.0 ]--
r 140             if ( Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ())&& !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.09.981.0 ]--
r 140             if ( Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.12.892.0 ]--
r 140             if ( Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()). && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.13.421.0 ]--
r 140             if ( Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).i && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.13.503.0 ]--
r 140             if ( Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).is && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.13.908.0 ]--
r 140             if ( Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).i && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.14.075.0 ]--
r 140             if ( Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()). && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.14.251.0 ]--
r 140             if ( Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.14.425.0 ]--
r 140             if ( Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ() && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.15.644.0 ]--
r 140             if ( Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.27.135.0 ]--
r 140             if ( && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.34.818.0 ]--
r 140             if (Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.40.027.0 ]--
r 140             if (nCoord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.40.077.0 ]--
r 140             if (neCoord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.40.160.0 ]--
r 140             if (newCoord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.40.259.0 ]--
r 140             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.42.327.0 ]--
r 140             if (newCoord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.42.436.0 ]--
r 140             if (neCoord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.42.651.0 ]--
r 140             if (nCoord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.42.871.0 ]--
r 140             if (Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.47.294.0 ]--
r 140             if (Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()). && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.47.458.0 ]--
r 140             if (Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).i && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.47.519.0 ]--
r 140             if (Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).is && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.48.178.0 ]--
r 140             if (Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).i && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.48.348.0 ]--
r 140             if (Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()). && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.12.48.523.0 ]--
r 140             if (Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.13.06.918.0 ]--
r 140             if (Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()). && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.13.08.890.0 ]--
r 140             if (Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.13.14.468.0 ]--
r 140             if (nCoord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.13.14.530.0 ]--
r 140             if (neCoord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.13.14.659.0 ]--
r 140             if (newCoord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.13.14.745.0 ]--
r 140             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.13.17.538.0 ]--
r 140             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()). && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.13.20.231.0 ]--
r 140             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.13.20.238.0 ]--
r 140             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds() && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.13.36.217.0 ]--
+ 12     
--[ 2022.11.06.15.13.37.020.0 ]--
r 12     c
--[ 2022.11.06.15.13.37.242.0 ]--
r 12     co
--[ 2022.11.06.15.13.37.360.0 ]--
r 12     coo
--[ 2022.11.06.15.13.37.466.0 ]--
r 12     coor
--[ 2022.11.06.15.13.37.572.0 ]--
r 12     coord
--[ 2022.11.06.15.13.38.020.0 ]--
r 12     coor
--[ 2022.11.06.15.13.38.174.0 ]--
r 12     coo
--[ 2022.11.06.15.13.38.349.0 ]--
r 12     co
--[ 2022.11.06.15.13.38.516.0 ]--
r 12     c
--[ 2022.11.06.15.13.38.687.0 ]--
r 12     
--[ 2022.11.06.15.13.38.805.0 ]--
r 12     C
--[ 2022.11.06.15.13.39.063.0 ]--
r 12     Co
--[ 2022.11.06.15.13.39.191.0 ]--
r 12     Coo
--[ 2022.11.06.15.13.39.294.0 ]--
r 12     Coor
--[ 2022.11.06.15.13.39.376.0 ]--
r 12     Coord
--[ 2022.11.06.15.13.40.974.0 ]--
r 12     Coord 
--[ 2022.11.06.15.13.41.153.0 ]--
r 12     Coord m
--[ 2022.11.06.15.13.41.261.0 ]--
r 12     Coord ma
--[ 2022.11.06.15.13.41.454.0 ]--
r 12     Coord max
--[ 2022.11.06.15.13.41.719.0 ]--
r 12     Coord max,
--[ 2022.11.06.15.13.41.836.0 ]--
r 12     Coord max, 
--[ 2022.11.06.15.13.42.215.0 ]--
r 12     Coord max, m
--[ 2022.11.06.15.13.42.350.0 ]--
r 12     Coord max, mi
--[ 2022.11.06.15.13.42.448.0 ]--
r 12     Coord max, min
--[ 2022.11.06.15.13.42.837.0 ]--
r 12     Coord max, min;
--[ 2022.11.06.15.13.55.655.0 ]--
+ 99         
--[ 2022.11.06.15.13.57.487.0 ]--
r 99         m
--[ 2022.11.06.15.13.57.596.0 ]--
r 99         ma
--[ 2022.11.06.15.13.57.839.0 ]--
r 99         max
--[ 2022.11.06.15.13.58.424.0 ]--
r 99         max 
--[ 2022.11.06.15.13.58.552.0 ]--
r 99         max =
--[ 2022.11.06.15.13.58.680.0 ]--
r 99         max = 
--[ 2022.11.06.15.14.01.608.0 ]--
r 99         max = n
--[ 2022.11.06.15.14.01.660.0 ]--
r 99         max = ne
--[ 2022.11.06.15.14.01.750.0 ]--
r 99         max = new
--[ 2022.11.06.15.14.01.865.0 ]--
r 99         max = new 
--[ 2022.11.06.15.14.02.064.0 ]--
r 99         max = new C
--[ 2022.11.06.15.14.02.190.0 ]--
r 99         max = new Co
--[ 2022.11.06.15.14.02.325.0 ]--
r 99         max = new Coo
--[ 2022.11.06.15.14.02.450.0 ]--
r 99         max = new Coor
--[ 2022.11.06.15.14.02.542.0 ]--
r 99         max = new Coord
--[ 2022.11.06.15.14.02.910.0 ]--
r 99         max = new Coord()
--[ 2022.11.06.15.14.04.551.0 ]--
r 99         max = new Coord(N)
--[ 2022.11.06.15.14.04.814.0 ]--
r 99         max = new Coord(N,)
--[ 2022.11.06.15.14.05.073.0 ]--
r 99         max = new Coord(N,N)
--[ 2022.11.06.15.14.05.483.0 ]--
r 99         max = new Coord(N,Nj)
--[ 2022.11.06.15.14.06.335.0 ]--
r 99         max = new Coord(N,N)
--[ 2022.11.06.15.14.07.074.0 ]--
r 99         max = new Coord(N,N);
--[ 2022.11.06.15.14.07.703.0 ]--
+ 100         
--[ 2022.11.06.15.14.08.618.0 ]--
r 100         m
--[ 2022.11.06.15.14.08.713.0 ]--
r 100         mi
--[ 2022.11.06.15.14.08.801.0 ]--
r 100         min
--[ 2022.11.06.15.14.09.134.0 ]--
r 100         min 
--[ 2022.11.06.15.14.09.302.0 ]--
r 100         min =
--[ 2022.11.06.15.14.09.413.0 ]--
r 100         min = 
--[ 2022.11.06.15.14.09.816.0 ]--
r 100         min = n
--[ 2022.11.06.15.14.09.898.0 ]--
r 100         min = ne
--[ 2022.11.06.15.14.09.963.0 ]--
r 100         min = new
--[ 2022.11.06.15.14.10.101.0 ]--
r 100         min = new 
--[ 2022.11.06.15.14.10.308.0 ]--
r 100         min = new C
--[ 2022.11.06.15.14.10.477.0 ]--
r 100         min = new Co
--[ 2022.11.06.15.14.10.613.0 ]--
r 100         min = new Coo
--[ 2022.11.06.15.14.10.710.0 ]--
r 100         min = new Coor
--[ 2022.11.06.15.14.10.800.0 ]--
r 100         min = new Coord
--[ 2022.11.06.15.14.11.341.0 ]--
r 100         min = new Coord()
--[ 2022.11.06.15.14.12.098.0 ]--
r 100         min = new Coord(0)
--[ 2022.11.06.15.14.12.459.0 ]--
r 100         min = new Coord(0.)
--[ 2022.11.06.15.14.13.224.0 ]--
r 100         min = new Coord(0)
--[ 2022.11.06.15.14.13.578.0 ]--
r 100         min = new Coord(0,)
--[ 2022.11.06.15.14.13.681.0 ]--
r 100         min = new Coord(0,0)
--[ 2022.11.06.15.14.15.543.0 ]--
r 100         min = new Coord(0,0);
--[ 2022.11.06.15.14.25.644.0 ]--
r 143             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds(m) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.25.760.0 ]--
r 143             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds(mi) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.25.850.0 ]--
r 143             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds(min) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.26.047.0 ]--
r 143             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds(min,) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.26.367.0 ]--
r 143             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds(min, ) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.26.482.0 ]--
r 143             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds(min, m) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.26.563.0 ]--
r 143             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds(min, ma) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.26.750.0 ]--
r 143             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds(min, max) && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.34.400.0 ]--
+ 143             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds(min, max) 
r 144             && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.34.416.0 ]--
r 144                     && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.37.686.0 ]--
r 143             if (new Coord(nextTile.currentTile.getI()-1, nextTile.currentTile.getJ()).isInBounds(min, max)
--[ 2022.11.06.15.14.50.882.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ())nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.53.209.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()) nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.53.874.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()) &nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.54.006.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()) &&nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.54.231.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()) && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.57.578.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()). && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.57.742.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).s && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.59.239.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.14.59.244.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds() && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.15.00.298.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds(m) && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.15.00.395.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds(mi) && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.15.00.505.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min) && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.15.00.736.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,) && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.15.00.921.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,m) && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.15.01.045.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,ma) && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.15.01.226.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max) && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.15.04.239.0 ]--
+ 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max) 
r 154             && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.15.04.266.0 ]--
r 154                     && nextTile.currentTile.getJ() <= (N-1) && nextTile.currentTile.getI()+1 >= 0 && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.15.14.934.0 ]--
r 154                     && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.15.16.466.0 ]--
r 153             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.15.22.411.0 ]--
r 163             if ( !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.31.434.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1) !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.33.194.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1). !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.33.380.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).i !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.33.427.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).is !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.34.426.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.34.432.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds() !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.35.235.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(m) !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.35.365.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(mi) !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.35.456.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(min) !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.35.720.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(min,) !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.35.872.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(min,m) !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.36.000.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(min,ma) !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.36.166.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(min,max) !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.40.502.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(min,max) &!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.40.655.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(min,max) &&!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.41.623.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(min,max) && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.42.944.0 ]--
+ 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(min,max) 
r 164             && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.42.960.0 ]--
r 164                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.15.44.560.0 ]--
r 163             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-1).isInBounds(min,max)
--[ 2022.11.06.15.15.55.830.0 ]--
r 173             if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.08.822.0 ]--
r 173             if (&!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.08.945.0 ]--
r 173             if (&&!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.09.741.0 ]--
r 173             if (&& !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.11.491.0 ]--
r 173             if ( && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.12.169.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1) && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.14.329.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1). && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.14.597.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).i && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.14.706.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).is && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.15.368.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.15.373.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds() && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.16.023.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds(m) && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.16.122.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds(mi) && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.16.212.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds(min) && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.16.407.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds(min,) && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.16.629.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds(min,m) && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.16.730.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds(min,ma) && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.16.913.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds(min,max) && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.19.111.0 ]--
+ 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds(min,max) 
r 174             && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.19.124.0 ]--
r 174                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.16.20.157.0 ]--
r 173             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds(min,max)
--[ 2022.11.06.15.16.25.032.0 ]--
r 176                 
--[ 2022.11.06.15.16.25.578.0 ]--
- 176
--[ 2022.11.06.15.16.27.313.0 ]--
r 179                 
--[ 2022.11.06.15.16.27.770.0 ]--
- 179
--[ 2022.11.06.15.16.31.393.0 ]--
r 176                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ() + 1] = true;
r 177                 right.getCost(heuristic);
r 178                 pq.insert(right);
--[ 2022.11.06.15.16.35.269.0 ]--
r 170                 
--[ 2022.11.06.15.16.36.300.0 ]--
- 170
--[ 2022.11.06.15.16.36.516.0 ]--
r 169                     pq.insert(left)
--[ 2022.11.06.15.16.37.851.0 ]--
r 169                     pq.insert(left);
--[ 2022.11.06.15.16.42.012.0 ]--
r 166                
--[ 2022.11.06.15.16.42.412.0 ]--
- 166
--[ 2022.11.06.15.16.46.264.0 ]--
r 166                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ() - 1] = true;
r 167                 left.getCost(heuristic);
r 168                 pq.insert(left);
--[ 2022.11.06.15.16.51.323.0 ]--
r 160                 
--[ 2022.11.06.15.16.51.535.0 ]--
- 160
--[ 2022.11.06.15.16.59.620.0 ]--
r 156                 
--[ 2022.11.06.15.16.59.855.0 ]--
- 156
--[ 2022.11.06.15.17.03.826.0 ]--
r 156                 below.getCost(heuristic);
r 157                 array[nextTile.currentTile.getI() + 1][nextTile.currentTile.getJ()] = true;
r 158                 pq.insert(below);
--[ 2022.11.06.15.17.09.543.0 ]--
r 147                 above.getCost(heuristic);
r 148                 array[nextTile.currentTile.getI() - 1][nextTile.currentTile.getJ()] = true;
r 149                 pq.insert(above);
--[ 2022.11.06.15.17.10.885.0 ]--
r 150                 
--[ 2022.11.06.15.17.11.069.0 ]--
- 150
--[ 2022.11.06.15.17.16.947.0 ]--
r 146                 
--[ 2022.11.06.15.17.17.457.0 ]--
- 146
--[ 2022.11.06.15.17.20.812.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.20.29.718.0 ]--
r 168                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+]) {
--[ 2022.11.06.15.20.30.013.0 ]--
r 168                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.20.35.414.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.20.50.685.0 ]--
r 152                     && !array[nextTile.currentTile.getI()+][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.20.50.983.0 ]--
r 152                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.20.56.100.0 ]--
r 144                     && !array[nextTile.currentTile.getI()-][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.20.56.279.0 ]--
r 144                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.21.01.951.0 ]--
r 160                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-]) {
--[ 2022.11.06.15.21.02.113.0 ]--
r 160                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.21.04.623.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.22.16.696.0 ]--
r 160                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.22.17.960.0 ]--
r 144                     && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.22.18.896.0 ]--
r 152                     && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.22.19.852.0 ]--
r 168                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.22.22.878.0 ]--
+ 146                 if (above.currentTile.isInBounds(new Coord(0,0), new Coord(N, N))) {
--[ 2022.11.06.15.22.24.748.0 ]--
r 146                 
--[ 2022.11.06.15.22.25.216.0 ]--
- 146
--[ 2022.11.06.15.23.21.176.0 ]--
+ 109         
--[ 2022.11.06.15.23.21.953.0 ]--
r 109         a
--[ 2022.11.06.15.23.22.157.0 ]--
r 109         ar
--[ 2022.11.06.15.23.22.279.0 ]--
r 109         arr
--[ 2022.11.06.15.23.22.461.0 ]--
r 109         arra
--[ 2022.11.06.15.23.22.551.0 ]--
r 109         array
--[ 2022.11.06.15.23.23.747.0 ]--
r 109         arrayp
--[ 2022.11.06.15.23.24.335.0 ]--
r 109         array
--[ 2022.11.06.15.23.25.066.0 ]--
r 109         array[]
--[ 2022.11.06.15.23.26.448.0 ]--
r 109         array[][]
--[ 2022.11.06.15.23.27.865.0 ]--
r 109         array[][] 
--[ 2022.11.06.15.23.28.067.0 ]--
r 109         array[][] =
--[ 2022.11.06.15.23.28.174.0 ]--
r 109         array[][] = 
--[ 2022.11.06.15.23.28.544.0 ]--
r 109         array[][] = t
--[ 2022.11.06.15.23.28.676.0 ]--
r 109         array[][] = tr
--[ 2022.11.06.15.23.28.796.0 ]--
r 109         array[][] = tru
--[ 2022.11.06.15.23.28.878.0 ]--
r 109         array[][] = true
--[ 2022.11.06.15.23.29.731.0 ]--
r 109         array[][] = true;
--[ 2022.11.06.15.23.38.892.0 ]--
r 109         array[l][] = true;
--[ 2022.11.06.15.23.39.061.0 ]--
r 109         array[lo][] = true;
--[ 2022.11.06.15.23.39.150.0 ]--
r 109         array[loc][] = true;
--[ 2022.11.06.15.23.42.069.0 ]--
r 109         array[loc.][] = true;
--[ 2022.11.06.15.23.42.615.0 ]--
r 109         array[loc.i][] = true;
--[ 2022.11.06.15.23.45.080.0 ]--
r 109         array[loc.getI][] = true;
--[ 2022.11.06.15.23.45.084.0 ]--
r 109         array[loc.getI()][] = true;
--[ 2022.11.06.15.23.46.367.0 ]--
r 109         array[loc.getI()][l] = true;
--[ 2022.11.06.15.23.46.570.0 ]--
r 109         array[loc.getI()][lo] = true;
--[ 2022.11.06.15.23.46.675.0 ]--
r 109         array[loc.getI()][loc] = true;
--[ 2022.11.06.15.23.46.869.0 ]--
r 109         array[loc.getI()][loc.] = true;
--[ 2022.11.06.15.23.47.198.0 ]--
r 109         array[loc.getI()][loc.g] = true;
--[ 2022.11.06.15.23.47.318.0 ]--
r 109         array[loc.getI()][loc.ge] = true;
--[ 2022.11.06.15.23.47.889.0 ]--
r 109         array[loc.getI()][loc.getJ] = true;
--[ 2022.11.06.15.23.47.893.0 ]--
r 109         array[loc.getI()][loc.getJ()] = true;
--[ 2022.11.06.15.23.57.546.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.24.21.101.0 ]--
+ 168             
--[ 2022.11.06.15.24.23.870.0 ]--
r 168             s
--[ 2022.11.06.15.24.23.964.0 ]--
r 168             so
--[ 2022.11.06.15.24.24.052.0 ]--
r 168             sou
--[ 2022.11.06.15.24.24.129.0 ]--
r 168             sout
--[ 2022.11.06.15.24.24.223.0 ]--
r 168             System.out.println();
--[ 2022.11.06.15.24.25.071.0 ]--
r 168             System.out.println("");
--[ 2022.11.06.15.24.26.226.0 ]--
r 168             System.out.println("R");
--[ 2022.11.06.15.24.26.347.0 ]--
r 168             System.out.println("Ri");
--[ 2022.11.06.15.24.26.461.0 ]--
r 168             System.out.println("Rig");
--[ 2022.11.06.15.24.26.470.0 ]--
r 168             System.out.println("Rigf");
--[ 2022.11.06.15.24.26.621.0 ]--
r 168             System.out.println("Rigfh");
--[ 2022.11.06.15.24.26.700.0 ]--
r 168             System.out.println("Rigfht");
--[ 2022.11.06.15.24.27.051.0 ]--
r 168             System.out.println("Rigfh");
--[ 2022.11.06.15.24.27.225.0 ]--
r 168             System.out.println("Rigf");
--[ 2022.11.06.15.24.27.359.0 ]--
r 168             System.out.println("Rig");
--[ 2022.11.06.15.24.27.459.0 ]--
r 168             System.out.println("Righ");
--[ 2022.11.06.15.24.27.584.0 ]--
r 168             System.out.println("Right");
--[ 2022.11.06.15.24.27.908.0 ]--
r 168             System.out.println("Right:");
--[ 2022.11.06.15.24.28.153.0 ]--
r 168             System.out.println("Right: ");
--[ 2022.11.06.15.24.28.748.0 ]--
r 168             System.out.println("Right:");
--[ 2022.11.06.15.24.28.912.0 ]--
r 168             System.out.println("Right");
--[ 2022.11.06.15.24.29.223.0 ]--
r 168             System.out.println("Right ");
--[ 2022.11.06.15.24.29.391.0 ]--
r 168             System.out.println("Right C");
--[ 2022.11.06.15.24.29.551.0 ]--
r 168             System.out.println("Right Co");
--[ 2022.11.06.15.24.29.692.0 ]--
r 168             System.out.println("Right Coo");
--[ 2022.11.06.15.24.29.801.0 ]--
r 168             System.out.println("Right Coor");
--[ 2022.11.06.15.24.29.916.0 ]--
r 168             System.out.println("Right Coord");
--[ 2022.11.06.15.24.30.273.0 ]--
r 168             System.out.println("Right Coords");
--[ 2022.11.06.15.24.30.939.0 ]--
r 168             System.out.println("Right Coords:");
--[ 2022.11.06.15.24.31.094.0 ]--
r 168             System.out.println("Right Coords: ");
--[ 2022.11.06.15.24.31.444.0 ]--
r 168             System.out.println("Right Coords: " );
--[ 2022.11.06.15.24.31.677.0 ]--
r 168             System.out.println("Right Coords: " +);
--[ 2022.11.06.15.24.31.818.0 ]--
r 168             System.out.println("Right Coords: " + );
--[ 2022.11.06.15.24.40.413.0 ]--
r 168             System.out.println("Right Coords: " +nextTile.currentTile.getI() );
--[ 2022.11.06.15.24.43.249.0 ]--
r 168             System.out.println("Right Coords: " +nextTile.currentTile.getI()  );
--[ 2022.11.06.15.24.43.430.0 ]--
r 168             System.out.println("Right Coords: " +nextTile.currentTile.getI() "" );
--[ 2022.11.06.15.24.43.535.0 ]--
r 168             System.out.println("Right Coords: " +nextTile.currentTile.getI() " " );
--[ 2022.11.06.15.24.43.699.0 ]--
r 168             System.out.println("Right Coords: " +nextTile.currentTile.getI() " =" );
--[ 2022.11.06.15.24.44.262.0 ]--
r 168             System.out.println("Right Coords: " +nextTile.currentTile.getI() " " );
--[ 2022.11.06.15.24.45.199.0 ]--
r 168             System.out.println("Right Coords: " +nextTile.currentTile.getI() " \" );
--[ 2022.11.06.15.24.45.332.0 ]--
r 168             System.out.println("Right Coords: " +nextTile.currentTile.getI() " \n" );
--[ 2022.11.06.15.24.47.923.0 ]--
r 168             System.out.println("Right Coords: " +nextTile.currentTile.getI() " \n " );
--[ 2022.11.06.15.24.57.274.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n " );
--[ 2022.11.06.15.25.00.773.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y" );
--[ 2022.11.06.15.25.01.499.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y:" );
--[ 2022.11.06.15.25.01.635.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y: " );
--[ 2022.11.06.15.25.02.248.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y: +" );
--[ 2022.11.06.15.25.02.706.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y: " );
--[ 2022.11.06.15.25.03.475.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y:  " );
--[ 2022.11.06.15.25.04.675.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y: " );
--[ 2022.11.06.15.25.05.247.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y: "  );
--[ 2022.11.06.15.25.05.740.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y: " + );
--[ 2022.11.06.15.25.05.851.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y: " +  );
--[ 2022.11.06.15.25.14.831.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y: " + nextTile.currentTile.getJ()+1 );
--[ 2022.11.06.15.25.17.202.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() " \n Y: " + nextTile.currentTile.getJ()+1);
--[ 2022.11.06.15.25.23.266.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +" \n Y: " + nextTile.currentTile.getJ()+1);
--[ 2022.11.06.15.25.26.200.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.getJ()+1);
--[ 2022.11.06.15.25.29.314.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.27.00.460.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.getJ()+);
--[ 2022.11.06.15.27.00.644.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.getJ());
--[ 2022.11.06.15.27.03.479.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.27.42.194.0 ]--
+ 171                 
--[ 2022.11.06.15.27.43.415.0 ]--
r 171                 s
--[ 2022.11.06.15.27.43.558.0 ]--
r 171                 so
--[ 2022.11.06.15.27.43.636.0 ]--
r 171                 sou
--[ 2022.11.06.15.27.43.710.0 ]--
r 171                 soul
--[ 2022.11.06.15.27.43.754.0 ]--
r 171                 soult
--[ 2022.11.06.15.27.43.841.0 ]--
+ 172                 
--[ 2022.11.06.15.27.43.851.0 ]--
r 172                         
--[ 2022.11.06.15.27.44.443.0 ]--
- 172
--[ 2022.11.06.15.27.44.599.0 ]--
r 171                 soul
--[ 2022.11.06.15.27.44.773.0 ]--
r 171                 sou
--[ 2022.11.06.15.27.45.274.0 ]--
r 171                 sout
--[ 2022.11.06.15.27.45.376.0 ]--
r 171                 System.out.println();
--[ 2022.11.06.15.27.46.203.0 ]--
r 171                 System.out.println("");
--[ 2022.11.06.15.27.46.418.0 ]--
r 171                 System.out.println("T");
--[ 2022.11.06.15.27.46.559.0 ]--
r 171                 System.out.println("Te");
--[ 2022.11.06.15.27.46.698.0 ]--
r 171                 System.out.println("Tes");
--[ 2022.11.06.15.27.46.772.0 ]--
r 171                 System.out.println("Test");
--[ 2022.11.06.15.27.48.966.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.30.56.569.0 ]--
+ 103         
--[ 2022.11.06.15.30.57.086.0 ]--
r 103         a
--[ 2022.11.06.15.30.57.236.0 ]--
r 103         ar
--[ 2022.11.06.15.30.57.368.0 ]--
r 103         arr
--[ 2022.11.06.15.30.57.399.0 ]--
r 103         arra
--[ 2022.11.06.15.30.57.504.0 ]--
r 103         array
--[ 2022.11.06.15.30.57.792.0 ]--
r 103         array.
--[ 2022.11.06.15.30.58.076.0 ]--
r 103         array.l
--[ 2022.11.06.15.30.58.233.0 ]--
r 103         array.le
--[ 2022.11.06.15.31.01.241.0 ]--
r 103         array.l
--[ 2022.11.06.15.31.01.589.0 ]--
r 103         array.
--[ 2022.11.06.15.31.02.008.0 ]--
r 103         array.i
--[ 2022.11.06.15.31.02.082.0 ]--
r 103         array.is
--[ 2022.11.06.15.31.02.779.0 ]--
r 103         array.i
--[ 2022.11.06.15.31.02.931.0 ]--
r 103         array.
--[ 2022.11.06.15.31.03.188.0 ]--
r 103         array.b
--[ 2022.11.06.15.31.03.294.0 ]--
r 103         array.bo
--[ 2022.11.06.15.31.03.345.0 ]--
r 103         array.bou
--[ 2022.11.06.15.31.03.814.0 ]--
r 103         array.bo
--[ 2022.11.06.15.31.03.954.0 ]--
r 103         array.b
--[ 2022.11.06.15.31.04.135.0 ]--
r 103         array.
--[ 2022.11.06.15.31.04.309.0 ]--
r 103         array
--[ 2022.11.06.15.31.04.493.0 ]--
r 103         arra
--[ 2022.11.06.15.31.04.675.0 ]--
r 103         arr
--[ 2022.11.06.15.31.04.831.0 ]--
r 103         ar
--[ 2022.11.06.15.31.05.013.0 ]--
r 103         a
--[ 2022.11.06.15.31.05.190.0 ]--
r 103         
--[ 2022.11.06.15.31.08.348.0 ]--
- 103
--[ 2022.11.06.15.31.32.859.0 ]--
r 153                     && ) {
--[ 2022.11.06.15.31.34.126.0 ]--
r 153                     &&) {
--[ 2022.11.06.15.31.34.297.0 ]--
r 153                     &) {
--[ 2022.11.06.15.31.34.458.0 ]--
r 153                     ) {
--[ 2022.11.06.15.31.34.664.0 ]--
r 153             ) {
--[ 2022.11.06.15.31.34.932.0 ]--
- 152
r 152             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max)) {
--[ 2022.11.06.15.31.37.472.0 ]--
+ 153                 
--[ 2022.11.06.15.31.38.163.0 ]--
r 153                 i
--[ 2022.11.06.15.31.38.233.0 ]--
r 153                 if
--[ 2022.11.06.15.31.39.289.0 ]--
r 153                 if ()
--[ 2022.11.06.15.31.41.037.0 ]--
r 153                 if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()])
--[ 2022.11.06.15.31.44.910.0 ]--
r 153                 if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) 
--[ 2022.11.06.15.31.45.145.0 ]--
r 153                 if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.31.47.558.0 ]--
+ 158                 
--[ 2022.11.06.15.31.47.911.0 ]--
r 158                 }
--[ 2022.11.06.15.31.47.923.0 ]--
r 154                     PFNode below = new PFNode(new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.15.31.47.926.0 ]--
r 155                     below.getCost(heuristic);
--[ 2022.11.06.15.31.47.928.0 ]--
r 156                     array[nextTile.currentTile.getI() + 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.31.47.930.0 ]--
r 157                     pq.insert(below);
--[ 2022.11.06.15.31.50.720.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.32.16.151.0 ]--
r 171                     && ) {
--[ 2022.11.06.15.32.17.124.0 ]--
r 171                     &&) {
--[ 2022.11.06.15.32.17.280.0 ]--
r 171                     &) {
--[ 2022.11.06.15.32.17.439.0 ]--
r 171                     ) {
--[ 2022.11.06.15.32.17.653.0 ]--
r 171             ) {
--[ 2022.11.06.15.32.18.054.0 ]--
- 170
r 170             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds(min,max)) {
--[ 2022.11.06.15.32.20.032.0 ]--
+ 171                 
--[ 2022.11.06.15.32.20.627.0 ]--
r 171                 i
--[ 2022.11.06.15.32.20.717.0 ]--
r 171                 if
--[ 2022.11.06.15.32.21.263.0 ]--
r 171                 if ()
--[ 2022.11.06.15.32.22.204.0 ]--
r 171                 if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1])
--[ 2022.11.06.15.32.23.956.0 ]--
r 171                 if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) 
--[ 2022.11.06.15.32.24.276.0 ]--
r 171                 if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.32.26.474.0 ]--
+ 177                 
--[ 2022.11.06.15.32.26.801.0 ]--
r 177                 }
--[ 2022.11.06.15.32.26.815.0 ]--
r 172                     System.out.println("Test");
--[ 2022.11.06.15.32.26.818.0 ]--
r 173                     PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
--[ 2022.11.06.15.32.26.820.0 ]--
r 173                     PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ() +1), nextTile);
--[ 2022.11.06.15.32.26.822.0 ]--
r 173                     PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ() + 1), nextTile);
--[ 2022.11.06.15.32.26.824.0 ]--
r 174                     array[nextTile.currentTile.getI()][nextTile.currentTile.getJ() + 1] = true;
--[ 2022.11.06.15.32.26.826.0 ]--
r 175                     right.getCost(heuristic);
--[ 2022.11.06.15.32.26.827.0 ]--
r 176                     pq.insert(right);
--[ 2022.11.06.15.32.29.329.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.32.41.166.0 ]--
r 172                 System.out.println("Test");
r 173                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1), nextTile);
r 174                 array[nextTile.currentTile.getI()][nextTile.currentTile.getJ() + 1] = true;
r 175                 right.getCost(heuristic);
r 176                 pq.insert(right);
--[ 2022.11.06.15.32.41.517.0 ]--
r 177                 
--[ 2022.11.06.15.32.41.869.0 ]--
- 177
--[ 2022.11.06.15.32.42.456.0 ]--
r 171                 if (!array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1])
--[ 2022.11.06.15.32.43.137.0 ]--
r 171                 if ()
--[ 2022.11.06.15.32.43.476.0 ]--
r 171                 if
--[ 2022.11.06.15.32.43.803.0 ]--
r 171                 
--[ 2022.11.06.15.32.44.071.0 ]--
- 171
--[ 2022.11.06.15.32.44.825.0 ]--
+ 170             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()+1).isInBounds(min,max)
r 171                     && ) {
--[ 2022.11.06.15.32.45.327.0 ]--
r 171                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()+1]) {
--[ 2022.11.06.15.32.46.731.0 ]--
r 154                 PFNode below = new PFNode(new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()), nextTile);
r 155                 below.getCost(heuristic);
r 156                 array[nextTile.currentTile.getI() + 1][nextTile.currentTile.getJ()] = true;
r 157                 pq.insert(below);
--[ 2022.11.06.15.32.47.640.0 ]--
r 158                 
--[ 2022.11.06.15.32.48.063.0 ]--
- 158
--[ 2022.11.06.15.32.49.454.0 ]--
r 153                 if (!array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()])
--[ 2022.11.06.15.32.50.290.0 ]--
r 153                 if ()
--[ 2022.11.06.15.32.50.661.0 ]--
r 153                 if
--[ 2022.11.06.15.32.51.013.0 ]--
r 153                 
--[ 2022.11.06.15.32.51.391.0 ]--
- 153
--[ 2022.11.06.15.32.52.468.0 ]--
+ 152             if (new Coord(nextTile.currentTile.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max)
r 153                     && ) {
--[ 2022.11.06.15.32.53.031.0 ]--
r 153                     && !array[nextTile.currentTile.getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.33.52.391.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.getJ()+);
--[ 2022.11.06.15.33.53.031.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.getJ()+1);
--[ 2022.11.06.15.33.55.858.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.38.00.699.0 ]--
r 145                     && !array[nextTile.currentTile.getI().-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.00.701.0 ]--
UpdateTree (AD): 1 0
+ /P04_Pathfinding.zip

--[ 2022.11.06.15.38.01.493.0 ]--
r 145                     && !array[nextTile.currentTile.getI().a-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.02.238.0 ]--
r 145                     && !array[nextTile.currentTile.getI().-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.02.674.0 ]--
r 145                     && !array[nextTile.currentTile.getI()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.06.501.0 ]--
r 145                     && !array[nextTile.currentTile.getI(-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.06.976.0 ]--
r 145                     && !array[nextTile.currentTile.getI-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.07.181.0 ]--
r 145                     && !array[nextTile.currentTile.get-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.07.387.0 ]--
r 145                     && !array[nextTile.currentTile.ge-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.07.570.0 ]--
r 145                     && !array[nextTile.currentTile.g-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.07.803.0 ]--
r 145                     && !array[nextTile.currentTile.-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.08.203.0 ]--
r 145                     && !array[nextTile.currentTile.a-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.11.771.0 ]--
r 145                     && !array[nextTile.currentTile.add-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.11.779.0 ]--
r 145                     && !array[nextTile.currentTile.add()-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.20.180.0 ]--
r 145                     && !array[nextTile.currentTile.add(-)-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.20.283.0 ]--
r 145                     && !array[nextTile.currentTile.add(-1)-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.20.599.0 ]--
r 145                     && !array[nextTile.currentTile.add(-1,)-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.21.188.0 ]--
r 145                     && !array[nextTile.currentTile.add(-1,0)-1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.23.563.0 ]--
r 145                     && !array[nextTile.currentTile.add(-1,0)-][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.23.751.0 ]--
r 145                     && !array[nextTile.currentTile.add(-1,0)][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.44.960.0 ]--
r 145                     && !array[nextTile.currentTile.add(-1,0).][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.45.138.0 ]--
r 145                     && !array[nextTile.currentTile.add(-1,0).g][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.45.257.0 ]--
r 145                     && !array[nextTile.currentTile.add(-1,0).ge][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.45.406.0 ]--
r 145                     && !array[nextTile.currentTile.add(-1,0).get][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.46.558.0 ]--
r 145                     && !array[nextTile.currentTile.add(-1,0).getI][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.38.46.566.0 ]--
r 145                     && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.39.02.252.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.getJ()+);
--[ 2022.11.06.15.39.02.415.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.getJ());
--[ 2022.11.06.15.39.02.596.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.getJ();
--[ 2022.11.06.15.39.02.786.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.getJ);
--[ 2022.11.06.15.39.04.011.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.getJ());
--[ 2022.11.06.15.39.06.983.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile..getJ());
--[ 2022.11.06.15.39.07.955.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.a.getJ());
--[ 2022.11.06.15.39.08.377.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.add.getJ());
--[ 2022.11.06.15.39.08.384.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.add().getJ());
--[ 2022.11.06.15.39.09.544.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.add.getJ());
--[ 2022.11.06.15.39.09.721.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.ad.getJ());
--[ 2022.11.06.15.39.09.912.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.a.getJ());
--[ 2022.11.06.15.39.10.087.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile..getJ());
--[ 2022.11.06.15.39.10.316.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.a.getJ());
--[ 2022.11.06.15.39.10.410.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.ad.getJ());
--[ 2022.11.06.15.39.13.945.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.add.getJ());
--[ 2022.11.06.15.39.13.952.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.add().getJ());
--[ 2022.11.06.15.39.19.148.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.add(0).getJ());
--[ 2022.11.06.15.39.19.965.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.add(0,).getJ());
--[ 2022.11.06.15.39.20.513.0 ]--
r 168             System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.add(0,1).getJ());
--[ 2022.11.06.15.39.25.393.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.39.54.481.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile..getJ()-1]) {
--[ 2022.11.06.15.39.54.596.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile..agetJ()-1]) {
--[ 2022.11.06.15.39.54.754.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile..adgetJ()-1]) {
--[ 2022.11.06.15.39.54.904.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile..addgetJ()-1]) {
--[ 2022.11.06.15.39.55.388.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile..adgetJ()-1]) {
--[ 2022.11.06.15.39.55.529.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile..agetJ()-1]) {
--[ 2022.11.06.15.39.55.693.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile..getJ()-1]) {
--[ 2022.11.06.15.39.55.876.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.39.56.058.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTilegetJ()-1]) {
--[ 2022.11.06.15.39.56.424.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.getJ()-1]) {
--[ 2022.11.06.15.39.56.702.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.agetJ()-1]) {
--[ 2022.11.06.15.39.56.946.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.adgetJ()-1]) {
--[ 2022.11.06.15.39.58.107.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.addgetJ()-1]) {
--[ 2022.11.06.15.39.58.113.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.add()getJ()-1]) {
--[ 2022.11.06.15.40.00.056.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0)getJ()-1]) {
--[ 2022.11.06.15.40.00.660.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,)getJ()-1]) {
--[ 2022.11.06.15.40.01.787.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-)getJ()-1]) {
--[ 2022.11.06.15.40.01.884.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1)getJ()-1]) {
--[ 2022.11.06.15.40.04.139.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()-1]) {
--[ 2022.11.06.15.40.06.771.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()-]) {
--[ 2022.11.06.15.40.06.930.0 ]--
r 161                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
--[ 2022.11.06.15.40.19.676.0 ]--
r 162                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()-), nextTile);
--[ 2022.11.06.15.40.20.133.0 ]--
r 162                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.15.40.22.883.0 ]--
r 162                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile..getJ()), nextTile);
--[ 2022.11.06.15.40.23.020.0 ]--
r 162                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.a.getJ()), nextTile);
--[ 2022.11.06.15.40.23.194.0 ]--
r 162                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.ad.getJ()), nextTile);
--[ 2022.11.06.15.40.23.781.0 ]--
r 162                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add.getJ()), nextTile);
--[ 2022.11.06.15.40.23.788.0 ]--
r 162                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add().getJ()), nextTile);
--[ 2022.11.06.15.40.25.269.0 ]--
r 162                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0).getJ()), nextTile);
--[ 2022.11.06.15.40.26.003.0 ]--
r 162                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,).getJ()), nextTile);
--[ 2022.11.06.15.40.26.660.0 ]--
r 162                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-).getJ()), nextTile);
--[ 2022.11.06.15.40.27.013.0 ]--
r 162                 PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
--[ 2022.11.06.15.40.34.556.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile..getJ() - 1] = true;
--[ 2022.11.06.15.40.34.745.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.a.getJ() - 1] = true;
--[ 2022.11.06.15.40.34.926.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.ad.getJ() - 1] = true;
--[ 2022.11.06.15.40.35.192.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.add.getJ() - 1] = true;
--[ 2022.11.06.15.40.35.198.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.add().getJ() - 1] = true;
--[ 2022.11.06.15.40.36.635.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0).getJ() - 1] = true;
--[ 2022.11.06.15.40.36.997.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,).getJ() - 1] = true;
--[ 2022.11.06.15.40.37.714.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-).getJ() - 1] = true;
--[ 2022.11.06.15.40.38.029.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ() - 1] = true;
--[ 2022.11.06.15.40.40.465.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ() - ] = true;
--[ 2022.11.06.15.40.40.687.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ() -] = true;
--[ 2022.11.06.15.40.41.010.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ() ] = true;
--[ 2022.11.06.15.40.41.372.0 ]--
r 163                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
--[ 2022.11.06.15.40.48.605.0 ]--
r 160             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile..getJ()-1).isInBounds(min,max)
--[ 2022.11.06.15.40.48.712.0 ]--
r 160             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.a.getJ()-1).isInBounds(min,max)
--[ 2022.11.06.15.40.48.848.0 ]--
r 160             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.ad.getJ()-1).isInBounds(min,max)
--[ 2022.11.06.15.40.49.158.0 ]--
r 160             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add.getJ()-1).isInBounds(min,max)
--[ 2022.11.06.15.40.49.166.0 ]--
r 160             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add().getJ()-1).isInBounds(min,max)
--[ 2022.11.06.15.40.50.874.0 ]--
r 160             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0).getJ()-1).isInBounds(min,max)
--[ 2022.11.06.15.40.51.426.0 ]--
r 160             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,).getJ()-1).isInBounds(min,max)
--[ 2022.11.06.15.40.51.886.0 ]--
r 160             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-).getJ()-1).isInBounds(min,max)
--[ 2022.11.06.15.40.52.134.0 ]--
r 160             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()-1).isInBounds(min,max)
--[ 2022.11.06.15.40.55.135.0 ]--
r 160             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()-).isInBounds(min,max)
--[ 2022.11.06.15.40.55.327.0 ]--
r 160             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
--[ 2022.11.06.15.41.09.447.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile..getJ()+1).isInBounds(min,max)
--[ 2022.11.06.15.41.09.551.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.a.getJ()+1).isInBounds(min,max)
--[ 2022.11.06.15.41.09.689.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.ad.getJ()+1).isInBounds(min,max)
--[ 2022.11.06.15.41.10.325.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add.getJ()+1).isInBounds(min,max)
--[ 2022.11.06.15.41.10.333.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add().getJ()+1).isInBounds(min,max)
--[ 2022.11.06.15.41.11.401.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0).getJ()+1).isInBounds(min,max)
--[ 2022.11.06.15.41.11.762.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0.).getJ()+1).isInBounds(min,max)
--[ 2022.11.06.15.41.12.365.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0).getJ()+1).isInBounds(min,max)
--[ 2022.11.06.15.41.12.724.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,).getJ()+1).isInBounds(min,max)
--[ 2022.11.06.15.41.13.085.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()+1).isInBounds(min,max)
--[ 2022.11.06.15.41.15.986.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()+).isInBounds(min,max)
--[ 2022.11.06.15.41.16.154.0 ]--
r 169             if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
--[ 2022.11.06.15.41.25.775.0 ]--
r 170                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()+1]) {
--[ 2022.11.06.15.41.28.627.0 ]--
r 170                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()+]) {
--[ 2022.11.06.15.41.28.788.0 ]--
r 170                     && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
--[ 2022.11.06.15.41.32.987.0 ]--
r 172                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()+1), nextTile);
--[ 2022.11.06.15.41.36.429.0 ]--
r 172                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()+), nextTile);
--[ 2022.11.06.15.41.36.576.0 ]--
r 172                 PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
--[ 2022.11.06.15.41.40.606.0 ]--
r 173                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ() + 1] = true;
--[ 2022.11.06.15.41.42.638.0 ]--
r 173                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ() + ] = true;
--[ 2022.11.06.15.41.42.818.0 ]--
r 173                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ() +] = true;
--[ 2022.11.06.15.41.42.996.0 ]--
r 173                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ() ] = true;
--[ 2022.11.06.15.41.43.264.0 ]--
r 173                 array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
--[ 2022.11.06.15.41.56.253.0 ]--
r 152             if (new Coord(nextTile.currentTile..getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.41.56.360.0 ]--
r 152             if (new Coord(nextTile.currentTile.a.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.41.56.476.0 ]--
r 152             if (new Coord(nextTile.currentTile.ad.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.41.56.867.0 ]--
r 152             if (new Coord(nextTile.currentTile.add.getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.41.56.875.0 ]--
r 152             if (new Coord(nextTile.currentTile.add().getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.41.58.493.0 ]--
r 152             if (new Coord(nextTile.currentTile.add(1).getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.41.58.913.0 ]--
r 152             if (new Coord(nextTile.currentTile.add(1,).getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.41.59.330.0 ]--
r 152             if (new Coord(nextTile.currentTile.add(1,0).getI() + 1, nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.42.03.179.0 ]--
r 152             if (new Coord(nextTile.currentTile.add(1,0).getI() + , nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.42.03.346.0 ]--
r 152             if (new Coord(nextTile.currentTile.add(1,0).getI() +, nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.42.03.532.0 ]--
r 152             if (new Coord(nextTile.currentTile.add(1,0).getI() , nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.42.03.954.0 ]--
r 152             if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
--[ 2022.11.06.15.42.13.650.0 ]--
r 153                     && !array[nextTile.currentTile.add(1,0).getI()+1][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.42.16.093.0 ]--
r 153                     && !array[nextTile.currentTile.add(1,0).getI()+][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.42.16.269.0 ]--
r 153                     && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
--[ 2022.11.06.15.42.20.109.0 ]--
r 154                 PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI() + 1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.15.42.22.219.0 ]--
r 154                 PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI() + , nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.15.42.22.424.0 ]--
r 154                 PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI() +, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.15.42.22.719.0 ]--
r 154                 PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI() , nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.15.42.23.013.0 ]--
r 154                 PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.15.42.27.857.0 ]--
r 156                 array[nextTile.currentTile.add(1,0).getI() + 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.30.532.0 ]--
r 156                 array[nextTile.currentTile.add(1,0).getI() + ][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.30.825.0 ]--
r 156                 array[nextTile.currentTile.add(1,0).getI() +][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.31.119.0 ]--
r 156                 array[nextTile.currentTile.add(1,0).getI() ][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.31.411.0 ]--
r 156                 array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.46.604.0 ]--
r 148                 array[nextTile.currentTile..getI() - 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.46.697.0 ]--
r 148                 array[nextTile.currentTile.a.getI() - 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.46.839.0 ]--
r 148                 array[nextTile.currentTile.ad.getI() - 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.46.985.0 ]--
r 148                 array[nextTile.currentTile.add.getI() - 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.47.170.0 ]--
r 148                 array[nextTile.currentTile.add().getI() - 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.48.399.0 ]--
r 148                 array[nextTile.currentTile.add(-).getI() - 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.48.639.0 ]--
r 148                 array[nextTile.currentTile.add(-1).getI() - 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.49.060.0 ]--
r 148                 array[nextTile.currentTile.add(-1,).getI() - 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.49.423.0 ]--
r 148                 array[nextTile.currentTile.add(-1,0).getI() - 1][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.51.559.0 ]--
r 148                 array[nextTile.currentTile.add(-1,0).getI() - ][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.51.739.0 ]--
r 148                 array[nextTile.currentTile.add(-1,0).getI() -][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.51.915.0 ]--
r 148                 array[nextTile.currentTile.add(-1,0).getI() ][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.42.52.135.0 ]--
r 148                 array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
--[ 2022.11.06.15.43.07.651.0 ]--
r 146                 PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI()-1, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.15.43.10.114.0 ]--
r 146                 PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI()-, nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.15.43.10.345.0 ]--
r 146                 PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
--[ 2022.11.06.15.43.19.705.0 ]--
r 144             if (new Coord(nextTile.currentTile.add(-1,0).getI()-1, nextTile.currentTile.getJ()).isInBounds(min, max)
--[ 2022.11.06.15.43.21.805.0 ]--
r 144             if (new Coord(nextTile.currentTile.add(-1,0).getI()-, nextTile.currentTile.getJ()).isInBounds(min, max)
--[ 2022.11.06.15.43.21.974.0 ]--
r 144             if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
--[ 2022.11.06.15.43.53.777.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.46.19.841.0 ]--
r 144             if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max-)
--[ 2022.11.06.15.46.20.367.0 ]--
r 144             if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max-1)
--[ 2022.11.06.15.46.27.785.0 ]--
r 144             if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max-)
--[ 2022.11.06.15.46.27.961.0 ]--
r 144             if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
--[ 2022.11.06.15.46.35.586.0 ]--
:/src/Coord.java
r 20         return i >= min.i && i <= max.i- && j >= min.j && j <= max.j;
--[ 2022.11.06.15.46.36.081.0 ]--
r 20         return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j;
--[ 2022.11.06.15.46.40.044.0 ]--
r 20         return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-;
--[ 2022.11.06.15.46.40.535.0 ]--
r 20         return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
--[ 2022.11.06.15.46.43.811.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.48.06.520.0 ]--
:/src/Pathfinder.java
+ 139             
--[ 2022.11.06.15.48.07.568.0 ]--
r 139             s
--[ 2022.11.06.15.48.07.600.0 ]--
r 139             so
--[ 2022.11.06.15.48.07.704.0 ]--
r 139             sou
--[ 2022.11.06.15.48.07.829.0 ]--
r 139             sout
--[ 2022.11.06.15.48.07.866.0 ]--
r 139             System.out.println();
--[ 2022.11.06.15.48.08.821.0 ]--
r 139             System.out.println("");
--[ 2022.11.06.15.48.10.482.0 ]--
r 139             System.out.println("s");
--[ 2022.11.06.15.48.10.559.0 ]--
r 139             System.out.println("si");
--[ 2022.11.06.15.48.10.622.0 ]--
r 139             System.out.println("siz");
--[ 2022.11.06.15.48.10.717.0 ]--
r 139             System.out.println("size");
--[ 2022.11.06.15.48.12.340.0 ]--
r 139             System.out.println("size ");
--[ 2022.11.06.15.48.12.631.0 ]--
r 139             System.out.println("size P");
--[ 2022.11.06.15.48.12.725.0 ]--
r 139             System.out.println("size PG");
--[ 2022.11.06.15.48.13.141.0 ]--
r 139             System.out.println("size P");
--[ 2022.11.06.15.48.13.175.0 ]--
r 139             System.out.println("size PQ");
--[ 2022.11.06.15.48.14.170.0 ]--
r 139             System.out.println("size PQ ");
--[ 2022.11.06.15.48.14.940.0 ]--
r 139             System.out.println("size PQ  ");
--[ 2022.11.06.15.48.15.805.0 ]--
r 139             System.out.println("size PQ ");
--[ 2022.11.06.15.48.16.395.0 ]--
r 139             System.out.println("size PQ " );
--[ 2022.11.06.15.48.16.629.0 ]--
r 139             System.out.println("size PQ " +);
--[ 2022.11.06.15.48.16.674.0 ]--
r 139             System.out.println("size PQ " + );
--[ 2022.11.06.15.48.17.815.0 ]--
r 139             System.out.println("size PQ " + p);
--[ 2022.11.06.15.48.17.990.0 ]--
r 139             System.out.println("size PQ " + pw);
--[ 2022.11.06.15.48.18.387.0 ]--
r 139             System.out.println("size PQ " + p);
--[ 2022.11.06.15.48.18.421.0 ]--
r 139             System.out.println("size PQ " + pq);
--[ 2022.11.06.15.48.18.663.0 ]--
r 139             System.out.println("size PQ " + pq.);
--[ 2022.11.06.15.48.19.190.0 ]--
r 139             System.out.println("size PQ " + pq.s);
--[ 2022.11.06.15.48.19.934.0 ]--
r 139             System.out.println("size PQ " + pq.size);
--[ 2022.11.06.15.48.19.941.0 ]--
r 139             System.out.println("size PQ " + pq.size());
--[ 2022.11.06.15.48.22.611.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.49.25.619.0 ]--
+ 147                 
--[ 2022.11.06.15.49.26.262.0 ]--
r 147                 s
--[ 2022.11.06.15.49.26.350.0 ]--
r 147                 so
--[ 2022.11.06.15.49.26.447.0 ]--
r 147                 sou
--[ 2022.11.06.15.49.26.529.0 ]--
r 147                 sout
--[ 2022.11.06.15.49.26.646.0 ]--
r 147                 System.out.println();
--[ 2022.11.06.15.49.27.325.0 ]--
r 147                 System.out.println("");
--[ 2022.11.06.15.49.27.977.0 ]--
r 147                 System.out.println("A");
--[ 2022.11.06.15.49.28.512.0 ]--
r 147                 System.out.println("Av");
--[ 2022.11.06.15.49.28.651.0 ]--
r 147                 System.out.println("Avo");
--[ 2022.11.06.15.49.28.751.0 ]--
r 147                 System.out.println("Avov");
--[ 2022.11.06.15.49.28.900.0 ]--
r 147                 System.out.println("Avove");
--[ 2022.11.06.15.49.28.998.0 ]--
r 147                 System.out.println("Avove ");
--[ 2022.11.06.15.49.29.434.0 ]--
r 147                 System.out.println("Avove");
--[ 2022.11.06.15.49.29.611.0 ]--
r 147                 System.out.println("Avov");
--[ 2022.11.06.15.49.29.777.0 ]--
r 147                 System.out.println("Avo");
--[ 2022.11.06.15.49.29.954.0 ]--
r 147                 System.out.println("Av");
--[ 2022.11.06.15.49.30.126.0 ]--
r 147                 System.out.println("A");
--[ 2022.11.06.15.49.30.252.0 ]--
r 147                 System.out.println("Ab");
--[ 2022.11.06.15.49.30.397.0 ]--
r 147                 System.out.println("Abo");
--[ 2022.11.06.15.49.30.498.0 ]--
r 147                 System.out.println("Abov");
--[ 2022.11.06.15.49.30.651.0 ]--
r 147                 System.out.println("Above");
--[ 2022.11.06.15.49.30.782.0 ]--
r 147                 System.out.println("Above ");
--[ 2022.11.06.15.49.30.949.0 ]--
r 147                 System.out.println("Above c");
--[ 2022.11.06.15.49.31.392.0 ]--
r 147                 System.out.println("Above cr");
--[ 2022.11.06.15.49.31.494.0 ]--
r 147                 System.out.println("Above cre");
--[ 2022.11.06.15.49.31.670.0 ]--
r 147                 System.out.println("Above crea");
--[ 2022.11.06.15.49.31.869.0 ]--
r 147                 System.out.println("Above creat");
--[ 2022.11.06.15.49.31.960.0 ]--
r 147                 System.out.println("Above create");
--[ 2022.11.06.15.49.32.177.0 ]--
r 147                 System.out.println("Above created");
--[ 2022.11.06.15.49.37.631.0 ]--
+ 156                 
--[ 2022.11.06.15.49.37.924.0 ]--
r 156                 System.out.println("Above created");
--[ 2022.11.06.15.49.40.055.0 ]--
r 156                 System.out.println("b created");
--[ 2022.11.06.15.49.40.534.0 ]--
r 156                 System.out.println(" created");
--[ 2022.11.06.15.49.40.616.0 ]--
r 156                 System.out.println("B created");
--[ 2022.11.06.15.49.40.915.0 ]--
r 156                 System.out.println("Be created");
--[ 2022.11.06.15.49.41.141.0 ]--
r 156                 System.out.println("Bel created");
--[ 2022.11.06.15.49.41.296.0 ]--
r 156                 System.out.println("Belo created");
--[ 2022.11.06.15.49.41.369.0 ]--
r 156                 System.out.println("Below created");
--[ 2022.11.06.15.49.44.757.0 ]--
+ 165                 
--[ 2022.11.06.15.49.46.176.0 ]--
r 165                 System.out.println("Above created");
--[ 2022.11.06.15.49.48.608.0 ]--
r 165                 System.out.println("L created");
--[ 2022.11.06.15.49.48.765.0 ]--
r 165                 System.out.println("Le created");
--[ 2022.11.06.15.49.48.837.0 ]--
r 165                 System.out.println("Lef created");
--[ 2022.11.06.15.49.49.081.0 ]--
r 165                 System.out.println("Left created");
--[ 2022.11.06.15.49.53.258.0 ]--
+ 175                 
--[ 2022.11.06.15.49.53.527.0 ]--
r 175                 System.out.println("Above created");
--[ 2022.11.06.15.49.56.879.0 ]--
r 175                 System.out.println("R created");
--[ 2022.11.06.15.49.57.029.0 ]--
r 175                 System.out.println("Ri created");
--[ 2022.11.06.15.49.57.099.0 ]--
r 175                 System.out.println("Rig created");
--[ 2022.11.06.15.49.57.279.0 ]--
r 175                 System.out.println("Righ created");
--[ 2022.11.06.15.49.57.349.0 ]--
r 175                 System.out.println("Right created");
--[ 2022.11.06.15.50.00.135.0 ]--
r 176                
--[ 2022.11.06.15.50.00.292.0 ]--
- 176
--[ 2022.11.06.15.50.02.462.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.50.42.833.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.52.32.077.0 ]--
+ 139             
--[ 2022.11.06.15.52.35.616.0 ]--
r 139             i
--[ 2022.11.06.15.52.35.716.0 ]--
r 139             if
--[ 2022.11.06.15.52.36.676.0 ]--
r 139             if ()
--[ 2022.11.06.15.52.37.551.0 ]--
r 139             if (i)
--[ 2022.11.06.15.52.37.601.0 ]--
r 139             if (is)
--[ 2022.11.06.15.52.39.829.0 ]--
r 139             if (i)
--[ 2022.11.06.15.52.39.964.0 ]--
r 139             if ()
--[ 2022.11.06.15.52.41.376.0 ]--
r 139             if (f)
--[ 2022.11.06.15.52.41.421.0 ]--
r 139             if (fo)
--[ 2022.11.06.15.52.41.487.0 ]--
r 139             if (fou)
--[ 2022.11.06.15.52.41.718.0 ]--
r 139             if (foun)
--[ 2022.11.06.15.52.41.834.0 ]--
r 139             if (found)
--[ 2022.11.06.15.52.41.997.0 ]--
r 139             if (found )
--[ 2022.11.06.15.52.42.129.0 ]--
r 139             if (found =)
--[ 2022.11.06.15.52.42.221.0 ]--
r 139             if (found = )
--[ 2022.11.06.15.52.42.538.0 ]--
r 139             if (found =)
--[ 2022.11.06.15.52.42.701.0 ]--
r 139             if (found )
--[ 2022.11.06.15.52.42.873.0 ]--
r 139             if (found)
--[ 2022.11.06.15.52.43.050.0 ]--
r 139             if (foun)
--[ 2022.11.06.15.52.43.230.0 ]--
r 139             if (fou)
--[ 2022.11.06.15.52.43.432.0 ]--
r 139             if (fo)
--[ 2022.11.06.15.52.43.858.0 ]--
r 139             if (f)
--[ 2022.11.06.15.52.44.594.0 ]--
r 139             if ()
--[ 2022.11.06.15.52.47.151.0 ]--
r 139             if 
--[ 2022.11.06.15.52.47.327.0 ]--
r 139             if
--[ 2022.11.06.15.52.47.531.0 ]--
r 139             i
--[ 2022.11.06.15.52.47.732.0 ]--
r 139             
--[ 2022.11.06.15.52.48.074.0 ]--
- 139
--[ 2022.11.06.15.53.01.993.0 ]--
+ 143                 
--[ 2022.11.06.15.53.02.869.0 ]--
r 143                 c
--[ 2022.11.06.15.53.02.919.0 ]--
r 143                 co
--[ 2022.11.06.15.53.02.984.0 ]--
r 143                 con
--[ 2022.11.06.15.53.03.114.0 ]--
r 143                 cont
--[ 2022.11.06.15.53.03.160.0 ]--
r 143                 conti
--[ 2022.11.06.15.53.03.884.0 ]--
r 143                 continue
--[ 2022.11.06.15.53.03.907.0 ]--
r 143                 continue;
--[ 2022.11.06.15.53.09.100.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.54.37.714.0 ]--
+ 132         
--[ 2022.11.06.15.54.44.773.0 ]--
r 132         p
--[ 2022.11.06.15.54.45.098.0 ]--
r 132         pq
--[ 2022.11.06.15.54.45.317.0 ]--
r 132         pq.
--[ 2022.11.06.15.54.46.047.0 ]--
r 132         pq
--[ 2022.11.06.15.54.47.419.0 ]--
r 132         pq 
--[ 2022.11.06.15.54.47.511.0 ]--
r 132         pq =
--[ 2022.11.06.15.54.47.599.0 ]--
r 132         pq = 
--[ 2022.11.06.15.54.47.879.0 ]--
r 132         pq = n
--[ 2022.11.06.15.54.47.978.0 ]--
r 132         pq = ne
--[ 2022.11.06.15.54.48.065.0 ]--
r 132         pq = new
--[ 2022.11.06.15.54.50.378.0 ]--
r 132         pq = new MinPQ
--[ 2022.11.06.15.54.50.387.0 ]--
r 132         pq = new MinPQ<>
--[ 2022.11.06.15.54.50.394.0 ]--
r 132         pq = new MinPQ<>()
--[ 2022.11.06.15.54.52.587.0 ]--
r 132         pq = new MinPQ<N>()
--[ 2022.11.06.15.54.52.786.0 ]--
r 132         pq = new MinPQ<No>()
--[ 2022.11.06.15.54.52.946.0 ]--
r 132         pq = new MinPQ<Nod>()
--[ 2022.11.06.15.54.53.060.0 ]--
r 132         pq = new MinPQ<Node>()
--[ 2022.11.06.15.54.53.719.0 ]--
r 132         pq = new MinPQ<Nod>()
--[ 2022.11.06.15.54.53.855.0 ]--
r 132         pq = new MinPQ<No>()
--[ 2022.11.06.15.54.54.027.0 ]--
r 132         pq = new MinPQ<N>()
--[ 2022.11.06.15.54.54.189.0 ]--
r 132         pq = new MinPQ<>()
--[ 2022.11.06.15.54.54.467.0 ]--
r 132         pq = new MinPQ<P>()
--[ 2022.11.06.15.54.54.619.0 ]--
r 132         pq = new MinPQ<PF>()
--[ 2022.11.06.15.54.55.802.0 ]--
r 132         pq = new MinPQ<PFN>()
--[ 2022.11.06.15.54.55.903.0 ]--
r 132         pq = new MinPQ<PFNo>()
--[ 2022.11.06.15.54.55.977.0 ]--
r 132         pq = new MinPQ<PFNod>()
--[ 2022.11.06.15.54.56.118.0 ]--
r 132         pq = new MinPQ<PFNode>()
--[ 2022.11.06.15.54.57.124.0 ]--
r 132         pq = new MinPQ<Pathfinder.PFNode>()
--[ 2022.11.06.15.54.57.127.0 ]--
r 132         pq = new MinPQ<PFNode>()
--[ 2022.11.06.15.54.58.745.0 ]--
r 132         pq = new MinPQ<PFNode>();
--[ 2022.11.06.15.55.04.688.0 ]--
+ 133         
--[ 2022.11.06.15.55.08.598.0 ]--
r 133         a
--[ 2022.11.06.15.55.08.769.0 ]--
r 133         ar
--[ 2022.11.06.15.55.08.895.0 ]--
r 133         arr
--[ 2022.11.06.15.55.09.009.0 ]--
r 133         arra
--[ 2022.11.06.15.55.09.065.0 ]--
r 133         array
--[ 2022.11.06.15.55.09.683.0 ]--
r 133         array 
--[ 2022.11.06.15.55.09.766.0 ]--
r 133         array =
--[ 2022.11.06.15.55.09.887.0 ]--
r 133         array = 
--[ 2022.11.06.15.55.10.377.0 ]--
r 133         array = n
--[ 2022.11.06.15.55.10.454.0 ]--
r 133         array = ne
--[ 2022.11.06.15.55.10.543.0 ]--
r 133         array = new
--[ 2022.11.06.15.55.11.129.0 ]--
r 133         array = new 
--[ 2022.11.06.15.55.11.305.0 ]--
r 133         array = new b
--[ 2022.11.06.15.55.11.407.0 ]--
r 133         array = new bo
--[ 2022.11.06.15.55.11.530.0 ]--
r 133         array = new boo
--[ 2022.11.06.15.55.11.698.0 ]--
r 133         array = new bool
--[ 2022.11.06.15.55.11.895.0 ]--
r 133         array = new boole
--[ 2022.11.06.15.55.12.016.0 ]--
r 133         array = new boolea
--[ 2022.11.06.15.55.12.128.0 ]--
r 133         array = new boolean
--[ 2022.11.06.15.55.13.065.0 ]--
r 133         array = new boolean[][]
--[ 2022.11.06.15.55.14.390.0 ]--
r 133         array = new boolean[N][]
--[ 2022.11.06.15.55.15.734.0 ]--
r 133         array = new boolean[N][N]
--[ 2022.11.06.15.55.16.995.0 ]--
r 133         array = new boolean[N][N];
--[ 2022.11.06.15.55.18.846.0 ]--
+ 134         
--[ 2022.11.06.15.56.43.804.0 ]--
+ 144             
--[ 2022.11.06.15.56.44.771.0 ]--
r 144             s
--[ 2022.11.06.15.56.44.940.0 ]--
r 144             ss
--[ 2022.11.06.15.56.45.031.0 ]--
r 144             sso
--[ 2022.11.06.15.56.45.101.0 ]--
r 144             ssou
--[ 2022.11.06.15.56.45.322.0 ]--
r 144             sso
--[ 2022.11.06.15.56.45.482.0 ]--
r 144             ss
--[ 2022.11.06.15.56.45.625.0 ]--
r 144             s
--[ 2022.11.06.15.56.45.793.0 ]--
r 144             so
--[ 2022.11.06.15.56.45.900.0 ]--
r 144             sou
--[ 2022.11.06.15.56.46.024.0 ]--
r 144             sout
--[ 2022.11.06.15.56.46.140.0 ]--
r 144             System.out.println();
--[ 2022.11.06.15.56.46.875.0 ]--
r 144             System.out.println("");
--[ 2022.11.06.15.56.47.563.0 ]--
r 144             System.out.println("C");
--[ 2022.11.06.15.56.47.737.0 ]--
r 144             System.out.println("Cu");
--[ 2022.11.06.15.56.47.836.0 ]--
r 144             System.out.println("Cur");
--[ 2022.11.06.15.56.47.970.0 ]--
r 144             System.out.println("Curr");
--[ 2022.11.06.15.56.48.079.0 ]--
r 144             System.out.println("Curre");
--[ 2022.11.06.15.56.48.255.0 ]--
r 144             System.out.println("Curren");
--[ 2022.11.06.15.56.48.330.0 ]--
r 144             System.out.println("Current");
--[ 2022.11.06.15.56.48.456.0 ]--
r 144             System.out.println("Current ");
--[ 2022.11.06.15.56.48.685.0 ]--
r 144             System.out.println("Current L");
--[ 2022.11.06.15.56.48.844.0 ]--
r 144             System.out.println("Current Lo");
--[ 2022.11.06.15.56.48.925.0 ]--
r 144             System.out.println("Current Loc");
--[ 2022.11.06.15.56.49.617.0 ]--
r 144             System.out.println("Current Loc:");
--[ 2022.11.06.15.56.49.734.0 ]--
r 144             System.out.println("Current Loc: ");
--[ 2022.11.06.15.56.50.292.0 ]--
r 144             System.out.println("Current Loc: " );
--[ 2022.11.06.15.56.50.495.0 ]--
r 144             System.out.println("Current Loc: " +);
--[ 2022.11.06.15.56.50.632.0 ]--
r 144             System.out.println("Current Loc: " + );
--[ 2022.11.06.15.56.51.807.0 ]--
r 144             System.out.println("Current Loc: " + n);
--[ 2022.11.06.15.56.51.853.0 ]--
r 144             System.out.println("Current Loc: " + ne);
--[ 2022.11.06.15.56.52.177.0 ]--
r 144             System.out.println("Current Loc: " + nextTile);
--[ 2022.11.06.15.56.52.726.0 ]--
r 144             System.out.println("Current Loc: " + nextTile.);
--[ 2022.11.06.15.56.53.006.0 ]--
r 144             System.out.println("Current Loc: " + nextTile.c);
--[ 2022.11.06.15.56.53.061.0 ]--
r 144             System.out.println("Current Loc: " + nextTile.cu);
--[ 2022.11.06.15.56.53.558.0 ]--
r 144             System.out.println("Current Loc: " + nextTile.currentTile);
--[ 2022.11.06.15.56.55.347.0 ]--
r 134 
--[ 2022.11.06.15.56.57.050.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.57.55.380.0 ]--
+ 138         
--[ 2022.11.06.15.57.58.240.0 ]--
r 138         i
--[ 2022.11.06.15.57.58.313.0 ]--
r 138         if
--[ 2022.11.06.15.57.58.634.0 ]--
r 138         if ()
--[ 2022.11.06.15.57.59.552.0 ]--
r 138         if (s)
--[ 2022.11.06.15.57.59.688.0 ]--
r 138         if (st)
--[ 2022.11.06.15.57.59.811.0 ]--
r 138         if (sta)
--[ 2022.11.06.15.57.59.954.0 ]--
r 138         if (star)
--[ 2022.11.06.15.58.00.210.0 ]--
r 138         if (start)
--[ 2022.11.06.15.58.00.354.0 ]--
r 138         if (start )
--[ 2022.11.06.15.58.00.484.0 ]--
r 138         if (start =)
--[ 2022.11.06.15.58.00.685.0 ]--
r 138         if (start ==)
--[ 2022.11.06.15.58.00.904.0 ]--
r 138         if (start == )
--[ 2022.11.06.15.58.01.094.0 ]--
r 138         if (start == n)
--[ 2022.11.06.15.58.01.288.0 ]--
r 138         if (start == nu)
--[ 2022.11.06.15.58.01.421.0 ]--
r 138         if (start == nul)
--[ 2022.11.06.15.58.01.564.0 ]--
r 138         if (start == null)
--[ 2022.11.06.15.58.02.303.0 ]--
r 138         if (start == null) 
--[ 2022.11.06.15.58.02.612.0 ]--
r 138         if (start == null) {
--[ 2022.11.06.15.58.02.901.0 ]--
+ 139 
+ 140 }
--[ 2022.11.06.15.58.02.923.0 ]--
r 140         }
--[ 2022.11.06.15.58.02.938.0 ]--
r 139             
--[ 2022.11.06.15.58.04.656.0 ]--
r 139             t
--[ 2022.11.06.15.58.04.764.0 ]--
r 139             th
--[ 2022.11.06.15.58.04.921.0 ]--
r 139             thr
--[ 2022.11.06.15.58.05.105.0 ]--
r 139             thro
--[ 2022.11.06.15.58.05.229.0 ]--
r 139             throw
--[ 2022.11.06.15.58.05.364.0 ]--
r 139             throw 
--[ 2022.11.06.15.58.05.572.0 ]--
r 139             throw n
--[ 2022.11.06.15.58.05.683.0 ]--
r 139             throw ne
--[ 2022.11.06.15.58.05.762.0 ]--
r 139             throw new
--[ 2022.11.06.15.58.05.881.0 ]--
r 139             throw new 
--[ 2022.11.06.15.58.06.225.0 ]--
r 139             throw new I
--[ 2022.11.06.15.58.07.382.0 ]--
r 139             throw new IndexOutOfBoundsException
--[ 2022.11.06.15.58.07.391.0 ]--
r 139             throw new IndexOutOfBoundsException()
--[ 2022.11.06.15.58.09.799.0 ]--
r 139             throw new IndexOutOfBoundsException("")
--[ 2022.11.06.15.58.10.207.0 ]--
r 139             throw new IndexOutOfBoundsException("E")
--[ 2022.11.06.15.58.11.080.0 ]--
r 139             throw new IndexOutOfBoundsException("Er")
--[ 2022.11.06.15.58.11.215.0 ]--
r 139             throw new IndexOutOfBoundsException("Err")
--[ 2022.11.06.15.58.11.286.0 ]--
r 139             throw new IndexOutOfBoundsException("Erro")
--[ 2022.11.06.15.58.11.410.0 ]--
r 139             throw new IndexOutOfBoundsException("Error")
--[ 2022.11.06.15.58.11.743.0 ]--
r 139             throw new IndexOutOfBoundsException("Error:")
--[ 2022.11.06.15.58.11.879.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: ")
--[ 2022.11.06.15.58.12.538.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: S")
--[ 2022.11.06.15.58.13.351.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: St")
--[ 2022.11.06.15.58.13.487.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Sta")
--[ 2022.11.06.15.58.13.617.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Star")
--[ 2022.11.06.15.58.13.894.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start")
--[ 2022.11.06.15.58.14.046.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start ")
--[ 2022.11.06.15.58.14.884.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start h")
--[ 2022.11.06.15.58.14.932.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start ha")
--[ 2022.11.06.15.58.15.015.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has")
--[ 2022.11.06.15.58.15.087.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has ")
--[ 2022.11.06.15.58.15.321.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has n")
--[ 2022.11.06.15.58.15.418.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has no")
--[ 2022.11.06.15.58.15.500.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not")
--[ 2022.11.06.15.58.15.597.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not ")
--[ 2022.11.06.15.58.15.767.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not b")
--[ 2022.11.06.15.58.15.927.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not be")
--[ 2022.11.06.15.58.16.077.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not bee")
--[ 2022.11.06.15.58.16.186.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not been")
--[ 2022.11.06.15.58.16.242.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not been ")
--[ 2022.11.06.15.58.16.386.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not been s")
--[ 2022.11.06.15.58.16.593.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not been se")
--[ 2022.11.06.15.58.16.717.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not been set")
--[ 2022.11.06.15.58.17.515.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not been set.")
--[ 2022.11.06.15.58.19.266.0 ]--
r 139             throw new IndexOutOfBoundsException("Error: Start has not been set.");
--[ 2022.11.06.15.58.24.295.0 ]--
+ 141         
--[ 2022.11.06.15.58.25.164.0 ]--
r 141         e
--[ 2022.11.06.15.58.25.271.0 ]--
r 141         el
--[ 2022.11.06.15.58.25.345.0 ]--
r 141         els
--[ 2022.11.06.15.58.25.432.0 ]--
r 141         else
--[ 2022.11.06.15.58.25.946.0 ]--
r 141         else 
--[ 2022.11.06.15.58.26.015.0 ]--
r 141         else i
--[ 2022.11.06.15.58.26.101.0 ]--
r 141         else if
--[ 2022.11.06.15.58.26.253.0 ]--
r 141         else if 
--[ 2022.11.06.15.58.26.849.0 ]--
r 141         else if ()
--[ 2022.11.06.15.58.30.241.0 ]--
r 141         else if (e)
--[ 2022.11.06.15.58.30.346.0 ]--
r 141         else if (en)
--[ 2022.11.06.15.58.30.476.0 ]--
r 141         else if (end)
--[ 2022.11.06.15.58.32.081.0 ]--
r 141         else if (end )
--[ 2022.11.06.15.58.32.245.0 ]--
r 141         else if (end =)
--[ 2022.11.06.15.58.32.382.0 ]--
r 141         else if (end ==)
--[ 2022.11.06.15.58.32.531.0 ]--
r 141         else if (end == )
--[ 2022.11.06.15.58.32.857.0 ]--
r 141         else if (end == n)
--[ 2022.11.06.15.58.33.049.0 ]--
r 141         else if (end == nu)
--[ 2022.11.06.15.58.33.142.0 ]--
r 141         else if (end == nul)
--[ 2022.11.06.15.58.33.423.0 ]--
r 141         else if (end == null)
--[ 2022.11.06.15.58.37.034.0 ]--
r 141         else if (end == null) 
--[ 2022.11.06.15.58.37.783.0 ]--
r 141         else if (end == null) {
--[ 2022.11.06.15.58.38.063.0 ]--
+ 142 
+ 143 }
--[ 2022.11.06.15.58.38.083.0 ]--
r 143         }
--[ 2022.11.06.15.58.38.098.0 ]--
r 142             
--[ 2022.11.06.15.58.39.097.0 ]--
r 142             t
--[ 2022.11.06.15.58.39.169.0 ]--
r 142             th
--[ 2022.11.06.15.58.39.249.0 ]--
r 142             thr
--[ 2022.11.06.15.58.39.370.0 ]--
r 142             thro
--[ 2022.11.06.15.58.39.458.0 ]--
r 142             throw
--[ 2022.11.06.15.58.39.679.0 ]--
r 142             throw 
--[ 2022.11.06.15.58.39.815.0 ]--
r 142             throw n
--[ 2022.11.06.15.58.39.856.0 ]--
r 142             throw ne
--[ 2022.11.06.15.58.39.962.0 ]--
r 142             throw new
--[ 2022.11.06.15.58.40.093.0 ]--
r 142             throw new 
--[ 2022.11.06.15.58.41.879.0 ]--
r 142             throw new i
--[ 2022.11.06.15.58.41.953.0 ]--
r 142             throw new in
--[ 2022.11.06.15.58.42.954.0 ]--
r 142             throw new i
--[ 2022.11.06.15.58.43.086.0 ]--
r 142             throw new 
--[ 2022.11.06.15.58.43.461.0 ]--
r 142             throw new i
--[ 2022.11.06.15.58.43.662.0 ]--
r 142             throw new il
--[ 2022.11.06.15.58.43.833.0 ]--
r 142             throw new ill
--[ 2022.11.06.15.58.44.795.0 ]--
r 142             throw new il
--[ 2022.11.06.15.58.44.978.0 ]--
r 142             throw new i
--[ 2022.11.06.15.58.45.157.0 ]--
r 142             throw new 
--[ 2022.11.06.15.58.47.641.0 ]--
r 139             throw new i("Error: Start has not been set.");
--[ 2022.11.06.15.58.47.806.0 ]--
r 139             throw new il("Error: Start has not been set.");
--[ 2022.11.06.15.58.47.964.0 ]--
r 139             throw new ill("Error: Start has not been set.");
--[ 2022.11.06.15.58.48.014.0 ]--
r 139             throw new ille("Error: Start has not been set.");
--[ 2022.11.06.15.58.48.780.0 ]--
r 139             throw new ill("Error: Start has not been set.");
--[ 2022.11.06.15.58.48.933.0 ]--
r 139             throw new il("Error: Start has not been set.");
--[ 2022.11.06.15.58.49.120.0 ]--
r 139             throw new i("Error: Start has not been set.");
--[ 2022.11.06.15.58.49.266.0 ]--
r 139             throw new ("Error: Start has not been set.");
--[ 2022.11.06.15.58.49.453.0 ]--
r 139             throw new I("Error: Start has not been set.");
--[ 2022.11.06.15.58.49.868.0 ]--
r 139             throw new Il("Error: Start has not been set.");
--[ 2022.11.06.15.58.50.863.0 ]--
r 139             throw new IllegalArgumentException("Error: Start has not been set.");
--[ 2022.11.06.15.58.53.463.0 ]--
r 142             throw new I
--[ 2022.11.06.15.58.53.680.0 ]--
r 142             throw new Il
--[ 2022.11.06.15.58.53.831.0 ]--
r 142             throw new Ill
--[ 2022.11.06.15.58.54.318.0 ]--
r 142             throw new IllegalArgumentException
--[ 2022.11.06.15.58.54.327.0 ]--
r 142             throw new IllegalArgumentException()
--[ 2022.11.06.15.58.55.587.0 ]--
r 142             throw new IllegalArgumentException("")
--[ 2022.11.06.15.58.56.010.0 ]--
r 142             throw new IllegalArgumentException("E")
--[ 2022.11.06.15.58.56.158.0 ]--
r 142             throw new IllegalArgumentException("Er")
--[ 2022.11.06.15.58.56.314.0 ]--
r 142             throw new IllegalArgumentException("Err")
--[ 2022.11.06.15.58.56.389.0 ]--
r 142             throw new IllegalArgumentException("Erro")
--[ 2022.11.06.15.58.56.526.0 ]--
r 142             throw new IllegalArgumentException("Error")
--[ 2022.11.06.15.58.56.742.0 ]--
r 142             throw new IllegalArgumentException("Error:")
--[ 2022.11.06.15.58.57.043.0 ]--
r 142             throw new IllegalArgumentException("Error: ")
--[ 2022.11.06.15.58.57.664.0 ]--
r 142             throw new IllegalArgumentException("Error: E")
--[ 2022.11.06.15.58.57.872.0 ]--
r 142             throw new IllegalArgumentException("Error: En")
--[ 2022.11.06.15.58.57.941.0 ]--
r 142             throw new IllegalArgumentException("Error: End")
--[ 2022.11.06.15.58.58.111.0 ]--
r 142             throw new IllegalArgumentException("Error: End ")
--[ 2022.11.06.15.58.58.322.0 ]--
r 142             throw new IllegalArgumentException("Error: End h")
--[ 2022.11.06.15.58.58.392.0 ]--
r 142             throw new IllegalArgumentException("Error: End ha")
--[ 2022.11.06.15.58.58.461.0 ]--
r 142             throw new IllegalArgumentException("Error: End has")
--[ 2022.11.06.15.58.58.583.0 ]--
r 142             throw new IllegalArgumentException("Error: End has ")
--[ 2022.11.06.15.58.58.693.0 ]--
r 142             throw new IllegalArgumentException("Error: End has n")
--[ 2022.11.06.15.58.58.769.0 ]--
r 142             throw new IllegalArgumentException("Error: End has no")
--[ 2022.11.06.15.58.58.820.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not")
--[ 2022.11.06.15.58.58.937.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not ")
--[ 2022.11.06.15.58.59.106.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not b")
--[ 2022.11.06.15.58.59.231.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not be")
--[ 2022.11.06.15.58.59.393.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not bee")
--[ 2022.11.06.15.58.59.505.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not been")
--[ 2022.11.06.15.58.59.610.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not been ")
--[ 2022.11.06.15.58.59.784.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not been s")
--[ 2022.11.06.15.58.59.881.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not been se")
--[ 2022.11.06.15.58.59.988.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not been set")
--[ 2022.11.06.15.59.00.192.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not been set.")
--[ 2022.11.06.15.59.03.436.0 ]--
r 142             throw new IllegalArgumentException("Error: End has not been set.");
--[ 2022.11.06.15.59.06.228.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.59.35.900.0 ]--
+ 106         
--[ 2022.11.06.15.59.36.982.0 ]--
r 106         s
--[ 2022.11.06.15.59.37.051.0 ]--
r 106         so
--[ 2022.11.06.15.59.37.149.0 ]--
r 106         sou
--[ 2022.11.06.15.59.37.219.0 ]--
r 106         sout
--[ 2022.11.06.15.59.37.430.0 ]--
r 106         System.out.println();
--[ 2022.11.06.15.59.37.906.0 ]--
r 106         System.out.println("");
--[ 2022.11.06.15.59.38.392.0 ]--
r 106         System.out.println("M");
--[ 2022.11.06.15.59.38.894.0 ]--
r 106         System.out.println("Ma");
--[ 2022.11.06.15.59.39.067.0 ]--
r 106         System.out.println("Mad");
--[ 2022.11.06.15.59.39.252.0 ]--
r 106         System.out.println("Made");
--[ 2022.11.06.15.59.39.380.0 ]--
r 106         System.out.println("Made ");
--[ 2022.11.06.15.59.39.532.0 ]--
r 106         System.out.println("Made i");
--[ 2022.11.06.15.59.39.594.0 ]--
r 106         System.out.println("Made it");
--[ 2022.11.06.15.59.41.827.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.15.59.53.294.0 ]--
+ 133         
--[ 2022.11.06.15.59.53.985.0 ]--
r 133         ""
--[ 2022.11.06.15.59.54.999.0 ]--
r 133         
--[ 2022.11.06.15.59.55.205.0 ]--
r 133         S
--[ 2022.11.06.15.59.55.614.0 ]--
r 133         
--[ 2022.11.06.15.59.55.714.0 ]--
r 133         s
--[ 2022.11.06.15.59.55.802.0 ]--
r 133         so
--[ 2022.11.06.15.59.55.885.0 ]--
r 133         sou
--[ 2022.11.06.15.59.55.963.0 ]--
r 133         sout
--[ 2022.11.06.15.59.56.091.0 ]--
r 133         System.out.println();
--[ 2022.11.06.15.59.56.655.0 ]--
r 133         System.out.println("");
--[ 2022.11.06.15.59.57.073.0 ]--
r 133         System.out.println("R");
--[ 2022.11.06.15.59.57.155.0 ]--
r 133         System.out.println("Re");
--[ 2022.11.06.15.59.57.262.0 ]--
r 133         System.out.println("Res");
--[ 2022.11.06.15.59.57.510.0 ]--
r 133         System.out.println("Rest");
--[ 2022.11.06.15.59.58.079.0 ]--
r 133         System.out.println("Res");
--[ 2022.11.06.15.59.58.164.0 ]--
r 133         System.out.println("Rese");
--[ 2022.11.06.15.59.58.256.0 ]--
r 133         System.out.println("Reset");
--[ 2022.11.06.15.59.58.482.0 ]--
r 133         System.out.println("Reset ");
--[ 2022.11.06.15.59.58.638.0 ]--
r 133         System.out.println("Reset p");
--[ 2022.11.06.15.59.58.703.0 ]--
r 133         System.out.println("Reset pa");
--[ 2022.11.06.15.59.58.783.0 ]--
r 133         System.out.println("Reset pat");
--[ 2022.11.06.15.59.58.883.0 ]--
r 133         System.out.println("Reset path");
--[ 2022.11.06.16.00.01.711.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.16.00.51.707.0 ]--
+ 136         
--[ 2022.11.06.16.00.55.141.0 ]--
r 136         s
--[ 2022.11.06.16.00.55.274.0 ]--
r 136         st
--[ 2022.11.06.16.00.57.370.0 ]--
r 136         setPathStart
--[ 2022.11.06.16.00.57.377.0 ]--
r 136         setPathStart()
--[ 2022.11.06.16.00.57.381.0 ]--
r 136         setPathStart();
--[ 2022.11.06.16.00.58.383.0 ]--
r 136         setPathStart(s);
--[ 2022.11.06.16.00.58.516.0 ]--
r 136         setPathStart(st);
--[ 2022.11.06.16.00.58.636.0 ]--
r 136         setPathStart(sta);
--[ 2022.11.06.16.00.58.719.0 ]--
r 136         setPathStart(star);
--[ 2022.11.06.16.00.58.924.0 ]--
r 136         setPathStart(start);
--[ 2022.11.06.16.01.01.738.0 ]--
r 136         setPathStart(star);
--[ 2022.11.06.16.01.01.917.0 ]--
r 136         setPathStart(sta);
--[ 2022.11.06.16.01.02.111.0 ]--
r 136         setPathStart(st);
--[ 2022.11.06.16.01.02.353.0 ]--
r 136         setPathStart(s);
--[ 2022.11.06.16.01.02.649.0 ]--
r 136         setPathStart();
--[ 2022.11.06.16.02.02.403.0 ]--
r 136         
--[ 2022.11.06.16.02.02.617.0 ]--
- 136
--[ 2022.11.06.16.02.37.951.0 ]--
r 133         /System.out.println("Reset path");
--[ 2022.11.06.16.02.38.085.0 ]--
r 133         //System.out.println("Reset path");
--[ 2022.11.06.16.02.39.547.0 ]--
r 134         /pq = new MinPQ<PFNode>();
--[ 2022.11.06.16.02.39.701.0 ]--
r 134         //pq = new MinPQ<PFNode>();
--[ 2022.11.06.16.02.40.919.0 ]--
r 135         /array = new boolean[N][N];
--[ 2022.11.06.16.02.41.052.0 ]--
r 135         //array = new boolean[N][N];
--[ 2022.11.06.16.02.44.087.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.16.08.07.436.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.16.11.16.288.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.16.11.41.214.0 ]--
r 63             /System.out.println("PrevNode: " + this.prevNode);
--[ 2022.11.06.16.11.41.326.0 ]--
r 63             //System.out.println("PrevNode: " + this.prevNode);
--[ 2022.11.06.16.11.44.075.0 ]--
r 62             /System.out.println("Cost " + this.cost);
--[ 2022.11.06.16.11.44.228.0 ]--
r 62             //System.out.println("Cost " + this.cost);
--[ 2022.11.06.16.11.51.625.0 ]--
r 55             \
--[ 2022.11.06.16.11.51.827.0 ]--
r 55             
--[ 2022.11.06.16.11.52.219.0 ]--
- 55
--[ 2022.11.06.16.12.37.683.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.16.13.34.843.0 ]--
r 184             /System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.add(0,1).getJ());
--[ 2022.11.06.16.13.34.970.0 ]--
r 184             //System.out.println("Right X: " +nextTile.currentTile.getI() +"\n Y: " + nextTile.currentTile.add(0,1).getJ());
--[ 2022.11.06.16.13.54.872.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.16.20.25.399.0 ]--
+ 139         
--[ 2022.11.06.16.20.44.899.0 ]--
- 106
r 106        
--[ 2022.11.06.16.20.49.485.0 ]--
+ 138         
--[ 2022.11.06.16.20.49.726.0 ]--
+ 138         
--[ 2022.11.06.16.20.50.584.0 ]--
+ 139          PFNode s = new PFNode(loc, null);
r 140         pq.insert(s);
--[ 2022.11.06.16.20.50.601.0 ]--
r 138 
r 139         PFNode s = new PFNode(loc, null);
--[ 2022.11.06.16.20.55.887.0 ]--
r 139         PFNode s = new PFNode(g, null);
--[ 2022.11.06.16.20.55.995.0 ]--
r 139         PFNode s = new PFNode(ge, null);
--[ 2022.11.06.16.20.56.115.0 ]--
r 139         PFNode s = new PFNode(get, null);
--[ 2022.11.06.16.20.57.547.0 ]--
r 139         PFNode s = new PFNode(getPathStart, null);
--[ 2022.11.06.16.20.57.559.0 ]--
r 139         PFNode s = new PFNode(getPathStart(), null);
--[ 2022.11.06.16.21.07.116.0 ]--
r 108         
--[ 2022.11.06.16.21.07.950.0 ]--
- 108
--[ 2022.11.06.16.21.09.252.0 ]--
- 106
--[ 2022.11.06.16.21.12.843.0 ]--
r 105         
--[ 2022.11.06.16.21.12.993.0 ]--
- 105
--[ 2022.11.06.16.21.13.776.0 ]--
r 138 
--[ 2022.11.06.16.21.25.809.0 ]--
+ 138         
--[ 2022.11.06.16.21.25.962.0 ]--
r 138         array[loc.getI()][loc.getJ()] = true;
--[ 2022.11.06.16.21.29.253.0 ]--
r 138         array[g.getI()][loc.getJ()] = true;
--[ 2022.11.06.16.21.29.366.0 ]--
r 138         array[ge.getI()][loc.getJ()] = true;
--[ 2022.11.06.16.21.29.481.0 ]--
r 138         array[get.getI()][loc.getJ()] = true;
--[ 2022.11.06.16.21.31.001.0 ]--
r 138         array[getPathStart.getI()][loc.getJ()] = true;
--[ 2022.11.06.16.21.31.012.0 ]--
r 138         array[getPathStart().getI()][loc.getJ()] = true;
--[ 2022.11.06.16.21.32.443.0 ]--
r 138         array[getPathStart().getI()][g.getJ()] = true;
--[ 2022.11.06.16.21.32.552.0 ]--
r 138         array[getPathStart().getI()][ge.getJ()] = true;
--[ 2022.11.06.16.21.32.685.0 ]--
r 138         array[getPathStart().getI()][get.getJ()] = true;
--[ 2022.11.06.16.21.34.226.0 ]--
r 138         array[getPathStart().getI()][getPathStart.getJ()] = true;
--[ 2022.11.06.16.21.34.238.0 ]--
r 138         array[getPathStart().getI()][getPathStart().getJ()] = true;
--[ 2022.11.06.16.24.34.424.0 ]--
r 129         /pq = new MinPQ<PFNode>();
--[ 2022.11.06.16.24.34.640.0 ]--
r 129         pq = new MinPQ<PFNode>();
--[ 2022.11.06.16.24.39.393.0 ]--
r 130         /array = new boolean[N][N];
--[ 2022.11.06.16.24.39.620.0 ]--
r 130         array = new boolean[N][N];
--[ 2022.11.06.16.25.33.200.0 ]--
r 10     MinPQ<PFNode> pq ;
--[ 2022.11.06.16.25.33.747.0 ]--
r 10     MinPQ<PFNode> pq;
--[ 2022.11.06.16.25.50.125.0 ]--
r 129         
--[ 2022.11.06.16.25.50.904.0 ]--
- 129
--[ 2022.11.06.16.25.54.834.0 ]--
r 134     
--[ 2022.11.06.16.25.54.984.0 ]--
r 134         
--[ 2022.11.06.16.25.55.744.0 ]--
r 134         pq = new MinPQ<PFNode>();
--[ 2022.11.06.16.26.12.616.0 ]--
r 134         pq = new MinPQ<>();
--[ 2022.11.06.16.26.25.761.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.16.29.58.802.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.06.16.30.03.836.0 ]--
r 46     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2022.11.06.16.30.07.377.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.16.54.32.060.0 ]--
:/src/Pathfinder.java
r 58             this.cost = this.prevNode.g
--[ 2022.11.06.16.54.32.161.0 ]--
r 58             this.cost = this.prevNode.ge
--[ 2022.11.06.16.54.32.250.0 ]--
r 58             this.cost = this.prevNode.get
--[ 2022.11.06.16.54.32.821.0 ]--
r 58             this.cost = this.prevNode.getCost
--[ 2022.11.06.16.54.32.832.0 ]--
r 58             this.cost = this.prevNode.getCost()
--[ 2022.11.06.16.54.33.755.0 ]--
r 58             this.cost = this.prevNode.getCost(0)
--[ 2022.11.06.16.54.37.408.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.16.56.45.985.0 ]--
r 154                 b;
--[ 2022.11.06.16.56.46.235.0 ]--
r 154                 br;
--[ 2022.11.06.16.56.46.304.0 ]--
r 154                 bre;
--[ 2022.11.06.16.56.46.395.0 ]--
r 154                 brea;
--[ 2022.11.06.16.56.46.522.0 ]--
r 154                 break;
--[ 2022.11.06.16.56.47.794.0 ]--
r 154                 break
--[ 2022.11.06.16.56.48.423.0 ]--
r 154                 break;
--[ 2022.11.06.16.56.50.433.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.16.56.57.614.0 ]--
r 154                 break
--[ 2022.11.06.16.56.57.771.0 ]--
r 154                 break;
--[ 2022.11.06.16.56.58.219.0 ]--
r 154                 break;z
--[ 2022.11.06.16.56.58.705.0 ]--
r 154                 break;
--[ 2022.11.06.16.56.59.028.0 ]--
r 154                 continue;
--[ 2022.11.06.17.35.36.889.0 ]--
r 152             if (nextTile.currentTile  end) {
--[ 2022.11.06.17.35.37.319.0 ]--
r 152             if (nextTile.currentTile end) {
--[ 2022.11.06.17.35.38.732.0 ]--
r 152             if (nextTile.currentTileend) {
--[ 2022.11.06.17.35.39.435.0 ]--
r 152             if (nextTile.currentTile.end) {
--[ 2022.11.06.17.35.39.747.0 ]--
r 152             if (nextTile.currentTile.eend) {
--[ 2022.11.06.17.35.39.906.0 ]--
r 152             if (nextTile.currentTile.eqend) {
--[ 2022.11.06.17.35.40.026.0 ]--
r 152             if (nextTile.currentTile.equend) {
--[ 2022.11.06.17.35.40.705.0 ]--
r 152             if (nextTile.currentTile.equalsend) {
--[ 2022.11.06.17.35.40.716.0 ]--
r 152             if (nextTile.currentTile.equals()end) {
--[ 2022.11.06.17.35.42.138.0 ]--
r 152             if (nextTile.currentTile.equals(e)end) {
--[ 2022.11.06.17.35.42.255.0 ]--
r 152             if (nextTile.currentTile.equals(en)end) {
--[ 2022.11.06.17.35.42.342.0 ]--
r 152             if (nextTile.currentTile.equals(end)end) {
--[ 2022.11.06.17.35.45.410.0 ]--
r 152             if (nextTile.currentTile.equals(end)en) {
--[ 2022.11.06.17.35.45.551.0 ]--
r 152             if (nextTile.currentTile.equals(end)e) {
--[ 2022.11.06.17.35.45.734.0 ]--
r 152             if (nextTile.currentTile.equals(end)) {
--[ 2022.11.06.17.36.18.824.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.17.39.14.862.0 ]--
+ 193             
--[ 2022.11.06.17.39.23.582.0 ]--
+ 11     
--[ 2022.11.06.17.39.26.065.0 ]--
r 11     S
--[ 2022.11.06.17.39.26.273.0 ]--
r 11     St
--[ 2022.11.06.17.39.26.350.0 ]--
r 11     Sta
--[ 2022.11.06.17.39.27.010.0 ]--
r 11     Stack
--[ 2022.11.06.17.39.27.793.0 ]--
r 11     Stack<>
--[ 2022.11.06.17.39.28.512.0 ]--
r 11     Stack<C>
--[ 2022.11.06.17.39.28.652.0 ]--
r 11     Stack<Co>
--[ 2022.11.06.17.39.28.788.0 ]--
r 11     Stack<Coo>
--[ 2022.11.06.17.39.28.877.0 ]--
r 11     Stack<Coor>
--[ 2022.11.06.17.39.28.995.0 ]--
r 11     Stack<Coord>
--[ 2022.11.06.17.39.30.992.0 ]--
r 11     Stack<Coord> 
--[ 2022.11.06.17.39.36.672.0 ]--
r 11     Stack<Coord> p
--[ 2022.11.06.17.39.36.787.0 ]--
r 11     Stack<Coord> pa
--[ 2022.11.06.17.39.36.935.0 ]--
r 11     Stack<Coord> pat
--[ 2022.11.06.17.39.37.023.0 ]--
r 11     Stack<Coord> path
--[ 2022.11.06.17.39.38.815.0 ]--
r 11     Stack<Coord> pat
--[ 2022.11.06.17.39.39.029.0 ]--
r 11     Stack<Coord> pa
--[ 2022.11.06.17.39.39.214.0 ]--
r 11     Stack<Coord> p
--[ 2022.11.06.17.39.39.418.0 ]--
r 11     Stack<Coord> 
--[ 2022.11.06.17.39.39.861.0 ]--
r 11     Stack<Coord> p
--[ 2022.11.06.17.39.39.968.0 ]--
r 11     Stack<Coord> pa
--[ 2022.11.06.17.39.40.070.0 ]--
r 11     Stack<Coord> pat
--[ 2022.11.06.17.39.40.159.0 ]--
r 11     Stack<Coord> path
--[ 2022.11.06.17.39.41.095.0 ]--
r 11     Stack<Coord> path;
--[ 2022.11.06.17.39.57.136.0 ]--
r 194             f
--[ 2022.11.06.17.39.57.203.0 ]--
r 194             fo
--[ 2022.11.06.17.39.57.339.0 ]--
r 194             for
--[ 2022.11.06.17.39.58.323.0 ]--
r 194             for 
--[ 2022.11.06.17.39.59.771.0 ]--
r 194             for p
--[ 2022.11.06.17.39.59.851.0 ]--
r 194             for pa
--[ 2022.11.06.17.39.59.963.0 ]--
r 194             for pat
--[ 2022.11.06.17.40.00.055.0 ]--
r 194             for path
--[ 2022.11.06.17.40.00.694.0 ]--
r 194             for path 
--[ 2022.11.06.17.40.00.802.0 ]--
r 194             for path =
--[ 2022.11.06.17.40.00.912.0 ]--
r 194             for path = 
--[ 2022.11.06.17.40.01.302.0 ]--
r 194             for path =
--[ 2022.11.06.17.40.01.498.0 ]--
r 194             for path 
--[ 2022.11.06.17.40.01.652.0 ]--
r 194             for path
--[ 2022.11.06.17.40.01.802.0 ]--
r 194             for pat
--[ 2022.11.06.17.40.01.982.0 ]--
r 194             for pa
--[ 2022.11.06.17.40.02.151.0 ]--
r 194             for p
--[ 2022.11.06.17.40.02.588.0 ]--
r 194             for 
--[ 2022.11.06.17.40.02.745.0 ]--
r 194             for ()
--[ 2022.11.06.17.40.03.488.0 ]--
r 194             for (p)
--[ 2022.11.06.17.40.03.558.0 ]--
r 194             for (pa)
--[ 2022.11.06.17.40.03.666.0 ]--
r 194             for (pat)
--[ 2022.11.06.17.40.03.759.0 ]--
r 194             for (path)
--[ 2022.11.06.17.40.03.866.0 ]--
r 194             for (path )
--[ 2022.11.06.17.40.04.022.0 ]--
r 194             for (path =)
--[ 2022.11.06.17.40.04.146.0 ]--
r 194             for (path = )
--[ 2022.11.06.17.40.04.752.0 ]--
r 194             for (path = n)
--[ 2022.11.06.17.40.04.894.0 ]--
r 194             for (path = ne)
--[ 2022.11.06.17.40.04.921.0 ]--
r 194             for (path = new)
--[ 2022.11.06.17.40.05.097.0 ]--
r 194             for (path = new )
--[ 2022.11.06.17.40.05.629.0 ]--
r 194             for (path = new S)
--[ 2022.11.06.17.40.05.753.0 ]--
r 194             for (path = new St)
--[ 2022.11.06.17.40.05.855.0 ]--
r 194             for (path = new Sta)
--[ 2022.11.06.17.40.06.332.0 ]--
r 194             for (path = new Stack)
--[ 2022.11.06.17.40.06.339.0 ]--
r 194             for (path = new Stack<>)
--[ 2022.11.06.17.40.06.346.0 ]--
r 194             for (path = new Stack<>())
--[ 2022.11.06.17.40.08.806.0 ]--
r 194             for (path = new Stack<>();)
--[ 2022.11.06.17.40.10.033.0 ]--
r 194             for (path = new Stack<>(); )
--[ 2022.11.06.17.40.10.348.0 ]--
r 194             for (path = new Stack<>(); c)
--[ 2022.11.06.17.40.11.559.0 ]--
r 194             for (path = new Stack<>(); c )
--[ 2022.11.06.17.40.11.930.0 ]--
r 194             for (path = new Stack<>(); c ~)
--[ 2022.11.06.17.40.12.223.0 ]--
r 194             for (path = new Stack<>(); c ~=)
--[ 2022.11.06.17.40.12.419.0 ]--
r 194             for (path = new Stack<>(); c ~= )
--[ 2022.11.06.17.40.12.568.0 ]--
r 194             for (path = new Stack<>(); c ~= n)
--[ 2022.11.06.17.40.12.987.0 ]--
r 194             for (path = new Stack<>(); c ~= )
--[ 2022.11.06.17.40.13.127.0 ]--
r 194             for (path = new Stack<>(); c ~=)
--[ 2022.11.06.17.40.13.323.0 ]--
r 194             for (path = new Stack<>(); c ~)
--[ 2022.11.06.17.40.13.488.0 ]--
r 194             for (path = new Stack<>(); c )
--[ 2022.11.06.17.40.13.774.0 ]--
r 194             for (path = new Stack<>(); c !)
--[ 2022.11.06.17.40.14.900.0 ]--
r 194             for (path = new Stack<>(); c !=)
--[ 2022.11.06.17.40.16.552.0 ]--
r 194             for (path = new Stack<>(); c != )
--[ 2022.11.06.17.40.16.601.0 ]--
r 194             for (path = new Stack<>(); c != n)
--[ 2022.11.06.17.40.16.866.0 ]--
r 194             for (path = new Stack<>(); c != nu)
--[ 2022.11.06.17.40.16.990.0 ]--
r 194             for (path = new Stack<>(); c != nul)
--[ 2022.11.06.17.40.17.144.0 ]--
r 194             for (path = new Stack<>(); c != null)
--[ 2022.11.06.17.40.17.568.0 ]--
r 194             for (path = new Stack<>(); c != null;)
--[ 2022.11.06.17.40.27.261.0 ]--
+ 194             
--[ 2022.11.06.17.40.28.501.0 ]--
r 194             i
--[ 2022.11.06.17.40.28.603.0 ]--
r 194             if
--[ 2022.11.06.17.40.28.772.0 ]--
r 194             if ()
--[ 2022.11.06.17.40.29.774.0 ]--
r 194             if (f)
--[ 2022.11.06.17.40.29.869.0 ]--
r 194             if (fo)
--[ 2022.11.06.17.40.30.124.0 ]--
r 194             if (fon)
--[ 2022.11.06.17.40.30.172.0 ]--
r 194             if (fond)
--[ 2022.11.06.17.40.30.853.0 ]--
r 194             if (fon)
--[ 2022.11.06.17.40.30.991.0 ]--
r 194             if (fo)
--[ 2022.11.06.17.40.31.451.0 ]--
r 194             if (fou)
--[ 2022.11.06.17.40.31.663.0 ]--
r 194             if (foun)
--[ 2022.11.06.17.40.31.812.0 ]--
r 194             if (found)
--[ 2022.11.06.17.40.33.658.0 ]--
r 194             if (found) 
--[ 2022.11.06.17.40.34.094.0 ]--
r 194             if (found) {
--[ 2022.11.06.17.40.34.372.0 ]--
+ 195 
+ 196 }
--[ 2022.11.06.17.40.34.397.0 ]--
r 196             }
--[ 2022.11.06.17.40.34.415.0 ]--
r 195                 
--[ 2022.11.06.17.40.45.954.0 ]--
r 197             
--[ 2022.11.06.17.40.47.089.0 ]--
r 195                 for (path = new Stack<>(); c != null;)
--[ 2022.11.06.17.40.48.239.0 ]--
+ 195                 
--[ 2022.11.06.17.40.50.535.0 ]--
r 195                 f
--[ 2022.11.06.17.40.50.625.0 ]--
r 195                 fo
--[ 2022.11.06.17.40.50.700.0 ]--
r 195                 fou
--[ 2022.11.06.17.40.50.919.0 ]--
r 195                 foun
--[ 2022.11.06.17.40.51.043.0 ]--
r 195                 found
--[ 2022.11.06.17.40.51.740.0 ]--
r 195                 foundp
--[ 2022.11.06.17.40.51.823.0 ]--
r 195                 foundpa
--[ 2022.11.06.17.40.51.943.0 ]--
r 195                 foundpat
--[ 2022.11.06.17.40.51.989.0 ]--
r 195                 foundpath
--[ 2022.11.06.17.40.52.509.0 ]--
r 195                 foundpat
--[ 2022.11.06.17.40.52.671.0 ]--
r 195                 foundpa
--[ 2022.11.06.17.40.52.848.0 ]--
r 195                 foundp
--[ 2022.11.06.17.40.53.029.0 ]--
r 195                 found
--[ 2022.11.06.17.40.53.218.0 ]--
r 195                 foun
--[ 2022.11.06.17.40.54.195.0 ]--
r 195                 found
--[ 2022.11.06.17.40.55.711.0 ]--
r 195                 foundP
--[ 2022.11.06.17.40.55.910.0 ]--
r 195                 foundPa
--[ 2022.11.06.17.40.56.065.0 ]--
r 195                 foundPat
--[ 2022.11.06.17.40.56.177.0 ]--
r 195                 foundPath
--[ 2022.11.06.17.41.08.803.0 ]--
r 195                 foundPat
--[ 2022.11.06.17.41.08.942.0 ]--
r 195                 foundPa
--[ 2022.11.06.17.41.09.110.0 ]--
r 195                 foundP
--[ 2022.11.06.17.41.09.329.0 ]--
r 195                 found
--[ 2022.11.06.17.41.09.499.0 ]--
r 195                 foun
--[ 2022.11.06.17.41.09.685.0 ]--
r 195                 fou
--[ 2022.11.06.17.41.09.874.0 ]--
r 195                 fo
--[ 2022.11.06.17.41.10.064.0 ]--
r 195                 f
--[ 2022.11.06.17.41.10.521.0 ]--
r 195                 
--[ 2022.11.06.17.41.17.846.0 ]--
r 195                 c
--[ 2022.11.06.17.41.17.966.0 ]--
r 195                 cu
--[ 2022.11.06.17.41.18.067.0 ]--
r 195                 cur
--[ 2022.11.06.17.41.18.214.0 ]--
r 195                 curr
--[ 2022.11.06.17.41.18.329.0 ]--
r 195                 curre
--[ 2022.11.06.17.41.18.462.0 ]--
r 195                 curren
--[ 2022.11.06.17.41.18.608.0 ]--
r 195                 current
--[ 2022.11.06.17.41.19.275.0 ]--
r 195                 currentn
--[ 2022.11.06.17.41.19.656.0 ]--
r 195                 current
--[ 2022.11.06.17.41.19.735.0 ]--
r 195                 currentN
--[ 2022.11.06.17.41.19.868.0 ]--
r 195                 currentNo
--[ 2022.11.06.17.41.19.956.0 ]--
r 195                 currentNod
--[ 2022.11.06.17.41.20.108.0 ]--
r 195                 currentNode
--[ 2022.11.06.17.41.20.701.0 ]--
r 195                 currentNode 
--[ 2022.11.06.17.41.20.795.0 ]--
r 195                 currentNode
--[ 2022.11.06.17.41.20.846.0 ]--
r 195                 currentNode 
--[ 2022.11.06.17.41.21.412.0 ]--
r 195                 currentNode
--[ 2022.11.06.17.41.21.963.0 ]--
r 195                 currentNode 
--[ 2022.11.06.17.41.22.116.0 ]--
r 195                 currentNode =
--[ 2022.11.06.17.41.22.233.0 ]--
r 195                 currentNode = 
--[ 2022.11.06.17.41.23.807.0 ]--
r 195                 currentNode =
--[ 2022.11.06.17.41.24.134.0 ]--
r 195                 currentNode 
--[ 2022.11.06.17.41.24.893.0 ]--
r 195                 currentNode
--[ 2022.11.06.17.41.25.374.0 ]--
r 195                 currentNod
--[ 2022.11.06.17.41.27.436.0 ]--
r 195                 currentNo
--[ 2022.11.06.17.41.27.678.0 ]--
r 195                 currentN
--[ 2022.11.06.17.41.27.920.0 ]--
r 195                 current
--[ 2022.11.06.17.41.28.139.0 ]--
r 195                 curren
--[ 2022.11.06.17.41.28.349.0 ]--
r 195                 curre
--[ 2022.11.06.17.41.28.536.0 ]--
r 195                 curr
--[ 2022.11.06.17.41.28.748.0 ]--
r 195                 cur
--[ 2022.11.06.17.41.28.960.0 ]--
r 195                 cu
--[ 2022.11.06.17.41.29.178.0 ]--
r 195                 c
--[ 2022.11.06.17.41.29.408.0 ]--
r 195                 
--[ 2022.11.06.17.42.42.754.0 ]--
r 195                 P
--[ 2022.11.06.17.42.43.002.0 ]--
r 195                 PF
--[ 2022.11.06.17.42.43.627.0 ]--
r 195                 PFNode
--[ 2022.11.06.17.42.44.055.0 ]--
r 195                 PFNode 
--[ 2022.11.06.17.42.44.604.0 ]--
r 195                 PFNode p
--[ 2022.11.06.17.42.44.725.0 ]--
r 195                 PFNode pa
--[ 2022.11.06.17.42.44.812.0 ]--
r 195                 PFNode pat
--[ 2022.11.06.17.42.44.940.0 ]--
r 195                 PFNode path
--[ 2022.11.06.17.42.45.232.0 ]--
r 195                 PFNode pathN
--[ 2022.11.06.17.42.45.364.0 ]--
r 195                 PFNode pathNo
--[ 2022.11.06.17.42.45.395.0 ]--
r 195                 PFNode pathNod
--[ 2022.11.06.17.42.45.547.0 ]--
r 195                 PFNode pathNode
--[ 2022.11.06.17.42.45.902.0 ]--
r 195                 PFNode pathNode 
--[ 2022.11.06.17.42.46.039.0 ]--
r 195                 PFNode pathNode =
--[ 2022.11.06.17.42.46.154.0 ]--
r 195                 PFNode pathNode = 
--[ 2022.11.06.17.42.52.753.0 ]--
r 195                 PFNode pathNode = c
--[ 2022.11.06.17.42.52.802.0 ]--
r 195                 PFNode pathNode = cu
--[ 2022.11.06.17.42.53.765.0 ]--
r 195                 PFNode pathNode = c
--[ 2022.11.06.17.42.53.921.0 ]--
r 195                 PFNode pathNode = 
--[ 2022.11.06.17.43.40.576.0 ]--
r 195                 PFNode pathNode =
--[ 2022.11.06.17.43.40.780.0 ]--
r 195                 PFNode pathNode 
--[ 2022.11.06.17.43.40.953.0 ]--
r 195                 PFNode pathNode
--[ 2022.11.06.17.43.41.154.0 ]--
r 195                 PFNode pathNod
--[ 2022.11.06.17.43.41.351.0 ]--
r 195                 PFNode pathNo
--[ 2022.11.06.17.43.41.842.0 ]--
r 195                 PFNode pathN
--[ 2022.11.06.17.43.41.926.0 ]--
r 195                 PFNode path
--[ 2022.11.06.17.43.42.010.0 ]--
r 195                 PFNode pat
--[ 2022.11.06.17.43.42.094.0 ]--
r 195                 PFNode pa
--[ 2022.11.06.17.43.42.177.0 ]--
r 195                 PFNode p
--[ 2022.11.06.17.43.42.260.0 ]--
r 195                 PFNode 
--[ 2022.11.06.17.43.42.343.0 ]--
r 195                 PFNode
--[ 2022.11.06.17.43.42.427.0 ]--
r 195                 PFNod
--[ 2022.11.06.17.43.42.510.0 ]--
r 195                 PFNo
--[ 2022.11.06.17.43.42.922.0 ]--
r 195                 PFN
--[ 2022.11.06.17.43.43.119.0 ]--
r 195                 PF
--[ 2022.11.06.17.43.43.315.0 ]--
r 195                 P
--[ 2022.11.06.17.43.43.528.0 ]--
r 195                 
--[ 2022.11.06.17.43.43.741.0 ]--
- 195
--[ 2022.11.06.17.45.05.058.0 ]--
r 195                 
--[ 2022.11.06.17.45.09.971.0 ]--
r 195                 P
--[ 2022.11.06.17.45.10.071.0 ]--
r 195                 PF
--[ 2022.11.06.17.45.10.750.0 ]--
r 195                 P
--[ 2022.11.06.17.45.10.888.0 ]--
r 195                 
--[ 2022.11.06.17.45.11.067.0 ]--
r 195                 t
--[ 2022.11.06.17.45.11.141.0 ]--
r 195                 th
--[ 2022.11.06.17.45.11.192.0 ]--
r 195                 thi
--[ 2022.11.06.17.45.11.270.0 ]--
r 195                 this
--[ 2022.11.06.17.45.13.547.0 ]--
r 195                 thi
--[ 2022.11.06.17.45.13.695.0 ]--
r 195                 th
--[ 2022.11.06.17.45.13.869.0 ]--
r 195                 t
--[ 2022.11.06.17.45.14.061.0 ]--
r 195                 
--[ 2022.11.06.17.45.15.383.0 ]--
r 195                 F
--[ 2022.11.06.17.45.15.802.0 ]--
r 195                 
--[ 2022.11.06.17.45.16.572.0 ]--
r 195                 F
--[ 2022.11.06.17.45.16.838.0 ]--
r 195                 
--[ 2022.11.06.17.45.17.222.0 ]--
r 195                 this
--[ 2022.11.06.17.45.17.641.0 ]--
r 195                 
--[ 2022.11.06.17.45.18.031.0 ]--
r 195                 PF
--[ 2022.11.06.17.45.18.412.0 ]--
r 195                 
--[ 2022.11.06.17.45.18.755.0 ]--
r 195                 for (path = new Stack<>(); c != null;)
--[ 2022.11.06.17.45.37.106.0 ]--
r 195                 for (path = new Stack<>();  != null;)
--[ 2022.11.06.17.45.37.969.0 ]--
r 195                 for (path = new Stack<>(); t != null;)
--[ 2022.11.06.17.45.38.044.0 ]--
r 195                 for (path = new Stack<>(); th != null;)
--[ 2022.11.06.17.45.38.092.0 ]--
r 195                 for (path = new Stack<>(); thi != null;)
--[ 2022.11.06.17.45.38.201.0 ]--
r 195                 for (path = new Stack<>(); this != null;)
--[ 2022.11.06.17.45.38.398.0 ]--
r 195                 for (path = new Stack<>(); this. != null;)
--[ 2022.11.06.17.45.38.751.0 ]--
r 195                 for (path = new Stack<>(); this.p != null;)
--[ 2022.11.06.17.45.38.868.0 ]--
r 195                 for (path = new Stack<>(); this.pr != null;)
--[ 2022.11.06.17.45.38.933.0 ]--
r 195                 for (path = new Stack<>(); this.pre != null;)
--[ 2022.11.06.17.45.39.776.0 ]--
r 195                 for (path = new Stack<>(); this.prev != null;)
--[ 2022.11.06.17.45.42.726.0 ]--
r 195                 for (path = new Stack<>(); this.pre != null;)
--[ 2022.11.06.17.45.42.938.0 ]--
r 195                 for (path = new Stack<>(); this.pr != null;)
--[ 2022.11.06.17.45.43.198.0 ]--
r 195                 for (path = new Stack<>(); this.p != null;)
--[ 2022.11.06.17.45.43.475.0 ]--
r 195                 for (path = new Stack<>(); this. != null;)
--[ 2022.11.06.17.45.44.111.0 ]--
r 195                 for (path = new Stack<>(); this.c != null;)
--[ 2022.11.06.17.45.44.236.0 ]--
r 195                 for (path = new Stack<>(); this.cu != null;)
--[ 2022.11.06.17.45.44.925.0 ]--
r 195                 for (path = new Stack<>(); this.c != null;)
--[ 2022.11.06.17.45.45.102.0 ]--
r 195                 for (path = new Stack<>(); this. != null;)
--[ 2022.11.06.17.45.45.282.0 ]--
r 195                 for (path = new Stack<>(); this != null;)
--[ 2022.11.06.17.45.46.452.0 ]--
r 195                 for (path = new Stack<>(); thi != null;)
--[ 2022.11.06.17.45.46.649.0 ]--
r 195                 for (path = new Stack<>(); th != null;)
--[ 2022.11.06.17.45.46.874.0 ]--
r 195                 for (path = new Stack<>(); t != null;)
--[ 2022.11.06.17.45.47.380.0 ]--
r 195                 for (path = new Stack<>();  != null;)
--[ 2022.11.06.17.47.36.979.0 ]--
r 210         return ;
--[ 2022.11.06.17.47.37.498.0 ]--
r 210         return p;
--[ 2022.11.06.17.47.37.599.0 ]--
r 210         return pq;
--[ 2022.11.06.17.47.38.368.0 ]--
r 210         return pq.;
--[ 2022.11.06.17.47.39.334.0 ]--
r 210         return pq.size;
--[ 2022.11.06.17.47.39.344.0 ]--
r 210         return pq.size();
--[ 2022.11.06.17.47.40.923.0 ]--
r 197 
--[ 2022.11.06.17.48.05.541.0 ]--
r 195                 
--[ 2022.11.06.17.48.05.682.0 ]--
- 195
--[ 2022.11.06.17.48.07.770.0 ]--
- 194
r 194            
--[ 2022.11.06.17.48.07.952.0 ]--
- 194
--[ 2022.11.06.17.48.09.529.0 ]--
- 194
--[ 2022.11.06.17.48.12.503.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.17.49.38.684.0 ]--
+ 154                 
--[ 2022.11.06.17.49.40.846.0 ]--
r 154                 f
--[ 2022.11.06.17.49.40.944.0 ]--
r 154                 fo
--[ 2022.11.06.17.49.41.029.0 ]--
r 154                 for
--[ 2022.11.06.17.49.41.185.0 ]--
r 154                 for 
--[ 2022.11.06.17.49.41.849.0 ]--
r 154                 for ()
--[ 2022.11.06.17.49.44.724.0 ]--
r 154                 for (p)
--[ 2022.11.06.17.49.44.826.0 ]--
r 154                 for (pa)
--[ 2022.11.06.17.49.44.938.0 ]--
r 154                 for (pat)
--[ 2022.11.06.17.49.45.026.0 ]--
r 154                 for (path)
--[ 2022.11.06.17.49.45.328.0 ]--
r 154                 for (path )
--[ 2022.11.06.17.49.45.412.0 ]--
r 154                 for (path =)
--[ 2022.11.06.17.49.45.533.0 ]--
r 154                 for (path = )
--[ 2022.11.06.17.49.46.107.0 ]--
r 154                 for (path = n)
--[ 2022.11.06.17.49.46.171.0 ]--
r 154                 for (path = ne)
--[ 2022.11.06.17.49.46.257.0 ]--
r 154                 for (path = new)
--[ 2022.11.06.17.49.46.369.0 ]--
r 154                 for (path = new )
--[ 2022.11.06.17.49.46.713.0 ]--
r 154                 for (path = new S)
--[ 2022.11.06.17.49.46.866.0 ]--
r 154                 for (path = new St)
--[ 2022.11.06.17.49.47.187.0 ]--
r 154                 for (path = new Stack)
--[ 2022.11.06.17.49.47.193.0 ]--
r 154                 for (path = new Stack<>)
--[ 2022.11.06.17.49.47.200.0 ]--
r 154                 for (path = new Stack<>())
--[ 2022.11.06.17.49.48.952.0 ]--
r 154                 for (path = new Stack<>();)
--[ 2022.11.06.17.49.49.159.0 ]--
r 154                 for (path = new Stack<>(); )
--[ 2022.11.06.17.50.01.698.0 ]--
r 154                 for (path = new Stack<>(); n)
--[ 2022.11.06.17.50.01.762.0 ]--
r 154                 for (path = new Stack<>(); ne)
--[ 2022.11.06.17.50.01.973.0 ]--
r 154                 for (path = new Stack<>(); nex)
--[ 2022.11.06.17.50.03.435.0 ]--
r 154                 for (path = new Stack<>(); next)
--[ 2022.11.06.17.50.03.510.0 ]--
r 154                 for (path = new Stack<>(); nexti)
--[ 2022.11.06.17.50.03.578.0 ]--
r 154                 for (path = new Stack<>(); nextil)
--[ 2022.11.06.17.50.03.703.0 ]--
r 154                 for (path = new Stack<>(); nextile)
--[ 2022.11.06.17.50.03.933.0 ]--
r 154                 for (path = new Stack<>(); nextTile.found)
--[ 2022.11.06.17.50.03.946.0 ]--
r 154                 for (path = new Stack<>(); nextTile;)
--[ 2022.11.06.17.50.03.957.0 ]--
r 154                 for (path = new Stack<>(); nextTile.found)
--[ 2022.11.06.17.50.03.971.0 ]--
r 154                 for (path = new Stack<>(); nextTile.found;)
--[ 2022.11.06.17.50.04.667.0 ]--
r 154                 for (path = new Stack<>(); nextTile.found)
--[ 2022.11.06.17.50.04.832.0 ]--
r 154                 for (path = new Stack<>(); nextTile.foun)
--[ 2022.11.06.17.50.05.015.0 ]--
r 154                 for (path = new Stack<>(); nextTile.fou)
--[ 2022.11.06.17.50.05.191.0 ]--
r 154                 for (path = new Stack<>(); nextTile.fo)
--[ 2022.11.06.17.50.05.367.0 ]--
r 154                 for (path = new Stack<>(); nextTile.f)
--[ 2022.11.06.17.50.05.537.0 ]--
r 154                 for (path = new Stack<>(); nextTile.)
--[ 2022.11.06.17.50.06.539.0 ]--
r 154                 for (path = new Stack<>(); nextTile.p)
--[ 2022.11.06.17.50.06.629.0 ]--
r 154                 for (path = new Stack<>(); nextTile.pr)
--[ 2022.11.06.17.50.06.730.0 ]--
r 154                 for (path = new Stack<>(); nextTile.pre)
--[ 2022.11.06.17.50.07.411.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode)
--[ 2022.11.06.17.50.07.792.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode )
--[ 2022.11.06.17.50.07.908.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode =)
--[ 2022.11.06.17.50.08.080.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode ==)
--[ 2022.11.06.17.50.08.212.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == )
--[ 2022.11.06.17.50.08.403.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == n)
--[ 2022.11.06.17.50.08.609.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == nu)
--[ 2022.11.06.17.50.08.742.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == nul)
--[ 2022.11.06.17.50.08.885.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null)
--[ 2022.11.06.17.50.32.814.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null;)
--[ 2022.11.06.17.50.32.971.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; )
--[ 2022.11.06.17.50.34.194.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; n)
--[ 2022.11.06.17.50.34.268.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; ne)
--[ 2022.11.06.17.50.34.452.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nex)
--[ 2022.11.06.17.50.34.563.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; next)
--[ 2022.11.06.17.50.34.701.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nexti)
--[ 2022.11.06.17.50.34.778.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextil)
--[ 2022.11.06.17.50.34.945.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextile)
--[ 2022.11.06.17.50.35.225.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile)
--[ 2022.11.06.17.50.35.781.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile.)
--[ 2022.11.06.17.50.37.415.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile.p)
--[ 2022.11.06.17.50.37.565.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile.pr)
--[ 2022.11.06.17.50.37.663.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile.pre)
--[ 2022.11.06.17.50.38.419.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile.pr)
--[ 2022.11.06.17.50.38.577.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile.p)
--[ 2022.11.06.17.50.38.778.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile.)
--[ 2022.11.06.17.50.38.966.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile)
--[ 2022.11.06.17.50.39.488.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile )
--[ 2022.11.06.17.50.39.626.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile =)
--[ 2022.11.06.17.50.39.719.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = )
--[ 2022.11.06.17.50.42.801.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = n)
--[ 2022.11.06.17.50.42.859.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = ne)
--[ 2022.11.06.17.50.43.035.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nex)
--[ 2022.11.06.17.50.43.190.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = next)
--[ 2022.11.06.17.50.43.395.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = next.)
--[ 2022.11.06.17.50.44.033.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = next)
--[ 2022.11.06.17.50.44.240.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextT)
--[ 2022.11.06.17.50.44.376.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTi)
--[ 2022.11.06.17.50.44.538.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTil)
--[ 2022.11.06.17.50.44.698.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTile)
--[ 2022.11.06.17.50.44.987.0 ]--
+ 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTile
r 155                 )
--[ 2022.11.06.17.50.45.666.0 ]--
- 154
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTile)
--[ 2022.11.06.17.50.46.362.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTile.)
--[ 2022.11.06.17.50.46.641.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTile.p)
--[ 2022.11.06.17.50.46.718.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTile.pr)
--[ 2022.11.06.17.50.46.803.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTile.pre)
--[ 2022.11.06.17.50.46.993.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTile.prev)
--[ 2022.11.06.17.50.47.634.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTile.prevNode)
--[ 2022.11.06.17.52.16.249.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTile.prevNode) 
--[ 2022.11.06.17.52.16.594.0 ]--
r 154                 for (path = new Stack<>(); nextTile.prevNode == null; nextTile = nextTile.prevNode) {
--[ 2022.11.06.17.52.17.246.0 ]--
+ 155 
+ 156 }
--[ 2022.11.06.17.52.17.263.0 ]--
r 156                 }
--[ 2022.11.06.17.52.17.274.0 ]--
r 155                     
--[ 2022.11.06.17.52.20.259.0 ]--
r 155                     p
--[ 2022.11.06.17.52.20.339.0 ]--
r 155                     pa
--[ 2022.11.06.17.52.20.435.0 ]--
r 155                     pat
--[ 2022.11.06.17.52.20.515.0 ]--
r 155                     path
--[ 2022.11.06.17.52.20.796.0 ]--
r 155                     path.
--[ 2022.11.06.17.52.21.032.0 ]--
r 155                     path.s
--[ 2022.11.06.17.52.21.427.0 ]--
r 155                     path.
--[ 2022.11.06.17.52.21.665.0 ]--
r 155                     path.p
--[ 2022.11.06.17.52.21.762.0 ]--
r 155                     path.pu
--[ 2022.11.06.17.52.21.883.0 ]--
r 155                     path.pus
--[ 2022.11.06.17.52.22.028.0 ]--
r 155                     path.push
--[ 2022.11.06.17.52.22.770.0 ]--
r 155                     path.push()
--[ 2022.11.06.17.52.22.777.0 ]--
r 155                     path.push();
--[ 2022.11.06.17.52.25.269.0 ]--
r 155                     path.push(n);
--[ 2022.11.06.17.52.25.470.0 ]--
r 155                     path.push(ne);
--[ 2022.11.06.17.52.25.829.0 ]--
r 155                     path.push(nex);
--[ 2022.11.06.17.52.26.114.0 ]--
r 155                     path.push(next);
--[ 2022.11.06.17.52.26.710.0 ]--
r 155                     path.push(nextTile);
--[ 2022.11.06.17.52.27.036.0 ]--
r 155                     path.push(nextTile.);
--[ 2022.11.06.17.52.27.277.0 ]--
r 155                     path.push(nextTile.c);
--[ 2022.11.06.17.52.27.344.0 ]--
r 155                     path.push(nextTile.cu);
--[ 2022.11.06.17.52.27.510.0 ]--
r 155                     path.push(nextTile.cur);
--[ 2022.11.06.17.52.27.653.0 ]--
r 155                     path.push(nextTile.currentTile);
--[ 2022.11.06.17.54.58.549.0 ]--
r 213         return p;
--[ 2022.11.06.17.54.59.624.0 ]--
r 213         return path;
--[ 2022.11.06.17.55.06.620.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.17.57.05.710.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.06.17.57.06.227.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.06.17.57.09.177.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.17.57.32.910.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.06.17.57.33.673.0 ]--
r 46     private final static String emapFilename = emaps[3];        // change index to load a different elevation map
--[ 2022.11.06.17.57.35.994.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.17.58.01.571.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.17.58.21.166.0 ]--
:/src/Pathfinder.java
r 152             /System.out.println("Current Loc: " + nextTile.currentTile);
--[ 2022.11.06.17.58.21.296.0 ]--
r 152             //System.out.println("Current Loc: " + nextTile.currentTile);
--[ 2022.11.06.17.58.23.976.0 ]--
r 150             /System.out.println("size PQ " + pq.size());
--[ 2022.11.06.17.58.24.109.0 ]--
r 150             //System.out.println("size PQ " + pq.size());
--[ 2022.11.06.17.58.27.430.0 ]--
r 163                 /System.out.println("Above created");
--[ 2022.11.06.17.58.27.559.0 ]--
r 163                 //System.out.println("Above created");
--[ 2022.11.06.17.58.29.805.0 ]--
r 172                 /System.out.println("Below created");
--[ 2022.11.06.17.58.29.932.0 ]--
r 172                 //System.out.println("Below created");
--[ 2022.11.06.17.58.32.410.0 ]--
r 181                 /System.out.println("Left created");
--[ 2022.11.06.17.58.32.542.0 ]--
r 181                 //System.out.println("Left created");
--[ 2022.11.06.17.58.35.040.0 ]--
r 191                 /System.out.println("Right created");
--[ 2022.11.06.17.58.35.174.0 ]--
r 191                 //System.out.println("Right created");
--[ 2022.11.06.17.58.42.223.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.06.17.58.42.727.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.06.17.58.43.325.0 ]--
r 46     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2022.11.06.17.58.46.430.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.17.59.22.843.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.17.59.48.107.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.06.17.59.48.608.0 ]--
r 46     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2022.11.06.17.59.51.820.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.00.25.880.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.00.34.056.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.06.18.00.34.323.0 ]--
r 46     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2022.11.06.18.00.34.700.0 ]--
r 46     private final static String emapFilename = emaps[10x];        // change index to load a different elevation map
--[ 2022.11.06.18.00.35.895.0 ]--
r 46     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2022.11.06.18.00.38.059.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.02.11.507.0 ]--
:/src/Pathfinder.java
+ 157                 
--[ 2022.11.06.18.02.13.283.0 ]--
r 157                 e
--[ 2022.11.06.18.02.13.835.0 ]--
r 157                 
--[ 2022.11.06.18.02.14.168.0 ]--
r 157                 P
--[ 2022.11.06.18.02.14.310.0 ]--
r 157                 PF
--[ 2022.11.06.18.02.14.979.0 ]--
r 157                 PFNode
--[ 2022.11.06.18.02.15.547.0 ]--
r 157                 PFNode 
--[ 2022.11.06.18.02.15.623.0 ]--
r 157                 PFNode =
--[ 2022.11.06.18.02.15.740.0 ]--
r 157                 PFNode = 
--[ 2022.11.06.18.02.16.268.0 ]--
r 157                 PFNode = e
--[ 2022.11.06.18.02.16.393.0 ]--
r 157                 PFNode = en
--[ 2022.11.06.18.02.16.465.0 ]--
r 157                 PFNode = end
--[ 2022.11.06.18.02.17.090.0 ]--
r 157                 PFNode = endN
--[ 2022.11.06.18.02.17.171.0 ]--
r 157                 PFNode = endNo
--[ 2022.11.06.18.02.17.284.0 ]--
r 157                 PFNode = endNod
--[ 2022.11.06.18.02.17.428.0 ]--
r 157                 PFNode = endNode
--[ 2022.11.06.18.02.18.300.0 ]--
r 157                 PFNode = endNode 
--[ 2022.11.06.18.02.18.413.0 ]--
r 157                 PFNode = endNode =
--[ 2022.11.06.18.02.18.509.0 ]--
r 157                 PFNode = endNode = 
--[ 2022.11.06.18.02.18.967.0 ]--
r 157                 PFNode = endNode =
--[ 2022.11.06.18.02.19.135.0 ]--
r 157                 PFNode = endNode 
--[ 2022.11.06.18.02.19.314.0 ]--
r 157                 PFNode = endNode
--[ 2022.11.06.18.02.22.175.0 ]--
r 157                 PFNode  endNode
--[ 2022.11.06.18.02.22.430.0 ]--
r 157                 PFNode endNode
--[ 2022.11.06.18.02.24.156.0 ]--
r 157                 PFNode endNode 
--[ 2022.11.06.18.02.24.294.0 ]--
r 157                 PFNode endNode =
--[ 2022.11.06.18.02.24.386.0 ]--
r 157                 PFNode endNode = 
--[ 2022.11.06.18.02.24.771.0 ]--
r 157                 PFNode endNode = n
--[ 2022.11.06.18.02.24.849.0 ]--
r 157                 PFNode endNode = ne
--[ 2022.11.06.18.02.25.009.0 ]--
r 157                 PFNode endNode = nex
--[ 2022.11.06.18.02.25.593.0 ]--
r 157                 PFNode endNode = nextTile
--[ 2022.11.06.18.02.25.947.0 ]--
r 157                 PFNode endNode = nextTile;
--[ 2022.11.06.18.02.45.637.0 ]--
+ 32         
--[ 2022.11.06.18.02.47.932.0 ]--
- 32
--[ 2022.11.06.18.02.49.527.0 ]--
r 31         PFNode prevNode,;
--[ 2022.11.06.18.02.49.784.0 ]--
r 31         PFNode prevNode, ;
--[ 2022.11.06.18.02.50.022.0 ]--
r 31         PFNode prevNode, e;
--[ 2022.11.06.18.02.50.137.0 ]--
r 31         PFNode prevNode, en;
--[ 2022.11.06.18.02.50.208.0 ]--
r 31         PFNode prevNode, end;
--[ 2022.11.06.18.02.50.491.0 ]--
r 31         PFNode prevNode, endN;
--[ 2022.11.06.18.02.50.594.0 ]--
r 31         PFNode prevNode, endNo;
--[ 2022.11.06.18.02.50.698.0 ]--
r 31         PFNode prevNode, endNod;
--[ 2022.11.06.18.02.50.844.0 ]--
r 31         PFNode prevNode, endNode;
--[ 2022.11.06.18.03.01.480.0 ]--
r 206         return ;
--[ 2022.11.06.18.03.02.893.0 ]--
r 206         return e;
--[ 2022.11.06.18.03.03.024.0 ]--
r 206         return en;
--[ 2022.11.06.18.03.03.098.0 ]--
r 206         return end;
--[ 2022.11.06.18.03.03.841.0 ]--
r 206         return endN;
--[ 2022.11.06.18.03.03.945.0 ]--
r 206         return endNo;
--[ 2022.11.06.18.03.07.039.0 ]--
r 206         return endN;
--[ 2022.11.06.18.03.07.238.0 ]--
r 206         return end;
--[ 2022.11.06.18.03.07.428.0 ]--
r 206         return en;
--[ 2022.11.06.18.03.07.649.0 ]--
r 206         return e;
--[ 2022.11.06.18.03.07.838.0 ]--
r 206         return ;
--[ 2022.11.06.18.03.23.349.0 ]--
r 31         PFNode prevNode, ;
--[ 2022.11.06.18.03.23.575.0 ]--
r 31         PFNode prevNode,;
--[ 2022.11.06.18.03.23.824.0 ]--
r 31         PFNode prevNode;
--[ 2022.11.06.18.03.26.897.0 ]--
+ 19     
--[ 2022.11.06.18.03.27.698.0 ]--
r 19     P
--[ 2022.11.06.18.03.27.786.0 ]--
r 19     PF
--[ 2022.11.06.18.03.28.421.0 ]--
r 19     PFN
--[ 2022.11.06.18.03.28.481.0 ]--
r 19     PFNO
--[ 2022.11.06.18.03.28.627.0 ]--
r 19     PFNOd
--[ 2022.11.06.18.03.28.941.0 ]--
r 19     PFNode
--[ 2022.11.06.18.03.30.292.0 ]--
r 19     PFNode 
--[ 2022.11.06.18.03.30.411.0 ]--
r 19     PFNode e
--[ 2022.11.06.18.03.30.552.0 ]--
r 19     PFNode en
--[ 2022.11.06.18.03.30.617.0 ]--
r 19     PFNode end
--[ 2022.11.06.18.03.31.404.0 ]--
r 19     PFNode endN
--[ 2022.11.06.18.03.31.524.0 ]--
r 19     PFNode endNo
--[ 2022.11.06.18.03.31.633.0 ]--
r 19     PFNode endNod
--[ 2022.11.06.18.03.31.777.0 ]--
r 19     PFNode endNode
--[ 2022.11.06.18.03.32.231.0 ]--
r 19     PFNode endNode 
--[ 2022.11.06.18.03.32.376.0 ]--
r 19     PFNode endNode =
--[ 2022.11.06.18.03.32.468.0 ]--
r 19     PFNode endNode = 
--[ 2022.11.06.18.03.33.947.0 ]--
r 19     PFNode endNode =
--[ 2022.11.06.18.03.34.114.0 ]--
r 19     PFNode endNode 
--[ 2022.11.06.18.03.34.259.0 ]--
r 19     PFNode endNode
--[ 2022.11.06.18.03.34.497.0 ]--
r 19     PFNode endNode;
--[ 2022.11.06.18.04.04.533.0 ]--
r 207         return e;
--[ 2022.11.06.18.04.04.640.0 ]--
r 207         return en;
--[ 2022.11.06.18.04.04.756.0 ]--
r 207         return end;
--[ 2022.11.06.18.04.07.483.0 ]--
r 207         return endNode.cost;
--[ 2022.11.06.18.04.07.494.0 ]--
r 207         return endNode;;
--[ 2022.11.06.18.04.07.502.0 ]--
r 207         return endNode.cost;
--[ 2022.11.06.18.04.17.387.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.04.35.005.0 ]--
+ 207         
--[ 2022.11.06.18.04.36.099.0 ]--
r 207         e
--[ 2022.11.06.18.04.36.212.0 ]--
r 207         en
--[ 2022.11.06.18.04.36.280.0 ]--
r 207         end
--[ 2022.11.06.18.04.37.188.0 ]--
r 207         endN
--[ 2022.11.06.18.04.37.287.0 ]--
r 207         endNo
--[ 2022.11.06.18.04.37.359.0 ]--
r 207         endNod
--[ 2022.11.06.18.04.37.514.0 ]--
r 207         endNode
--[ 2022.11.06.18.04.38.180.0 ]--
r 207         endNode.
--[ 2022.11.06.18.04.38.821.0 ]--
r 207         endNode.g
--[ 2022.11.06.18.04.38.929.0 ]--
r 207         endNode.ge
--[ 2022.11.06.18.04.39.059.0 ]--
r 207         endNode.get
--[ 2022.11.06.18.04.39.654.0 ]--
r 207         endNode.getCost
--[ 2022.11.06.18.04.39.659.0 ]--
r 207         endNode.getCost()
--[ 2022.11.06.18.04.41.233.0 ]--
r 207         endNode.getCost(h)
--[ 2022.11.06.18.04.42.054.0 ]--
r 207         endNode.getCost(heuristic)
--[ 2022.11.06.18.04.43.257.0 ]--
r 207         endNode.getCost(heuristic);
--[ 2022.11.06.18.04.52.917.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.05.19.494.0 ]--
r 207         
--[ 2022.11.06.18.05.20.509.0 ]--
- 207
--[ 2022.11.06.18.06.08.938.0 ]--
+ 57             
--[ 2022.11.06.18.06.10.250.0 ]--
r 57             /
--[ 2022.11.06.18.06.11.022.0 ]--
r 57             /*
--[ 2022.11.06.18.06.12.772.0 ]--
+ 61             
+ 62              */
--[ 2022.11.06.18.06.13.452.0 ]--
r 61             *
--[ 2022.11.06.18.06.13.938.0 ]--
r 61             */
--[ 2022.11.06.18.06.16.924.0 ]--
r 62              *
--[ 2022.11.06.18.06.17.075.0 ]--
r 62              
--[ 2022.11.06.18.06.17.579.0 ]--
r 62             
--[ 2022.11.06.18.06.18.948.0 ]--
- 62
--[ 2022.11.06.18.06.21.222.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.06.36.929.0 ]--
r 61             *
--[ 2022.11.06.18.06.37.081.0 ]--
r 61             
--[ 2022.11.06.18.06.38.716.0 ]--
r 57             /
--[ 2022.11.06.18.06.38.877.0 ]--
r 57             
--[ 2022.11.06.18.06.40.095.0 ]--
r 61 
--[ 2022.11.06.18.06.49.587.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.06.58.525.0 ]--
r 209         return endNode.cos;
--[ 2022.11.06.18.06.58.644.0 ]--
r 209         return endNode.co;
--[ 2022.11.06.18.06.58.814.0 ]--
r 209         return endNode.c;
--[ 2022.11.06.18.06.58.971.0 ]--
r 209         return endNode.;
--[ 2022.11.06.18.06.59.127.0 ]--
r 209         return endNode;
--[ 2022.11.06.18.06.59.304.0 ]--
r 209         return endNod;
--[ 2022.11.06.18.06.59.466.0 ]--
r 209         return endNo;
--[ 2022.11.06.18.06.59.638.0 ]--
r 209         return endN;
--[ 2022.11.06.18.06.59.797.0 ]--
r 209         return end;
--[ 2022.11.06.18.07.00.152.0 ]--
r 209         return en;
--[ 2022.11.06.18.07.00.321.0 ]--
r 209         return e;
--[ 2022.11.06.18.07.00.760.0 ]--
r 209         return ;
--[ 2022.11.06.18.07.01.195.0 ]--
r 209         return n;
--[ 2022.11.06.18.07.01.395.0 ]--
r 209         return nu;
--[ 2022.11.06.18.07.01.538.0 ]--
r 209         return nul;
--[ 2022.11.06.18.07.01.674.0 ]--
r 209         return null;
--[ 2022.11.06.18.07.02.452.0 ]--
r 57 
--[ 2022.11.06.18.07.03.064.0 ]--
r 209         return nul;
--[ 2022.11.06.18.07.03.194.0 ]--
r 209         return nu;
--[ 2022.11.06.18.07.03.371.0 ]--
r 209         return n;
--[ 2022.11.06.18.07.03.538.0 ]--
r 209         return ;
--[ 2022.11.06.18.07.04.128.0 ]--
r 209         return 0;
--[ 2022.11.06.18.07.06.890.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.08.15.899.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.06.18.08.17.292.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.06.18.08.17.913.0 ]--
r 46     private final static String emapFilename = emaps[4];        // change index to load a different elevation map
--[ 2022.11.06.18.08.20.341.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.08.43.335.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.06.18.08.44.021.0 ]--
r 46     private final static String emapFilename = emaps[5];        // change index to load a different elevation map
--[ 2022.11.06.18.08.46.753.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.16.29.861.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.16.54.242.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.06.18.16.55.813.0 ]--
r 46     private final static String emapFilename = emaps[3];        // change index to load a different elevation map
--[ 2022.11.06.18.16.58.548.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.18.55.399.0 ]--
:/src/Walker.java
r 8     
--[ 2022.11.06.18.18.58.356.0 ]--
r 8     p
--[ 2022.11.06.18.18.58.481.0 ]--
r 8     pr
--[ 2022.11.06.18.18.58.654.0 ]--
r 8     pri
--[ 2022.11.06.18.18.58.764.0 ]--
r 8     priv
--[ 2022.11.06.18.18.58.910.0 ]--
r 8     priva
--[ 2022.11.06.18.18.59.102.0 ]--
r 8     privat
--[ 2022.11.06.18.18.59.207.0 ]--
r 8     private
--[ 2022.11.06.18.18.59.295.0 ]--
r 8     private 
--[ 2022.11.06.18.18.59.635.0 ]--
r 8     private C
--[ 2022.11.06.18.18.59.785.0 ]--
r 8     private Co
--[ 2022.11.06.18.18.59.858.0 ]--
r 8     private Coo
--[ 2022.11.06.18.18.59.985.0 ]--
r 8     private Coor
--[ 2022.11.06.18.19.00.129.0 ]--
r 8     private Coord
--[ 2022.11.06.18.19.01.217.0 ]--
r 8     private Coord 
--[ 2022.11.06.18.19.01.409.0 ]--
r 8     private Coord l
--[ 2022.11.06.18.19.01.588.0 ]--
r 8     private Coord lo
--[ 2022.11.06.18.19.01.644.0 ]--
r 8     private Coord loc
--[ 2022.11.06.18.19.01.710.0 ]--
r 8     private Coord loca
--[ 2022.11.06.18.19.01.838.0 ]--
r 8     private Coord locat
--[ 2022.11.06.18.19.01.907.0 ]--
r 8     private Coord locati
--[ 2022.11.06.18.19.01.976.0 ]--
r 8     private Coord locatio
--[ 2022.11.06.18.19.02.097.0 ]--
r 8     private Coord location
--[ 2022.11.06.18.19.02.341.0 ]--
r 8     private Coord location;
--[ 2022.11.06.18.19.02.603.0 ]--
+ 9     
--[ 2022.11.06.18.19.03.337.0 ]--
r 9     p
--[ 2022.11.06.18.19.03.494.0 ]--
r 9     pr
--[ 2022.11.06.18.19.03.575.0 ]--
r 9     pri
--[ 2022.11.06.18.19.03.718.0 ]--
r 9     priv
--[ 2022.11.06.18.19.03.825.0 ]--
r 9     priva
--[ 2022.11.06.18.19.03.991.0 ]--
r 9     privat
--[ 2022.11.06.18.19.04.059.0 ]--
r 9     private
--[ 2022.11.06.18.19.04.189.0 ]--
r 9     private 
--[ 2022.11.06.18.19.04.420.0 ]--
r 9     private T
--[ 2022.11.06.18.19.04.592.0 ]--
r 9     private Te
--[ 2022.11.06.18.19.04.697.0 ]--
r 9     private Ter
--[ 2022.11.06.18.19.04.869.0 ]--
r 9     private Terr
--[ 2022.11.06.18.19.04.948.0 ]--
r 9     private Terra
--[ 2022.11.06.18.19.05.090.0 ]--
r 9     private Terrai
--[ 2022.11.06.18.19.05.175.0 ]--
r 9     private Terrain
--[ 2022.11.06.18.19.05.521.0 ]--
r 9     private Terrain 
--[ 2022.11.06.18.19.05.991.0 ]--
r 9     private Terrain t
--[ 2022.11.06.18.19.06.122.0 ]--
r 9     private Terrain te
--[ 2022.11.06.18.19.06.221.0 ]--
r 9     private Terrain ter
--[ 2022.11.06.18.19.06.407.0 ]--
r 9     private Terrain terr
--[ 2022.11.06.18.19.06.502.0 ]--
r 9     private Terrain terra
--[ 2022.11.06.18.19.06.604.0 ]--
r 9     private Terrain terrai
--[ 2022.11.06.18.19.06.665.0 ]--
r 9     private Terrain terrain
--[ 2022.11.06.18.19.07.026.0 ]--
r 9     private Terrain terrain;
--[ 2022.11.06.18.19.07.262.0 ]--
+ 10     
--[ 2022.11.06.18.19.08.694.0 ]--
r 10     p
--[ 2022.11.06.18.19.08.951.0 ]--
r 10     pr
--[ 2022.11.06.18.19.09.002.0 ]--
r 10     pri
--[ 2022.11.06.18.19.09.178.0 ]--
r 10     priv
--[ 2022.11.06.18.19.09.292.0 ]--
r 10     priva
--[ 2022.11.06.18.19.09.439.0 ]--
r 10     privat
--[ 2022.11.06.18.19.09.530.0 ]--
r 10     private
--[ 2022.11.06.18.19.09.655.0 ]--
r 10     private 
--[ 2022.11.06.18.19.09.995.0 ]--
r 10     private I
--[ 2022.11.06.18.19.10.041.0 ]--
r 10     private It
--[ 2022.11.06.18.19.10.194.0 ]--
r 10     private Ite
--[ 2022.11.06.18.19.10.277.0 ]--
r 10     private Iter
--[ 2022.11.06.18.19.10.405.0 ]--
r 10     private Itera
--[ 2022.11.06.18.19.10.521.0 ]--
r 10     private Iterat
--[ 2022.11.06.18.19.10.920.0 ]--
r 10     private Iterator
--[ 2022.11.06.18.19.12.222.0 ]--
r 10     private Iterator<>
--[ 2022.11.06.18.19.12.600.0 ]--
r 10     private Iterator<C>
--[ 2022.11.06.18.19.12.773.0 ]--
r 10     private Iterator<Co>
--[ 2022.11.06.18.19.12.887.0 ]--
r 10     private Iterator<Coo>
--[ 2022.11.06.18.19.12.974.0 ]--
r 10     private Iterator<Coor>
--[ 2022.11.06.18.19.13.111.0 ]--
r 10     private Iterator<Coord>
--[ 2022.11.06.18.19.15.217.0 ]--
r 10     private Iterator<Coord> 
--[ 2022.11.06.18.19.15.483.0 ]--
r 10     private Iterator<Coord> p
--[ 2022.11.06.18.19.15.559.0 ]--
r 10     private Iterator<Coord> pa
--[ 2022.11.06.18.19.15.658.0 ]--
r 10     private Iterator<Coord> pat
--[ 2022.11.06.18.19.15.746.0 ]--
r 10     private Iterator<Coord> path
--[ 2022.11.06.18.19.15.972.0 ]--
r 10     private Iterator<Coord> path;
--[ 2022.11.06.18.19.16.260.0 ]--
+ 11     
--[ 2022.11.06.18.19.17.687.0 ]--
r 11     p
--[ 2022.11.06.18.19.17.828.0 ]--
r 11     pr
--[ 2022.11.06.18.19.17.865.0 ]--
r 11     pri
--[ 2022.11.06.18.19.18.134.0 ]--
r 11     pria
--[ 2022.11.06.18.19.18.572.0 ]--
r 11     pri
--[ 2022.11.06.18.19.18.642.0 ]--
r 11     priv
--[ 2022.11.06.18.19.18.775.0 ]--
r 11     priva
--[ 2022.11.06.18.19.18.916.0 ]--
r 11     privat
--[ 2022.11.06.18.19.19.057.0 ]--
r 11     private
--[ 2022.11.06.18.19.19.121.0 ]--
r 11     private 
--[ 2022.11.06.18.19.19.430.0 ]--
r 11     private b
--[ 2022.11.06.18.19.19.543.0 ]--
r 11     private bo
--[ 2022.11.06.18.19.19.696.0 ]--
r 11     private boo
--[ 2022.11.06.18.19.19.918.0 ]--
r 11     private bool
--[ 2022.11.06.18.19.20.123.0 ]--
r 11     private boolean
--[ 2022.11.06.18.19.20.713.0 ]--
r 11     private boolean 
--[ 2022.11.06.18.19.23.777.0 ]--
r 11     private boolean d
--[ 2022.11.06.18.19.23.810.0 ]--
r 11     private boolean do
--[ 2022.11.06.18.19.23.919.0 ]--
r 11     private boolean don
--[ 2022.11.06.18.19.24.064.0 ]--
r 11     private boolean done
--[ 2022.11.06.18.19.24.493.0 ]--
r 11     private boolean doneW
--[ 2022.11.06.18.19.24.761.0 ]--
r 11     private boolean doneWa
--[ 2022.11.06.18.19.24.890.0 ]--
r 11     private boolean doneWal
--[ 2022.11.06.18.19.24.981.0 ]--
r 11     private boolean doneWalk
--[ 2022.11.06.18.19.25.247.0 ]--
r 11     private boolean doneWalki
--[ 2022.11.06.18.19.25.378.0 ]--
r 11     private boolean doneWalkin
--[ 2022.11.06.18.19.25.441.0 ]--
r 11     private boolean doneWalking
--[ 2022.11.06.18.19.26.259.0 ]--
r 11     private boolean doneWalking 
--[ 2022.11.06.18.19.26.412.0 ]--
r 11     private boolean doneWalking =
--[ 2022.11.06.18.19.26.518.0 ]--
r 11     private boolean doneWalking = 
--[ 2022.11.06.18.19.26.644.0 ]--
r 11     private boolean doneWalking = f
--[ 2022.11.06.18.19.26.733.0 ]--
r 11     private boolean doneWalking = fa
--[ 2022.11.06.18.19.26.841.0 ]--
r 11     private boolean doneWalking = fal
--[ 2022.11.06.18.19.26.946.0 ]--
r 11     private boolean doneWalking = fals
--[ 2022.11.06.18.19.27.038.0 ]--
r 11     private boolean doneWalking = false
--[ 2022.11.06.18.19.27.195.0 ]--
r 11     private boolean doneWalking = false;
--[ 2022.11.06.18.21.20.714.0 ]--
r 19         return t;
--[ 2022.11.06.18.21.20.826.0 ]--
r 19         return th;
--[ 2022.11.06.18.21.20.877.0 ]--
r 19         return thi;
--[ 2022.11.06.18.21.21.003.0 ]--
r 19         return this;
--[ 2022.11.06.18.21.21.124.0 ]--
r 19         return this.;
--[ 2022.11.06.18.21.21.377.0 ]--
r 19         return this.l;
--[ 2022.11.06.18.21.21.573.0 ]--
r 19         return this.lo;
--[ 2022.11.06.18.21.21.873.0 ]--
r 19         return this.location;
--[ 2022.11.06.18.21.27.646.0 ]--
r 24         return !;
--[ 2022.11.06.18.21.28.274.0 ]--
r 24         return !t;
--[ 2022.11.06.18.21.28.387.0 ]--
r 24         return !th;
--[ 2022.11.06.18.21.28.432.0 ]--
r 24         return !thi;
--[ 2022.11.06.18.21.28.586.0 ]--
r 24         return !this;
--[ 2022.11.06.18.21.29.500.0 ]--
r 24         return !this.;
--[ 2022.11.06.18.21.29.734.0 ]--
r 24         return !this.p;
--[ 2022.11.06.18.21.29.828.0 ]--
r 24         return !this.pa;
--[ 2022.11.06.18.21.29.950.0 ]--
r 24         return !this.pat;
--[ 2022.11.06.18.21.30.027.0 ]--
r 24         return !this.path;
--[ 2022.11.06.18.21.30.305.0 ]--
r 24         return !this.path.;
--[ 2022.11.06.18.21.30.780.0 ]--
r 24         return !this.path.jh;
--[ 2022.11.06.18.21.30.794.0 ]--
r 24         return !this.path.jha;
--[ 2022.11.06.18.21.31.178.0 ]--
r 24         return !this.path.jh;
--[ 2022.11.06.18.21.31.349.0 ]--
r 24         return !this.path.j;
--[ 2022.11.06.18.21.31.484.0 ]--
r 24         return !this.path.;
--[ 2022.11.06.18.21.31.593.0 ]--
r 24         return !this.path.h;
--[ 2022.11.06.18.21.31.695.0 ]--
r 24         return !this.path.ha;
--[ 2022.11.06.18.21.31.750.0 ]--
r 24         return !this.path.has;
--[ 2022.11.06.18.21.32.948.0 ]--
r 24         return !this.path.hasNext;
--[ 2022.11.06.18.21.32.952.0 ]--
r 24         return !this.path.hasNext();
--[ 2022.11.06.18.21.56.461.0 ]--
+ 30         
--[ 2022.11.06.18.22.09.362.0 ]--
r 30         w
--[ 2022.11.06.18.22.09.444.0 ]--
r 30         wh
--[ 2022.11.06.18.22.09.529.0 ]--
r 30         whi
--[ 2022.11.06.18.22.09.622.0 ]--
r 30         whil
--[ 2022.11.06.18.22.09.706.0 ]--
r 30         while
--[ 2022.11.06.18.22.11.050.0 ]--
r 30         while 
--[ 2022.11.06.18.22.11.252.0 ]--
r 30         while ()
--[ 2022.11.06.18.22.11.679.0 ]--
r 30         while (b)
--[ 2022.11.06.18.22.11.849.0 ]--
r 30         while (by)
--[ 2022.11.06.18.22.12.117.0 ]--
r 30         while (byT)
--[ 2022.11.06.18.22.12.311.0 ]--
r 30         while (byTi)
--[ 2022.11.06.18.22.12.377.0 ]--
r 30         while (byTim)
--[ 2022.11.06.18.22.12.494.0 ]--
r 30         while (byTime)
--[ 2022.11.06.18.22.13.796.0 ]--
r 30         while (byTime )
--[ 2022.11.06.18.22.14.061.0 ]--
r 30         while (byTime <)
--[ 2022.11.06.18.22.14.647.0 ]--
r 30         while (byTime )
--[ 2022.11.06.18.22.14.972.0 ]--
r 30         while (byTime >)
--[ 2022.11.06.18.22.15.846.0 ]--
r 30         while (byTime >=)
--[ 2022.11.06.18.22.16.765.0 ]--
r 30         while (byTime >= )
--[ 2022.11.06.18.22.17.783.0 ]--
r 30         while (byTime >= 0)
--[ 2022.11.06.18.22.18.119.0 ]--
r 30         while (byTime >= 0.)
--[ 2022.11.06.18.22.18.354.0 ]--
r 30         while (byTime >= 0.0)
--[ 2022.11.06.18.22.22.069.0 ]--
r 30         while (byTime >= 0.0f)
--[ 2022.11.06.18.22.27.023.0 ]--
r 30         while (byTime >= 0.0f )
--[ 2022.11.06.18.22.27.882.0 ]--
r 30         while (byTime >= 0.0f &)
--[ 2022.11.06.18.22.28.012.0 ]--
r 30         while (byTime >= 0.0f &&)
--[ 2022.11.06.18.22.28.996.0 ]--
r 30         while (byTime >= 0.0f && )
--[ 2022.11.06.18.22.29.224.0 ]--
r 30         while (byTime >= 0.0f && t)
--[ 2022.11.06.18.22.29.327.0 ]--
r 30         while (byTime >= 0.0f && th)
--[ 2022.11.06.18.22.29.403.0 ]--
r 30         while (byTime >= 0.0f && thi)
--[ 2022.11.06.18.22.29.500.0 ]--
r 30         while (byTime >= 0.0f && this)
--[ 2022.11.06.18.22.29.659.0 ]--
r 30         while (byTime >= 0.0f && this.)
--[ 2022.11.06.18.22.29.920.0 ]--
r 30         while (byTime >= 0.0f && this.p)
--[ 2022.11.06.18.22.29.984.0 ]--
r 30         while (byTime >= 0.0f && this.pa)
--[ 2022.11.06.18.22.30.103.0 ]--
r 30         while (byTime >= 0.0f && this.pat)
--[ 2022.11.06.18.22.30.184.0 ]--
r 30         while (byTime >= 0.0f && this.path)
--[ 2022.11.06.18.22.30.943.0 ]--
r 30         while (byTime >= 0.0f && this.path.)
--[ 2022.11.06.18.22.31.272.0 ]--
r 30         while (byTime >= 0.0f && this.path.h)
--[ 2022.11.06.18.22.31.354.0 ]--
r 30         while (byTime >= 0.0f && this.path.ha)
--[ 2022.11.06.18.22.31.426.0 ]--
r 30         while (byTime >= 0.0f && this.path.has)
--[ 2022.11.06.18.22.32.323.0 ]--
r 30         while (byTime >= 0.0f && this.path.hasNext)
--[ 2022.11.06.18.22.32.327.0 ]--
r 30         while (byTime >= 0.0f && this.path.hasNext())
--[ 2022.11.06.18.22.36.626.0 ]--
r 30         while (byTime >= 0.0f && this.path.hasNext()) 
--[ 2022.11.06.18.22.36.862.0 ]--
r 30         while (byTime >= 0.0f && this.path.hasNext()) {
--[ 2022.11.06.18.22.37.065.0 ]--
+ 31 
+ 32 }
--[ 2022.11.06.18.22.37.069.0 ]--
r 32         }
--[ 2022.11.06.18.22.37.085.0 ]--
r 31             
--[ 2022.11.06.18.22.39.605.0 ]--
r 31             C
--[ 2022.11.06.18.22.39.780.0 ]--
r 31             Co
--[ 2022.11.06.18.22.39.900.0 ]--
r 31             Coo
--[ 2022.11.06.18.22.40.002.0 ]--
r 31             Coor
--[ 2022.11.06.18.22.40.116.0 ]--
r 31             Coord
--[ 2022.11.06.18.22.40.270.0 ]--
r 31             Coord 
--[ 2022.11.06.18.22.40.435.0 ]--
r 31             Coord n
--[ 2022.11.06.18.22.40.513.0 ]--
r 31             Coord ne
--[ 2022.11.06.18.22.40.704.0 ]--
r 31             Coord nex
--[ 2022.11.06.18.22.40.823.0 ]--
r 31             Coord next
--[ 2022.11.06.18.22.40.963.0 ]--
r 31             Coord next 
--[ 2022.11.06.18.22.41.026.0 ]--
r 31             Coord next =
--[ 2022.11.06.18.22.41.151.0 ]--
r 31             Coord next = 
--[ 2022.11.06.18.22.42.684.0 ]--
r 31             Coord next = t
--[ 2022.11.06.18.22.42.769.0 ]--
r 31             Coord next = th
--[ 2022.11.06.18.22.42.844.0 ]--
r 31             Coord next = thi
--[ 2022.11.06.18.22.42.929.0 ]--
r 31             Coord next = this
--[ 2022.11.06.18.22.43.143.0 ]--
r 31             Coord next = this.
--[ 2022.11.06.18.22.44.233.0 ]--
r 31             Coord next = this.p
--[ 2022.11.06.18.22.44.323.0 ]--
r 31             Coord next = this.pa
--[ 2022.11.06.18.22.44.425.0 ]--
r 31             Coord next = this.pat
--[ 2022.11.06.18.22.44.495.0 ]--
r 31             Coord next = this.path
--[ 2022.11.06.18.22.45.108.0 ]--
r 31             Coord next = this.path.
--[ 2022.11.06.18.22.45.405.0 ]--
r 31             Coord next = this.path.n
--[ 2022.11.06.18.22.45.487.0 ]--
r 31             Coord next = this.path.ne
--[ 2022.11.06.18.22.45.971.0 ]--
r 31             Coord next = this.path.next
--[ 2022.11.06.18.22.45.975.0 ]--
r 31             Coord next = this.path.next()
--[ 2022.11.06.18.22.46.827.0 ]--
r 31             Coord next = this.path.next();
--[ 2022.11.06.18.22.47.080.0 ]--
+ 32             
--[ 2022.11.06.18.22.48.508.0 ]--
r 32             b
--[ 2022.11.06.18.22.48.647.0 ]--
r 32             by
--[ 2022.11.06.18.22.48.902.0 ]--
r 32             byT
--[ 2022.11.06.18.22.49.064.0 ]--
r 32             byTi
--[ 2022.11.06.18.22.49.201.0 ]--
r 32             byTim
--[ 2022.11.06.18.22.49.285.0 ]--
r 32             byTime
--[ 2022.11.06.18.22.49.541.0 ]--
r 32             byTime 
--[ 2022.11.06.18.22.50.084.0 ]--
r 32             byTime -
--[ 2022.11.06.18.22.50.801.0 ]--
r 32             byTime -=
--[ 2022.11.06.18.22.51.426.0 ]--
r 32             byTime -= 
--[ 2022.11.06.18.22.51.592.0 ]--
r 32             byTime -= t
--[ 2022.11.06.18.22.51.670.0 ]--
r 32             byTime -= th
--[ 2022.11.06.18.22.51.783.0 ]--
r 32             byTime -= thi
--[ 2022.11.06.18.22.51.861.0 ]--
r 32             byTime -= this
--[ 2022.11.06.18.22.52.013.0 ]--
r 32             byTime -= this.
--[ 2022.11.06.18.22.52.245.0 ]--
r 32             byTime -= this.t
--[ 2022.11.06.18.22.52.489.0 ]--
r 32             byTime -= this.te
--[ 2022.11.06.18.22.52.578.0 ]--
r 32             byTime -= this.ter
--[ 2022.11.06.18.22.53.154.0 ]--
r 32             byTime -= this.terrain
--[ 2022.11.06.18.22.53.670.0 ]--
r 32             byTime -= this.terrain.
--[ 2022.11.06.18.22.54.892.0 ]--
r 32             byTime -= this.terrain.c
--[ 2022.11.06.18.22.54.940.0 ]--
r 32             byTime -= this.terrain.co
--[ 2022.11.06.18.22.55.076.0 ]--
r 32             byTime -= this.terrain.com
--[ 2022.11.06.18.23.11.922.0 ]--
r 32             byTime -= this.terrain.computeTravelCost
--[ 2022.11.06.18.23.11.927.0 ]--
r 32             byTime -= this.terrain.computeTravelCost()
--[ 2022.11.06.18.23.14.635.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(t)
--[ 2022.11.06.18.23.14.721.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(th)
--[ 2022.11.06.18.23.14.797.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(thi)
--[ 2022.11.06.18.23.14.951.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this)
--[ 2022.11.06.18.23.15.110.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.)
--[ 2022.11.06.18.23.15.351.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.l)
--[ 2022.11.06.18.23.15.546.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.lo)
--[ 2022.11.06.18.23.15.689.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.loc)
--[ 2022.11.06.18.23.15.947.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.location)
--[ 2022.11.06.18.23.16.678.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.location,)
--[ 2022.11.06.18.23.16.870.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.location, )
--[ 2022.11.06.18.23.16.984.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.location, n)
--[ 2022.11.06.18.23.17.050.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.location, ne)
--[ 2022.11.06.18.23.17.251.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.location, nex)
--[ 2022.11.06.18.23.17.339.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.location, next)
--[ 2022.11.06.18.23.18.994.0 ]--
r 32             byTime -= this.terrain.computeTravelCost(this.location, next);
--[ 2022.11.06.18.23.20.998.0 ]--
+ 33             
--[ 2022.11.06.18.23.22.514.0 ]--
r 33             t
--[ 2022.11.06.18.23.22.619.0 ]--
r 33             th
--[ 2022.11.06.18.23.22.661.0 ]--
r 33             thi
--[ 2022.11.06.18.23.22.747.0 ]--
r 33             this
--[ 2022.11.06.18.23.22.899.0 ]--
r 33             this.
--[ 2022.11.06.18.23.23.154.0 ]--
r 33             this.l
--[ 2022.11.06.18.23.23.372.0 ]--
r 33             this.lo
--[ 2022.11.06.18.23.23.465.0 ]--
r 33             this.loc
--[ 2022.11.06.18.23.23.674.0 ]--
r 33             this.location
--[ 2022.11.06.18.23.24.248.0 ]--
r 33             this.location 
--[ 2022.11.06.18.23.24.299.0 ]--
r 33             this.location =
--[ 2022.11.06.18.23.24.397.0 ]--
r 33             this.location = 
--[ 2022.11.06.18.23.24.562.0 ]--
r 33             this.location = n
--[ 2022.11.06.18.23.24.654.0 ]--
r 33             this.location = ne
--[ 2022.11.06.18.23.24.859.0 ]--
r 33             this.location = nex
--[ 2022.11.06.18.23.24.953.0 ]--
r 33             this.location = next
--[ 2022.11.06.18.23.25.163.0 ]--
r 33             this.location = next;
--[ 2022.11.06.18.23.25.482.0 ]--
+ 34             
--[ 2022.11.06.18.23.25.843.0 ]--
r 34             d
--[ 2022.11.06.18.23.25.913.0 ]--
r 34             do
--[ 2022.11.06.18.23.26.005.0 ]--
r 34             don
--[ 2022.11.06.18.23.26.123.0 ]--
r 34             dont
--[ 2022.11.06.18.23.26.943.0 ]--
r 34             don
--[ 2022.11.06.18.23.27.028.0 ]--
r 34             done
--[ 2022.11.06.18.23.27.435.0 ]--
r 34             doneW
--[ 2022.11.06.18.23.28.272.0 ]--
r 34             doneWalking
--[ 2022.11.06.18.23.29.796.0 ]--
r 34             doneWalking 
--[ 2022.11.06.18.23.29.959.0 ]--
r 34             doneWalking =
--[ 2022.11.06.18.23.30.055.0 ]--
r 34             doneWalking = 
--[ 2022.11.06.18.23.31.823.0 ]--
r 34             doneWalking = !
--[ 2022.11.06.18.23.32.273.0 ]--
r 34             doneWalking = !t
--[ 2022.11.06.18.23.32.404.0 ]--
r 34             doneWalking = !th
--[ 2022.11.06.18.23.32.458.0 ]--
r 34             doneWalking = !thi
--[ 2022.11.06.18.23.32.529.0 ]--
r 34             doneWalking = !this
--[ 2022.11.06.18.23.33.462.0 ]--
r 34             doneWalking = !this.
--[ 2022.11.06.18.23.33.757.0 ]--
r 34             doneWalking = !this.p
--[ 2022.11.06.18.23.33.861.0 ]--
r 34             doneWalking = !this.pa
--[ 2022.11.06.18.23.33.939.0 ]--
r 34             doneWalking = !this.pat
--[ 2022.11.06.18.23.34.010.0 ]--
r 34             doneWalking = !this.path
--[ 2022.11.06.18.23.34.274.0 ]--
r 34             doneWalking = !this.path.
--[ 2022.11.06.18.23.34.556.0 ]--
r 34             doneWalking = !this.path.h
--[ 2022.11.06.18.23.34.636.0 ]--
r 34             doneWalking = !this.path.ha
--[ 2022.11.06.18.23.34.696.0 ]--
r 34             doneWalking = !this.path.has
--[ 2022.11.06.18.23.35.610.0 ]--
r 34             doneWalking = !this.path.hasNext
--[ 2022.11.06.18.23.35.615.0 ]--
r 34             doneWalking = !this.path.hasNext()
--[ 2022.11.06.18.23.35.973.0 ]--
r 34             doneWalking = !this.path.hasNext();
--[ 2022.11.06.18.24.13.153.0 ]--
+ 15         
--[ 2022.11.06.18.24.16.328.0 ]--
r 15         t
--[ 2022.11.06.18.24.16.461.0 ]--
r 15         te
--[ 2022.11.06.18.24.16.573.0 ]--
r 15         ter
--[ 2022.11.06.18.24.16.716.0 ]--
r 15         terr
--[ 2022.11.06.18.24.16.839.0 ]--
r 15         terra
--[ 2022.11.06.18.24.17.638.0 ]--
r 15         terrain
--[ 2022.11.06.18.24.17.835.0 ]--
r 15         terrain 
--[ 2022.11.06.18.24.17.945.0 ]--
r 15         terrain =
--[ 2022.11.06.18.24.18.038.0 ]--
r 15         terrain = 
--[ 2022.11.06.18.24.20.829.0 ]--
r 15         terrain = t
--[ 2022.11.06.18.24.20.991.0 ]--
r 15         terrain = te
--[ 2022.11.06.18.24.21.111.0 ]--
r 15         terrain = ter
--[ 2022.11.06.18.24.21.762.0 ]--
r 15         terrain = terrain
--[ 2022.11.06.18.24.22.891.0 ]--
r 15         terrain = terrain;
--[ 2022.11.06.18.24.26.051.0 ]--
r 15         tterrain = terrain;
--[ 2022.11.06.18.24.26.143.0 ]--
r 15         thterrain = terrain;
--[ 2022.11.06.18.24.26.235.0 ]--
r 15         thiterrain = terrain;
--[ 2022.11.06.18.24.26.309.0 ]--
r 15         thisterrain = terrain;
--[ 2022.11.06.18.24.26.463.0 ]--
r 15         this.terrain = terrain;
--[ 2022.11.06.18.24.29.270.0 ]--
+ 16         
--[ 2022.11.06.18.24.30.039.0 ]--
r 16         t
--[ 2022.11.06.18.24.30.099.0 ]--
r 16         th
--[ 2022.11.06.18.24.30.176.0 ]--
r 16         thi
--[ 2022.11.06.18.24.30.257.0 ]--
r 16         this
--[ 2022.11.06.18.24.30.429.0 ]--
r 16         this.
--[ 2022.11.06.18.24.31.082.0 ]--
r 16         this.p
--[ 2022.11.06.18.24.31.151.0 ]--
r 16         this.pa
--[ 2022.11.06.18.24.31.293.0 ]--
r 16         this.pat
--[ 2022.11.06.18.24.31.343.0 ]--
r 16         this.path
--[ 2022.11.06.18.24.31.608.0 ]--
r 16         this.path 
--[ 2022.11.06.18.24.31.766.0 ]--
r 16         this.path =
--[ 2022.11.06.18.24.31.844.0 ]--
r 16         this.path = 
--[ 2022.11.06.18.24.32.483.0 ]--
r 16         this.path = p
--[ 2022.11.06.18.24.32.579.0 ]--
r 16         this.path = pa
--[ 2022.11.06.18.24.32.666.0 ]--
r 16         this.path = pat
--[ 2022.11.06.18.24.32.755.0 ]--
r 16         this.path = path
--[ 2022.11.06.18.24.32.971.0 ]--
r 16         this.path = path;
--[ 2022.11.06.18.24.33.214.0 ]--
+ 17         
--[ 2022.11.06.18.24.35.122.0 ]--
- 17
--[ 2022.11.06.18.24.35.373.0 ]--
r 16         this.path = path
--[ 2022.11.06.18.24.36.490.0 ]--
r 16         this.path = path.
--[ 2022.11.06.18.24.40.577.0 ]--
r 16         this.path = path.iterator
--[ 2022.11.06.18.24.40.581.0 ]--
r 16         this.path = path.iterator()
--[ 2022.11.06.18.24.41.028.0 ]--
r 16         this.path = path.iterator();
--[ 2022.11.06.18.24.41.320.0 ]--
+ 17         
--[ 2022.11.06.18.24.42.030.0 ]--
r 17         t
--[ 2022.11.06.18.24.42.112.0 ]--
r 17         th
--[ 2022.11.06.18.24.42.197.0 ]--
r 17         thi
--[ 2022.11.06.18.24.42.293.0 ]--
r 17         this
--[ 2022.11.06.18.24.42.496.0 ]--
r 17         this.
--[ 2022.11.06.18.24.43.371.0 ]--
r 17         this.l
--[ 2022.11.06.18.24.43.578.0 ]--
r 17         this.lo
--[ 2022.11.06.18.24.43.700.0 ]--
r 17         this.loc
--[ 2022.11.06.18.24.43.860.0 ]--
r 17         this.location
--[ 2022.11.06.18.24.44.516.0 ]--
r 17         this.location 
--[ 2022.11.06.18.24.44.600.0 ]--
r 17         this.location =
--[ 2022.11.06.18.24.44.712.0 ]--
r 17         this.location = 
--[ 2022.11.06.18.24.45.511.0 ]--
r 17         this.location = t
--[ 2022.11.06.18.24.45.605.0 ]--
r 17         this.location = th
--[ 2022.11.06.18.24.45.695.0 ]--
r 17         this.location = thi
--[ 2022.11.06.18.24.45.780.0 ]--
r 17         this.location = this
--[ 2022.11.06.18.24.46.015.0 ]--
r 17         this.location = this.
--[ 2022.11.06.18.24.46.672.0 ]--
r 17         this.location = this.p
--[ 2022.11.06.18.24.46.749.0 ]--
r 17         this.location = this.pa
--[ 2022.11.06.18.24.46.890.0 ]--
r 17         this.location = this.pat
--[ 2022.11.06.18.24.46.917.0 ]--
r 17         this.location = this.path
--[ 2022.11.06.18.24.47.249.0 ]--
r 17         this.location = this.path.
--[ 2022.11.06.18.24.47.748.0 ]--
r 17         this.location = this.path.n
--[ 2022.11.06.18.24.47.978.0 ]--
r 17         this.location = this.path.next
--[ 2022.11.06.18.24.47.982.0 ]--
r 17         this.location = this.path.next()
--[ 2022.11.06.18.24.48.393.0 ]--
r 17         this.location = this.path.next();
--[ 2022.11.06.18.25.40.455.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.25.55.819.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.28.13.135.0 ]--
r 27         return d;
--[ 2022.11.06.18.28.13.200.0 ]--
r 27         return do;
--[ 2022.11.06.18.28.13.308.0 ]--
r 27         return don;
--[ 2022.11.06.18.28.13.391.0 ]--
r 27         return done;
--[ 2022.11.06.18.28.14.245.0 ]--
r 27         return doneWalking;
--[ 2022.11.06.18.28.17.405.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.06.18.30.36.108.0 ]--
r 17         this.location = this.path.next(;
--[ 2022.11.06.18.30.36.294.0 ]--
r 17         this.location = this.path.next;
--[ 2022.11.06.18.30.36.499.0 ]--
r 17         this.location = this.path.nex;
--[ 2022.11.06.18.30.36.690.0 ]--
r 17         this.location = this.path.ne;
--[ 2022.11.06.18.30.36.941.0 ]--
r 17         this.location = this.path.n;
--[ 2022.11.06.18.30.37.178.0 ]--
r 17         this.location = this.path.;
--[ 2022.11.06.18.30.38.142.0 ]--
r 17         this.location = this.path.i;
--[ 2022.11.06.18.30.38.214.0 ]--
r 17         this.location = this.path.it;
--[ 2022.11.06.18.30.38.460.0 ]--
r 17         this.location = this.path.ite;
--[ 2022.11.06.18.30.39.054.0 ]--
r 17         this.location = this.path.it;
--[ 2022.11.06.18.30.39.180.0 ]--
r 17         this.location = this.path.i;
--[ 2022.11.06.18.30.39.411.0 ]--
r 17         this.location = this.path.;
--[ 2022.11.06.18.30.40.048.0 ]--
r 17         this.location = this.path;
--[ 2022.11.06.18.30.40.564.0 ]--
r 17         this.location = this.pat;
--[ 2022.11.06.18.30.40.726.0 ]--
r 17         this.location = this.path;
--[ 2022.11.06.18.31.18.852.0 ]--
r 17         this.location = this.path.;
--[ 2022.11.06.18.31.19.260.0 ]--
r 17         this.location = this.path.i;
--[ 2022.11.06.18.31.20.280.0 ]--
r 17         this.location = this.path.it;
--[ 2022.11.06.18.31.21.229.0 ]--
r 17         this.location = this.path.ite;
--[ 2022.11.06.18.31.21.345.0 ]--
r 17         this.location = this.path.item;
--[ 2022.11.06.18.31.21.961.0 ]--
r 17         this.location = this.path.ite;
--[ 2022.11.06.18.31.22.146.0 ]--
r 17         this.location = this.path.it;
--[ 2022.11.06.18.31.22.323.0 ]--
r 17         this.location = this.path.i;
--[ 2022.11.06.18.31.22.501.0 ]--
r 17         this.location = this.path.;
--[ 2022.11.06.18.31.23.275.0 ]--
r 17         this.location = this.path;
--[ 2022.11.06.18.31.24.770.0 ]--
r 17         this.location = this.path[];
--[ 2022.11.06.18.31.25.029.0 ]--
r 17         this.location = this.path[0];
--[ 2022.11.06.18.31.27.135.0 ]--
r 17         this.location = this.path[];
--[ 2022.11.06.18.31.27.347.0 ]--
r 17         this.location = this.path;
--[ 2022.11.06.18.31.29.365.0 ]--
r 17         this.location = this.path.;
--[ 2022.11.06.18.31.29.546.0 ]--
r 17         this.location = this.path.n;
--[ 2022.11.06.18.31.29.649.0 ]--
r 17         this.location = this.path.ne;
--[ 2022.11.06.18.31.29.853.0 ]--
r 17         this.location = this.path.next;
--[ 2022.11.06.18.31.29.857.0 ]--
r 17         this.location = this.path.next();
--[ 2022.11.06.18.31.38.982.0 ]--
r 17         this.location = this.path.next(;
--[ 2022.11.06.18.31.39.174.0 ]--
r 17         this.location = this.path.next;
--[ 2022.11.06.18.31.39.347.0 ]--
r 17         this.location = this.path.nex;
--[ 2022.11.06.18.31.39.553.0 ]--
r 17         this.location = this.path.ne;
--[ 2022.11.06.18.31.39.740.0 ]--
r 17         this.location = this.path.n;
--[ 2022.11.06.18.31.39.931.0 ]--
r 17         this.location = this.path.;
--[ 2022.11.06.18.31.40.150.0 ]--
r 17         this.location = this.path;
--[ 2022.11.06.18.32.32.312.0 ]--
r 17         this.location = this.path.;
--[ 2022.11.06.18.32.32.480.0 ]--
r 17         this.location = this.path.n;
--[ 2022.11.06.18.32.32.600.0 ]--
r 17         this.location = this.path.ne;
--[ 2022.11.06.18.32.32.739.0 ]--
r 17         this.location = this.path.next;
--[ 2022.11.06.18.32.32.742.0 ]--
r 17         this.location = this.path.next();
--[ 2022.11.07.08.01.22.268.0 ]--
:/src/Pathfinder.java
r 213         return Npq.size();
--[ 2022.11.07.08.01.22.269.0 ]--
UpdateTree (AD): 1 1
- /P04_Pathfinding.zip
+ /P04_Pathfinding_Nesius_Wickham.zip

--[ 2022.11.07.08.01.24.221.0 ]--
r 213         return N pq.size();
--[ 2022.11.07.08.01.24.418.0 ]--
r 213         return N *pq.size();
--[ 2022.11.07.08.01.24.599.0 ]--
r 213         return N * pq.size();
--[ 2022.11.07.08.01.25.065.0 ]--
r 213         return N * Npq.size();
--[ 2022.11.07.08.01.26.727.0 ]--
r 213         return N * N pq.size();
--[ 2022.11.07.08.01.26.836.0 ]--
r 213         return N * N /pq.size();
--[ 2022.11.07.08.01.27.562.0 ]--
r 213         return N * N / pq.size();
--[ 2022.11.07.08.01.28.785.0 ]--
r 213         return N * N) / pq.size();
--[ 2022.11.07.08.01.30.695.0 ]--
r 213         return (N * N) / pq.size();
--[ 2022.11.07.09.04.40.797.0 ]--
+ 134         
--[ 2022.11.07.09.04.41.323.0 ]--
r 134         f
--[ 2022.11.07.09.04.41.429.0 ]--
r 134         fo
--[ 2022.11.07.09.04.41.507.0 ]--
r 134         fou
--[ 2022.11.07.09.04.41.680.0 ]--
r 134         foun
--[ 2022.11.07.09.04.41.750.0 ]--
r 134         found
--[ 2022.11.07.09.04.41.876.0 ]--
r 134         found 
--[ 2022.11.07.09.04.41.912.0 ]--
r 134         found n
--[ 2022.11.07.09.04.41.992.0 ]--
r 134         found n=
--[ 2022.11.07.09.04.42.142.0 ]--
r 134         found n= 
--[ 2022.11.07.09.04.42.482.0 ]--
r 134         found n= f
--[ 2022.11.07.09.04.42.732.0 ]--
r 134         found n= 
--[ 2022.11.07.09.04.42.889.0 ]--
r 134         found n=
--[ 2022.11.07.09.04.43.047.0 ]--
r 134         found n
--[ 2022.11.07.09.04.43.206.0 ]--
r 134         found 
--[ 2022.11.07.09.04.43.396.0 ]--
r 134         found =
--[ 2022.11.07.09.04.43.580.0 ]--
r 134         found = 
--[ 2022.11.07.09.04.43.707.0 ]--
r 134         found = f
--[ 2022.11.07.09.04.43.814.0 ]--
r 134         found = fa
--[ 2022.11.07.09.04.43.908.0 ]--
r 134         found = fal
--[ 2022.11.07.09.04.43.986.0 ]--
r 134         found = fals
--[ 2022.11.07.09.04.44.113.0 ]--
r 134         found = false
--[ 2022.11.07.09.04.44.309.0 ]--
r 134         found = false;
--[ 2022.11.07.09.04.50.237.0 ]--
:/src/Walker.java
+ 17         
--[ 2022.11.07.09.04.50.775.0 ]--
r 17         i
--[ 2022.11.07.09.04.50.888.0 ]--
r 17         if
--[ 2022.11.07.09.04.51.024.0 ]--
r 17         if 
--[ 2022.11.07.09.04.51.977.0 ]--
r 17         if ()
--[ 2022.11.07.09.04.53.104.0 ]--
r 17         if (t)
--[ 2022.11.07.09.04.53.153.0 ]--
r 17         if (th)
--[ 2022.11.07.09.04.53.235.0 ]--
r 17         if (thi)
--[ 2022.11.07.09.04.53.332.0 ]--
r 17         if (this)
--[ 2022.11.07.09.04.53.503.0 ]--
r 17         if (this.)
--[ 2022.11.07.09.04.53.756.0 ]--
r 17         if (this.p)
--[ 2022.11.07.09.04.53.834.0 ]--
r 17         if (this.pa)
--[ 2022.11.07.09.04.54.005.0 ]--
r 17         if (this.pat)
--[ 2022.11.07.09.04.54.112.0 ]--
r 17         if (this.path)
--[ 2022.11.07.09.04.54.401.0 ]--
r 17         if (this.path.)
--[ 2022.11.07.09.04.54.761.0 ]--
r 17         if (this.path.h)
--[ 2022.11.07.09.04.54.840.0 ]--
r 17         if (this.path.ha)
--[ 2022.11.07.09.04.55.195.0 ]--
r 17         if (this.path.hasNext)
--[ 2022.11.07.09.04.55.200.0 ]--
r 17         if (this.path.hasNext())
--[ 2022.11.07.09.04.56.948.0 ]--
r 17         if (this.path.hasNext()) 
--[ 2022.11.07.09.04.57.269.0 ]--
r 17         if (this.path.hasNext()) {
--[ 2022.11.07.09.04.57.496.0 ]--
+ 18 
+ 19 }
--[ 2022.11.07.09.04.57.505.0 ]--
r 19         }
--[ 2022.11.07.09.04.57.510.0 ]--
r 18             
--[ 2022.11.07.09.05.00.495.0 ]--
r 20         
--[ 2022.11.07.09.05.01.885.0 ]--
r 18             this.location = this.path.next();
--[ 2022.11.07.09.05.02.992.0 ]--
r 20 
--[ 2022.11.07.09.05.08.450.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.05.58.654.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.09.05.58.741.0 ]--
r 46     private final static String emapFilename = emaps[4];        // change index to load a different elevation map
--[ 2022.11.07.09.06.00.568.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.06.20.062.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.07.14.660.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.09.07.14.732.0 ]--
r 46     private final static String emapFilename = emaps[2];        // change index to load a different elevation map
--[ 2022.11.07.09.07.17.748.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.08.08.523.0 ]--
:/src/Pathfinder.java
r 214         return pq.size();
--[ 2022.11.07.09.08.13.964.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.15.18.523.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.09.15.18.656.0 ]--
r 46     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2022.11.07.09.15.20.794.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.15.54.095.0 ]--
:/src/Pathfinder.java
r 210         return ;
--[ 2022.11.07.09.15.55.195.0 ]--
r 210         return e;
--[ 2022.11.07.09.15.55.325.0 ]--
r 210         return en;
--[ 2022.11.07.09.15.55.404.0 ]--
r 210         return end;
--[ 2022.11.07.09.15.57.517.0 ]--
r 210         return endNode.cost;
--[ 2022.11.07.09.15.57.528.0 ]--
r 210         return endNode;;
--[ 2022.11.07.09.15.57.535.0 ]--
r 210         return endNode.cost;
--[ 2022.11.07.09.16.00.617.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.20.07.362.0 ]--
r 161                  endNode = nextTile;
--[ 2022.11.07.09.20.07.911.0 ]--
r 161                 endNode = nextTile;
--[ 2022.11.07.09.20.15.167.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.23.26.054.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.24.38.335.0 ]--
:/src/Walker.java
r 10     privatefinal Iterator<Coord> path;
--[ 2022.11.07.09.24.38.336.0 ]--
r 10     private final Iterator<Coord> path;
--[ 2022.11.07.09.24.42.451.0 ]--
r 9     privatefinal Terrain terrain;
--[ 2022.11.07.09.24.42.453.0 ]--
r 9     private final Terrain terrain;
--[ 2022.11.07.09.25.55.507.0 ]--
- 43
--[ 2022.11.07.09.29.12.841.0 ]--
r 36         while (byTime >= 0.0 && this.path.hasNext()) {
--[ 2022.11.07.09.29.13.245.0 ]--
r 36         while (byTime >= 0. && this.path.hasNext()) {
--[ 2022.11.07.09.29.14.053.0 ]--
r 36         while (byTime >= 0 && this.path.hasNext()) {
--[ 2022.11.07.09.29.18.927.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.38.43.840.0 ]--
+ 39             
--[ 2022.11.07.09.38.44.469.0 ]--
r 39             s
--[ 2022.11.07.09.38.44.518.0 ]--
r 39             so
--[ 2022.11.07.09.38.44.628.0 ]--
r 39             sou
--[ 2022.11.07.09.38.44.649.0 ]--
r 39             sout
--[ 2022.11.07.09.38.44.787.0 ]--
r 39             System.out.println();
--[ 2022.11.07.09.38.46.346.0 ]--
r 39             System.out.println("");
--[ 2022.11.07.09.38.46.749.0 ]--
r 39             System.out.println("b");
--[ 2022.11.07.09.38.46.853.0 ]--
r 39             System.out.println("by");
--[ 2022.11.07.09.38.47.080.0 ]--
r 39             System.out.println("byt");
--[ 2022.11.07.09.38.47.231.0 ]--
r 39             System.out.println("byti");
--[ 2022.11.07.09.38.47.588.0 ]--
r 39             System.out.println("byt");
--[ 2022.11.07.09.38.47.749.0 ]--
r 39             System.out.println("by");
--[ 2022.11.07.09.38.47.852.0 ]--
r 39             System.out.println("byT");
--[ 2022.11.07.09.38.47.931.0 ]--
r 39             System.out.println("byTI");
--[ 2022.11.07.09.38.48.027.0 ]--
r 39             System.out.println("byTIm");
--[ 2022.11.07.09.38.48.120.0 ]--
r 39             System.out.println("byTIme");
--[ 2022.11.07.09.38.48.450.0 ]--
r 39             System.out.println("byTIme:");
--[ 2022.11.07.09.38.48.644.0 ]--
r 39             System.out.println("byTIme: ");
--[ 2022.11.07.09.38.48.964.0 ]--
r 39             System.out.println("byTIme: +");
--[ 2022.11.07.09.38.49.219.0 ]--
r 39             System.out.println("byTIme: + ");
--[ 2022.11.07.09.38.49.642.0 ]--
r 39             System.out.println("byTIme: +");
--[ 2022.11.07.09.38.49.798.0 ]--
r 39             System.out.println("byTIme: ");
--[ 2022.11.07.09.38.50.350.0 ]--
r 39             System.out.println("byTIme: " );
--[ 2022.11.07.09.38.50.508.0 ]--
r 39             System.out.println("byTIme: " +);
--[ 2022.11.07.09.38.50.658.0 ]--
r 39             System.out.println("byTIme: " + );
--[ 2022.11.07.09.38.52.146.0 ]--
r 39             System.out.println("byTIme: " + b);
--[ 2022.11.07.09.38.52.251.0 ]--
r 39             System.out.println("byTIme: " + by);
--[ 2022.11.07.09.38.52.804.0 ]--
r 39             System.out.println("byTIme: " + byTime);
--[ 2022.11.07.09.39.00.868.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.39.48.870.0 ]--
+ 41             
--[ 2022.11.07.09.39.50.004.0 ]--
r 41             i
--[ 2022.11.07.09.39.50.069.0 ]--
r 41             if
--[ 2022.11.07.09.39.50.730.0 ]--
r 41             if ()
--[ 2022.11.07.09.39.52.176.0 ]--
r 41             if (t)
--[ 2022.11.07.09.39.52.693.0 ]--
r 41             if (th)
--[ 2022.11.07.09.39.52.821.0 ]--
r 41             if (thi)
--[ 2022.11.07.09.39.52.873.0 ]--
r 41             if (this)
--[ 2022.11.07.09.39.53.082.0 ]--
r 41             if (this.)
--[ 2022.11.07.09.39.53.408.0 ]--
r 41             if (this.p)
--[ 2022.11.07.09.39.53.518.0 ]--
r 41             if (this.pa)
--[ 2022.11.07.09.39.53.633.0 ]--
r 41             if (this.pat)
--[ 2022.11.07.09.39.53.723.0 ]--
r 41             if (this.path)
--[ 2022.11.07.09.39.54.069.0 ]--
r 41             if (this.path.)
--[ 2022.11.07.09.39.54.416.0 ]--
r 41             if (this.path.h)
--[ 2022.11.07.09.39.54.557.0 ]--
r 41             if (this.path.ha)
--[ 2022.11.07.09.39.54.905.0 ]--
r 41             if (this.path.hasNext)
--[ 2022.11.07.09.39.54.910.0 ]--
r 41             if (this.path.hasNext())
--[ 2022.11.07.09.39.56.804.0 ]--
r 41             if (this.path.hasNext()) 
--[ 2022.11.07.09.39.57.079.0 ]--
r 41             if (this.path.hasNext()) {
--[ 2022.11.07.09.39.59.528.0 ]--
+ 42 
+ 43 }
--[ 2022.11.07.09.39.59.533.0 ]--
r 43             }
--[ 2022.11.07.09.39.59.546.0 ]--
r 42                 
--[ 2022.11.07.09.40.04.499.0 ]--
r 42                 c
--[ 2022.11.07.09.40.04.574.0 ]--
r 42                 co
--[ 2022.11.07.09.40.04.639.0 ]--
r 42                 con
--[ 2022.11.07.09.40.04.826.0 ]--
r 42                 cont
--[ 2022.11.07.09.40.05.630.0 ]--
r 42                 continue
--[ 2022.11.07.09.40.05.640.0 ]--
r 42                 continue;
--[ 2022.11.07.09.40.08.690.0 ]--
r 43             } 
--[ 2022.11.07.09.40.08.799.0 ]--
r 43             } e
--[ 2022.11.07.09.40.08.938.0 ]--
r 43             } el
--[ 2022.11.07.09.40.08.945.0 ]--
r 43             } els
--[ 2022.11.07.09.40.09.072.0 ]--
r 43             } else
--[ 2022.11.07.09.40.09.664.0 ]--
r 43             } else 
--[ 2022.11.07.09.40.09.854.0 ]--
r 43             } else {
--[ 2022.11.07.09.40.12.482.0 ]--
+ 45             
--[ 2022.11.07.09.40.12.713.0 ]--
r 45             }
--[ 2022.11.07.09.40.12.719.0 ]--
r 44                 doneWalking = !this.path.hasNext();
--[ 2022.11.07.09.40.17.629.0 ]--
r 44                 doneWalking = t
--[ 2022.11.07.09.40.17.790.0 ]--
r 44                 doneWalking = tr
--[ 2022.11.07.09.40.17.924.0 ]--
r 44                 doneWalking = tru
--[ 2022.11.07.09.40.18.017.0 ]--
r 44                 doneWalking = true
--[ 2022.11.07.09.40.18.487.0 ]--
r 44                 doneWalking = true;
--[ 2022.11.07.09.40.33.025.0 ]--
r 44                 doneWalking = !this.path.hasNext();
--[ 2022.11.07.09.40.33.372.0 ]--
r 44             doneWalking = !this.path.hasNext();
--[ 2022.11.07.09.40.33.549.0 ]--
r 45             
--[ 2022.11.07.09.40.33.710.0 ]--
- 45
--[ 2022.11.07.09.40.34.054.0 ]--
r 43             }
--[ 2022.11.07.09.40.34.449.0 ]--
r 42                 cont
--[ 2022.11.07.09.40.34.724.0 ]--
r 42                 
--[ 2022.11.07.09.40.34.990.0 ]--
- 42
- 42
--[ 2022.11.07.09.40.35.286.0 ]--
r 41             if (this.path.hasNext())
--[ 2022.11.07.09.40.35.953.0 ]--
r 41             if (this.path.ha)
--[ 2022.11.07.09.40.36.187.0 ]--
r 41             if ()
--[ 2022.11.07.09.40.36.429.0 ]--
r 41             if
--[ 2022.11.07.09.40.36.751.0 ]--
r 41             
--[ 2022.11.07.09.40.37.064.0 ]--
- 41
--[ 2022.11.07.09.46.31.214.0 ]--
+ 36         
--[ 2022.11.07.09.46.41.150.0 ]--
r 36         s
--[ 2022.11.07.09.46.41.264.0 ]--
r 36         so
--[ 2022.11.07.09.46.41.344.0 ]--
r 36         sou
--[ 2022.11.07.09.46.41.396.0 ]--
r 36         sout
--[ 2022.11.07.09.46.41.557.0 ]--
r 36         System.out.println();
--[ 2022.11.07.09.46.42.583.0 ]--
r 36         System.out.println("");
--[ 2022.11.07.09.46.43.615.0 ]--
r 36         System.out.println("H");
--[ 2022.11.07.09.46.43.816.0 ]--
r 36         System.out.println("Ha");
--[ 2022.11.07.09.46.43.950.0 ]--
r 36         System.out.println("Has");
--[ 2022.11.07.09.46.44.267.0 ]--
r 36         System.out.println("Hasn");
--[ 2022.11.07.09.46.44.365.0 ]--
r 36         System.out.println("Hasne");
--[ 2022.11.07.09.46.44.526.0 ]--
r 36         System.out.println("Hasnex");
--[ 2022.11.07.09.46.44.676.0 ]--
r 36         System.out.println("Hasnext");
--[ 2022.11.07.09.46.44.999.0 ]--
r 36         System.out.println("Hasnex");
--[ 2022.11.07.09.46.45.165.0 ]--
r 36         System.out.println("Hasne");
--[ 2022.11.07.09.46.45.330.0 ]--
r 36         System.out.println("Hasn");
--[ 2022.11.07.09.46.45.487.0 ]--
r 36         System.out.println("Has");
--[ 2022.11.07.09.46.45.634.0 ]--
r 36         System.out.println("HasN");
--[ 2022.11.07.09.46.45.743.0 ]--
r 36         System.out.println("HasNe");
--[ 2022.11.07.09.46.45.950.0 ]--
r 36         System.out.println("HasNex");
--[ 2022.11.07.09.46.46.078.0 ]--
r 36         System.out.println("HasNext");
--[ 2022.11.07.09.46.46.657.0 ]--
r 36         System.out.println("HasNext(");
--[ 2022.11.07.09.46.46.711.0 ]--
r 36         System.out.println("HasNext()");
--[ 2022.11.07.09.46.47.715.0 ]--
r 36         System.out.println("HasNext()" );
--[ 2022.11.07.09.46.48.138.0 ]--
r 36         System.out.println("HasNext()");
--[ 2022.11.07.09.46.48.385.0 ]--
r 36         System.out.println("HasNext());
--[ 2022.11.07.09.46.48.721.0 ]--
r 36         System.out.println("HasNext() );
--[ 2022.11.07.09.46.49.081.0 ]--
r 36         System.out.println("HasNext() ");
--[ 2022.11.07.09.46.49.194.0 ]--
r 36         System.out.println("HasNext() " );
--[ 2022.11.07.09.46.49.489.0 ]--
r 36         System.out.println("HasNext() " =);
--[ 2022.11.07.09.46.49.869.0 ]--
r 36         System.out.println("HasNext() " );
--[ 2022.11.07.09.46.50.087.0 ]--
r 36         System.out.println("HasNext() " +);
--[ 2022.11.07.09.46.50.241.0 ]--
r 36         System.out.println("HasNext() " + );
--[ 2022.11.07.09.46.51.850.0 ]--
r 36         System.out.println("HasNext() " + t);
--[ 2022.11.07.09.46.51.895.0 ]--
r 36         System.out.println("HasNext() " + th);
--[ 2022.11.07.09.46.51.992.0 ]--
r 36         System.out.println("HasNext() " + thi);
--[ 2022.11.07.09.46.52.076.0 ]--
r 36         System.out.println("HasNext() " + this);
--[ 2022.11.07.09.46.52.281.0 ]--
r 36         System.out.println("HasNext() " + this.);
--[ 2022.11.07.09.46.52.823.0 ]--
r 36         System.out.println("HasNext() " + this.p);
--[ 2022.11.07.09.46.52.903.0 ]--
r 36         System.out.println("HasNext() " + this.pa);
--[ 2022.11.07.09.46.53.022.0 ]--
r 36         System.out.println("HasNext() " + this.pat);
--[ 2022.11.07.09.46.53.107.0 ]--
r 36         System.out.println("HasNext() " + this.path);
--[ 2022.11.07.09.46.53.360.0 ]--
r 36         System.out.println("HasNext() " + this.path.);
--[ 2022.11.07.09.46.53.515.0 ]--
r 36         System.out.println("HasNext() " + this.path.h);
--[ 2022.11.07.09.46.53.567.0 ]--
r 36         System.out.println("HasNext() " + this.path.ha);
--[ 2022.11.07.09.46.53.681.0 ]--
r 36         System.out.println("HasNext() " + this.path.has);
--[ 2022.11.07.09.46.53.895.0 ]--
r 36         System.out.println("HasNext() " + this.path.hasNext);
--[ 2022.11.07.09.46.53.899.0 ]--
r 36         System.out.println("HasNext() " + this.path.hasNext());
--[ 2022.11.07.09.46.56.445.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.48.51.854.0 ]--
:/src/Pathfinder.java
r 218         return path.;
--[ 2022.11.07.09.48.52.034.0 ]--
r 218         return path.i;
--[ 2022.11.07.09.48.53.796.0 ]--
r 218         return path.iterator;
--[ 2022.11.07.09.48.53.803.0 ]--
r 218         return path.iterator();
--[ 2022.11.07.09.49.14.225.0 ]--
r 218         return path.iterator(;
--[ 2022.11.07.09.49.14.356.0 ]--
r 218         return path.iterator;
--[ 2022.11.07.09.49.14.540.0 ]--
r 218         return path.iterato;
--[ 2022.11.07.09.49.14.706.0 ]--
r 218         return path.iterat;
--[ 2022.11.07.09.49.14.894.0 ]--
r 218         return path.itera;
--[ 2022.11.07.09.49.15.058.0 ]--
r 218         return path.iter;
--[ 2022.11.07.09.49.15.227.0 ]--
r 218         return path.ite;
--[ 2022.11.07.09.49.15.442.0 ]--
r 218         return path.it;
--[ 2022.11.07.09.49.15.682.0 ]--
r 218         return path.i;
--[ 2022.11.07.09.49.16.535.0 ]--
r 218         return path.it;
--[ 2022.11.07.09.49.19.574.0 ]--
r 218         return path.i;
--[ 2022.11.07.09.49.19.744.0 ]--
r 218         return path.;
--[ 2022.11.07.09.49.20.147.0 ]--
r 218         return path;
--[ 2022.11.07.09.50.50.289.0 ]--
:/src/Walker.java
r 17         if (.path.hasNext()) {
--[ 2022.11.07.09.50.51.048.0 ]--
r 17         if (path.hasNext()) {
--[ 2022.11.07.09.50.56.349.0 ]--
r 17         if (tpath.hasNext()) {
--[ 2022.11.07.09.50.56.431.0 ]--
r 17         if (thpath.hasNext()) {
--[ 2022.11.07.09.50.56.483.0 ]--
r 17         if (thipath.hasNext()) {
--[ 2022.11.07.09.50.56.567.0 ]--
r 17         if (thispath.hasNext()) {
--[ 2022.11.07.09.50.56.722.0 ]--
r 17         if (this.path.hasNext()) {
--[ 2022.11.07.09.51.04.123.0 ]--
r 10     private  Iterator<Coord> path;
--[ 2022.11.07.09.51.05.513.0 ]--
r 9     private  Terrain terrain;
--[ 2022.11.07.09.51.05.854.0 ]--
r 9     private Terrain terrain;
--[ 2022.11.07.09.51.07.629.0 ]--
r 10     private Iterator<Coord> path;
--[ 2022.11.07.09.52.28.202.0 ]--
r 40             
--[ 2022.11.07.09.52.28.372.0 ]--
- 40
--[ 2022.11.07.09.52.32.872.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.53.31.546.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.54.21.823.0 ]--
+ 20         
--[ 2022.11.07.09.54.23.076.0 ]--
r 20         t
--[ 2022.11.07.09.54.23.170.0 ]--
r 20         th
--[ 2022.11.07.09.54.23.277.0 ]--
r 20         thi
--[ 2022.11.07.09.54.23.348.0 ]--
r 20         this
--[ 2022.11.07.09.54.23.709.0 ]--
r 20         this.
--[ 2022.11.07.09.54.23.978.0 ]--
r 20         this.l
--[ 2022.11.07.09.54.24.208.0 ]--
r 20         this.lo
--[ 2022.11.07.09.54.24.384.0 ]--
r 20         this.loc
--[ 2022.11.07.09.54.24.540.0 ]--
r 20         this.loca
--[ 2022.11.07.09.54.24.646.0 ]--
r 20         this.locat
--[ 2022.11.07.09.54.24.736.0 ]--
r 20         this.locati
--[ 2022.11.07.09.54.24.804.0 ]--
r 20         this.locatio
--[ 2022.11.07.09.54.24.919.0 ]--
r 20         this.location
--[ 2022.11.07.09.54.25.667.0 ]--
r 20         this.location 
--[ 2022.11.07.09.54.25.749.0 ]--
r 20         this.location =
--[ 2022.11.07.09.54.25.901.0 ]--
r 20         this.location = 
--[ 2022.11.07.09.54.29.091.0 ]--
r 20         this.location =
--[ 2022.11.07.09.54.29.583.0 ]--
r 20         this.location 
--[ 2022.11.07.09.54.29.665.0 ]--
r 20         this.location
--[ 2022.11.07.09.54.29.748.0 ]--
r 20         this.locatio
--[ 2022.11.07.09.54.29.832.0 ]--
r 20         this.locati
--[ 2022.11.07.09.54.29.916.0 ]--
r 20         this.locat
--[ 2022.11.07.09.54.29.999.0 ]--
r 20         this.loca
--[ 2022.11.07.09.54.30.083.0 ]--
r 20         this.loc
--[ 2022.11.07.09.54.30.167.0 ]--
r 20         this.lo
--[ 2022.11.07.09.54.30.250.0 ]--
r 20         this.l
--[ 2022.11.07.09.54.30.331.0 ]--
r 20         this.
--[ 2022.11.07.09.54.30.416.0 ]--
r 20         this
--[ 2022.11.07.09.54.30.500.0 ]--
r 20         thi
--[ 2022.11.07.09.54.30.583.0 ]--
r 20         th
--[ 2022.11.07.09.54.30.666.0 ]--
r 20         t
--[ 2022.11.07.09.54.30.901.0 ]--
r 20         
--[ 2022.11.07.09.54.31.188.0 ]--
- 20
--[ 2022.11.07.09.54.33.601.0 ]--
- 20
--[ 2022.11.07.09.55.20.456.0 ]--
+ 35         
--[ 2022.11.07.09.55.20.930.0 ]--
r 35         s
--[ 2022.11.07.09.55.21.038.0 ]--
r 35         so
--[ 2022.11.07.09.55.21.118.0 ]--
r 35         sou
--[ 2022.11.07.09.55.21.202.0 ]--
r 35         sout
--[ 2022.11.07.09.55.21.319.0 ]--
r 35         System.out.println();
--[ 2022.11.07.09.55.22.402.0 ]--
r 35         System.out.println("");
--[ 2022.11.07.09.55.22.842.0 ]--
r 35         System.out.println("p");
--[ 2022.11.07.09.55.23.200.0 ]--
r 35         System.out.println("");
--[ 2022.11.07.09.55.23.429.0 ]--
r 35         System.out.println("P");
--[ 2022.11.07.09.55.23.646.0 ]--
r 35         System.out.println("Pa");
--[ 2022.11.07.09.55.23.764.0 ]--
r 35         System.out.println("Pat");
--[ 2022.11.07.09.55.23.835.0 ]--
r 35         System.out.println("Path");
--[ 2022.11.07.09.55.24.736.0 ]--
r 35         System.out.println("Path ");
--[ 2022.11.07.09.55.25.097.0 ]--
r 35         System.out.println("Path");
--[ 2022.11.07.09.55.25.353.0 ]--
r 35         System.out.println("Path:");
--[ 2022.11.07.09.55.25.513.0 ]--
r 35         System.out.println("Path: ");
--[ 2022.11.07.09.55.25.865.0 ]--
r 35         System.out.println("Path: " );
--[ 2022.11.07.09.55.26.777.0 ]--
r 35         System.out.println("Path: " +);
--[ 2022.11.07.09.55.26.918.0 ]--
r 35         System.out.println("Path: " + );
--[ 2022.11.07.09.55.27.442.0 ]--
r 35         System.out.println("Path: " + h);
--[ 2022.11.07.09.55.27.551.0 ]--
r 35         System.out.println("Path: " + ha);
--[ 2022.11.07.09.55.27.600.0 ]--
r 35         System.out.println("Path: " + has);
--[ 2022.11.07.09.55.28.038.0 ]--
r 35         System.out.println("Path: " + hasn);
--[ 2022.11.07.09.55.28.104.0 ]--
r 35         System.out.println("Path: " + hasne);
--[ 2022.11.07.09.55.28.442.0 ]--
r 35         System.out.println("Path: " + hasnex);
--[ 2022.11.07.09.55.28.782.0 ]--
r 35         System.out.println("Path: " + hasne);
--[ 2022.11.07.09.55.28.969.0 ]--
r 35         System.out.println("Path: " + hasn);
--[ 2022.11.07.09.55.29.132.0 ]--
r 35         System.out.println("Path: " + has);
--[ 2022.11.07.09.55.29.310.0 ]--
r 35         System.out.println("Path: " + ha);
--[ 2022.11.07.09.55.29.479.0 ]--
r 35         System.out.println("Path: " + h);
--[ 2022.11.07.09.55.29.647.0 ]--
r 35         System.out.println("Path: " + );
--[ 2022.11.07.09.55.32.102.0 ]--
r 35         System.out.println("Path: " + p);
--[ 2022.11.07.09.55.32.210.0 ]--
r 35         System.out.println("Path: " + pa);
--[ 2022.11.07.09.55.32.322.0 ]--
r 35         System.out.println("Path: " + pat);
--[ 2022.11.07.09.55.32.416.0 ]--
r 35         System.out.println("Path: " + path);
--[ 2022.11.07.09.55.35.753.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.09.55.41.056.0 ]--
r 35         System.out.println("Path: " + pat);
--[ 2022.11.07.09.55.41.398.0 ]--
r 35         System.out.println("Path: " + pa);
--[ 2022.11.07.09.55.41.663.0 ]--
r 35         System.out.println("Path: " + p);
--[ 2022.11.07.09.55.44.422.0 ]--
r 35         
--[ 2022.11.07.09.55.44.894.0 ]--
- 35
--[ 2022.11.07.09.57.47.830.0 ]--
:/src/Pathfinder.java
r 218         return path.;
--[ 2022.11.07.09.57.52.878.0 ]--
r 218         return path;
--[ 2022.11.07.09.58.16.511.0 ]--
r 218         return path.;
--[ 2022.11.07.09.58.29.587.0 ]--
r 218         return path;
--[ 2022.11.07.09.58.54.268.0 ]--
:/src/Walker.java
+ 17         
--[ 2022.11.07.09.58.57.046.0 ]--
r 17         s
--[ 2022.11.07.09.58.57.109.0 ]--
r 17         so
--[ 2022.11.07.09.58.57.188.0 ]--
r 17         sou
--[ 2022.11.07.09.58.57.266.0 ]--
r 17         sout
--[ 2022.11.07.09.58.57.387.0 ]--
r 17         System.out.println();
--[ 2022.11.07.09.58.57.762.0 ]--
r 17         System.out.println(B);
--[ 2022.11.07.09.58.58.226.0 ]--
r 17         System.out.println();
--[ 2022.11.07.09.58.58.450.0 ]--
r 17         System.out.println("");
--[ 2022.11.07.09.58.58.670.0 ]--
r 17         System.out.println("B");
--[ 2022.11.07.09.58.59.169.0 ]--
r 17         System.out.println("Be");
--[ 2022.11.07.09.58.59.302.0 ]--
r 17         System.out.println("Bef");
--[ 2022.11.07.09.58.59.431.0 ]--
r 17         System.out.println("Befo");
--[ 2022.11.07.09.58.59.524.0 ]--
r 17         System.out.println("Befor");
--[ 2022.11.07.09.58.59.595.0 ]--
r 17         System.out.println("Before");
--[ 2022.11.07.09.59.01.567.0 ]--
+ 19             
--[ 2022.11.07.09.59.02.154.0 ]--
r 19             s
--[ 2022.11.07.09.59.02.218.0 ]--
r 19             so
--[ 2022.11.07.09.59.02.330.0 ]--
r 19             sou
--[ 2022.11.07.09.59.02.385.0 ]--
r 19             sout
--[ 2022.11.07.09.59.02.580.0 ]--
r 19             System.out.println();
--[ 2022.11.07.09.59.03.487.0 ]--
r 19             System.out.println("");
--[ 2022.11.07.09.59.03.906.0 ]--
r 19             System.out.println("a");
--[ 2022.11.07.09.59.04.363.0 ]--
r 19             System.out.println("");
--[ 2022.11.07.09.59.04.562.0 ]--
r 19             System.out.println("A");
--[ 2022.11.07.09.59.04.803.0 ]--
r 19             System.out.println("Af");
--[ 2022.11.07.09.59.05.033.0 ]--
r 19             System.out.println("Aft");
--[ 2022.11.07.09.59.05.121.0 ]--
r 19             System.out.println("Afte");
--[ 2022.11.07.09.59.05.219.0 ]--
r 19             System.out.println("After");
--[ 2022.11.07.09.59.07.259.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.04.53.133.0 ]--
:/src/Pathfinder.java
+ 218         
--[ 2022.11.07.10.04.57.918.0 ]--
r 218         i
--[ 2022.11.07.10.04.58.023.0 ]--
r 218         it
--[ 2022.11.07.10.04.58.079.0 ]--
r 218         ite
--[ 2022.11.07.10.04.58.193.0 ]--
r 218         iter
--[ 2022.11.07.10.04.58.811.0 ]--
r 218         iterP
--[ 2022.11.07.10.04.58.952.0 ]--
r 218         iterPa
--[ 2022.11.07.10.04.59.047.0 ]--
r 218         iterPat
--[ 2022.11.07.10.04.59.158.0 ]--
r 218         iterPath
--[ 2022.11.07.10.04.59.839.0 ]--
r 218         iterPath 
--[ 2022.11.07.10.04.59.950.0 ]--
r 218         iterPath =
--[ 2022.11.07.10.05.00.063.0 ]--
r 218         iterPath = 
--[ 2022.11.07.10.05.04.573.0 ]--
r 218         IiterPath = 
--[ 2022.11.07.10.05.04.731.0 ]--
r 218         ItiterPath = 
--[ 2022.11.07.10.05.04.835.0 ]--
r 218         IteiterPath = 
--[ 2022.11.07.10.05.04.920.0 ]--
r 218         IteriterPath = 
--[ 2022.11.07.10.05.05.033.0 ]--
r 218         IteraiterPath = 
--[ 2022.11.07.10.05.06.461.0 ]--
r 218         IterableiterPath = 
--[ 2022.11.07.10.05.06.469.0 ]--
r 218         Iterable iterPath = 
--[ 2022.11.07.10.05.06.477.0 ]--
r 218         IterableiterPath = 
--[ 2022.11.07.10.05.07.423.0 ]--
r 218         Iterable<iterPath = 
--[ 2022.11.07.10.05.07.896.0 ]--
r 218         Iterable<CiterPath = 
--[ 2022.11.07.10.05.08.062.0 ]--
r 218         Iterable<CoiterPath = 
--[ 2022.11.07.10.05.08.152.0 ]--
r 218         Iterable<CooiterPath = 
--[ 2022.11.07.10.05.08.248.0 ]--
r 218         Iterable<CooriterPath = 
--[ 2022.11.07.10.05.08.356.0 ]--
r 218         Iterable<CoorditerPath = 
--[ 2022.11.07.10.05.08.663.0 ]--
r 218         Iterable<Coord>iterPath = 
--[ 2022.11.07.10.05.09.440.0 ]--
r 218         Iterable<Coord> iterPath = 
--[ 2022.11.07.10.05.11.021.0 ]--
r 218         Iterable<Coord> iterPath = p
--[ 2022.11.07.10.05.11.084.0 ]--
r 218         Iterable<Coord> iterPath = pa
--[ 2022.11.07.10.05.11.195.0 ]--
r 218         Iterable<Coord> iterPath = pat
--[ 2022.11.07.10.05.11.251.0 ]--
r 218         Iterable<Coord> iterPath = path
--[ 2022.11.07.10.05.11.548.0 ]--
r 218         Iterable<Coord> iterPath = path.
--[ 2022.11.07.10.05.11.817.0 ]--
r 218         Iterable<Coord> iterPath = path.i
--[ 2022.11.07.10.05.11.953.0 ]--
r 218         Iterable<Coord> iterPath = path.it
--[ 2022.11.07.10.05.12.059.0 ]--
r 218         Iterable<Coord> iterPath = path.ite
--[ 2022.11.07.10.05.12.233.0 ]--
r 218         Iterable<Coord> iterPath = path.iterator
--[ 2022.11.07.10.05.12.238.0 ]--
r 218         Iterable<Coord> iterPath = path.iterator()
--[ 2022.11.07.10.05.13.011.0 ]--
r 218         Iterable<Coord> iterPath = path.iterator();
--[ 2022.11.07.10.05.21.540.0 ]--
r 218         Iterable<Coord> iterPath = (Iterable<Coord>) path.iterator();
--[ 2022.11.07.10.05.30.481.0 ]--
r 219         return i;
--[ 2022.11.07.10.05.30.618.0 ]--
r 219         return ie;
--[ 2022.11.07.10.05.30.740.0 ]--
r 219         return iet;
--[ 2022.11.07.10.05.31.171.0 ]--
r 219         return ie;
--[ 2022.11.07.10.05.31.326.0 ]--
r 219         return i;
--[ 2022.11.07.10.05.31.363.0 ]--
r 219         return it;
--[ 2022.11.07.10.05.31.460.0 ]--
r 219         return ite;
--[ 2022.11.07.10.05.31.553.0 ]--
r 219         return iter;
--[ 2022.11.07.10.05.31.710.0 ]--
r 219         return iterp;
--[ 2022.11.07.10.05.31.849.0 ]--
r 219         return iterpa;
--[ 2022.11.07.10.05.31.983.0 ]--
r 219         return iterpat;
--[ 2022.11.07.10.05.32.065.0 ]--
r 219         return iterpath;
--[ 2022.11.07.10.05.33.429.0 ]--
r 219         return iterPath;
--[ 2022.11.07.10.05.38.587.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.05.44.550.0 ]--
r 219         return iterpath;
--[ 2022.11.07.10.05.44.836.0 ]--
r 219         return i;
--[ 2022.11.07.10.05.44.995.0 ]--
r 219         return iet;
--[ 2022.11.07.10.05.45.244.0 ]--
r 219         return path;
--[ 2022.11.07.10.05.45.711.0 ]--
r 218         Iterable<Coord> iterPath = path.iterator();
--[ 2022.11.07.10.05.45.972.0 ]--
r 218         Iterable<Coord> iterPath = path.iterator()
--[ 2022.11.07.10.05.46.351.0 ]--
r 218         Iterable<Coord> iterPath = path.ite
--[ 2022.11.07.10.05.46.700.0 ]--
r 218         Iterable<Coord> iterPath = 
--[ 2022.11.07.10.05.47.330.0 ]--
r 218         IterableiterPath = 
--[ 2022.11.07.10.05.47.641.0 ]--
r 218         IteraiterPath = 
--[ 2022.11.07.10.05.48.006.0 ]--
r 218         iterPath = 
--[ 2022.11.07.10.05.48.669.0 ]--
r 218         
--[ 2022.11.07.10.05.49.057.0 ]--
- 218
--[ 2022.11.07.10.05.52.115.0 ]--
+ 218         
--[ 2022.11.07.10.05.53.353.0 ]--
r 218         s
--[ 2022.11.07.10.05.53.436.0 ]--
r 218         so
--[ 2022.11.07.10.05.53.514.0 ]--
r 218         sou
--[ 2022.11.07.10.05.53.650.0 ]--
r 218         sout
--[ 2022.11.07.10.05.53.740.0 ]--
r 218         System.out.println();
--[ 2022.11.07.10.05.55.112.0 ]--
r 218         System.out.println("");
--[ 2022.11.07.10.05.55.927.0 ]--
r 218         System.out.println("T");
--[ 2022.11.07.10.05.56.022.0 ]--
r 218         System.out.println("Ty");
--[ 2022.11.07.10.05.56.133.0 ]--
r 218         System.out.println("Typ");
--[ 2022.11.07.10.05.56.242.0 ]--
r 218         System.out.println("Type");
--[ 2022.11.07.10.05.56.796.0 ]--
r 218         System.out.println("Type:");
--[ 2022.11.07.10.05.56.914.0 ]--
r 218         System.out.println("Type: ");
--[ 2022.11.07.10.05.57.272.0 ]--
r 218         System.out.println("Type: " );
--[ 2022.11.07.10.05.58.755.0 ]--
r 218         System.out.println("Type: " t);
--[ 2022.11.07.10.05.59.107.0 ]--
r 218         System.out.println("Type: " );
--[ 2022.11.07.10.05.59.318.0 ]--
r 218         System.out.println("Type: " p);
--[ 2022.11.07.10.05.59.399.0 ]--
r 218         System.out.println("Type: " pa);
--[ 2022.11.07.10.05.59.487.0 ]--
r 218         System.out.println("Type: " pat);
--[ 2022.11.07.10.05.59.556.0 ]--
r 218         System.out.println("Type: " path);
--[ 2022.11.07.10.05.59.791.0 ]--
r 218         System.out.println("Type: " path.);
--[ 2022.11.07.10.06.00.060.0 ]--
r 218         System.out.println("Type: " path.t);
--[ 2022.11.07.10.06.01.059.0 ]--
r 218         System.out.println("Type: " path.ty);
--[ 2022.11.07.10.06.02.007.0 ]--
r 218         System.out.println("Type: " path.t);
--[ 2022.11.07.10.06.02.192.0 ]--
r 218         System.out.println("Type: " path.);
--[ 2022.11.07.10.06.03.464.0 ]--
r 218         System.out.println("Type: " path);
--[ 2022.11.07.10.06.03.770.0 ]--
r 218         System.out.println("Type: " pat);
--[ 2022.11.07.10.06.03.929.0 ]--
r 218         System.out.println("Type: " pa);
--[ 2022.11.07.10.06.04.093.0 ]--
r 218         System.out.println("Type: " p);
--[ 2022.11.07.10.06.04.294.0 ]--
r 218         System.out.println("Type: " );
--[ 2022.11.07.10.06.05.124.0 ]--
r 218         System.out.println("Type: " t);
--[ 2022.11.07.10.06.05.249.0 ]--
r 218         System.out.println("Type: " ty);
--[ 2022.11.07.10.06.05.336.0 ]--
r 218         System.out.println("Type: " typ);
--[ 2022.11.07.10.06.05.398.0 ]--
r 218         System.out.println("Type: " type);
--[ 2022.11.07.10.06.05.852.0 ]--
r 218         System.out.println("Type: " type());
--[ 2022.11.07.10.06.06.899.0 ]--
r 218         System.out.println("Type: " type);
--[ 2022.11.07.10.06.07.058.0 ]--
r 218         System.out.println("Type: " typ);
--[ 2022.11.07.10.06.07.243.0 ]--
r 218         System.out.println("Type: " ty);
--[ 2022.11.07.10.06.07.422.0 ]--
r 218         System.out.println("Type: " t);
--[ 2022.11.07.10.06.07.602.0 ]--
r 218         System.out.println("Type: " );
--[ 2022.11.07.10.06.20.192.0 ]--
r 218         System.out.println("Type: " p);
--[ 2022.11.07.10.06.20.280.0 ]--
r 218         System.out.println("Type: " pa);
--[ 2022.11.07.10.06.20.383.0 ]--
r 218         System.out.println("Type: " pat);
--[ 2022.11.07.10.06.20.394.0 ]--
r 218         System.out.println("Type: " path);
--[ 2022.11.07.10.06.20.655.0 ]--
r 218         System.out.println("Type: " path.);
--[ 2022.11.07.10.06.21.148.0 ]--
r 218         System.out.println("Type: " path.j);
--[ 2022.11.07.10.06.21.189.0 ]--
r 218         System.out.println("Type: " path.je);
--[ 2022.11.07.10.06.21.572.0 ]--
r 218         System.out.println("Type: " path.j);
--[ 2022.11.07.10.06.21.722.0 ]--
r 218         System.out.println("Type: " path.);
--[ 2022.11.07.10.06.21.767.0 ]--
r 218         System.out.println("Type: " path.g);
--[ 2022.11.07.10.06.21.886.0 ]--
r 218         System.out.println("Type: " path.ge);
--[ 2022.11.07.10.06.21.990.0 ]--
r 218         System.out.println("Type: " path.get);
--[ 2022.11.07.10.06.23.144.0 ]--
r 218         System.out.println("Type: " path.getClass);
--[ 2022.11.07.10.06.23.150.0 ]--
r 218         System.out.println("Type: " path.getClass());
--[ 2022.11.07.10.06.26.434.0 ]--
UpdateTree (AD): 0 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.06.26.435.0 ]--
CompilationStatus (AEW): 0 2 0
[Ljava.lang.String;@53d031a0
--[ 2022.11.07.10.06.31.313.0 ]--
r 218         System.out.println("Type: " +path.getClass());
--[ 2022.11.07.10.06.31.314.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.06.31.316.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.06.31.318.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.06.31.319.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.06.31.321.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.06.31.323.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.06.31.635.0 ]--
r 218         System.out.println("Type: " + path.getClass());
--[ 2022.11.07.10.06.31.636.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.06.31.638.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.06.33.948.0 ]--
UpdateTree (AD): 2 0
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.06.33.948.1 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.07.11.248.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.10.07.11.337.0 ]--
r 46     private final static String emapFilename = emaps[5];        // change index to load a different elevation map
--[ 2022.11.07.10.07.13.846.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.07.54.113.0 ]--
:/src/Pathfinder.java
r 218         
--[ 2022.11.07.10.07.54.274.0 ]--
- 218
--[ 2022.11.07.10.08.51.602.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.10.08.52.026.0 ]--
r 46     private final static String emapFilename = emaps[4];        // change index to load a different elevation map
--[ 2022.11.07.10.08.54.225.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.11.15.840.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.12.39.340.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.10.12.39.746.0 ]--
r 46     private final static String emapFilename = emaps[2];        // change index to load a different elevation map
--[ 2022.11.07.10.12.42.110.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.14.17.296.0 ]--
:/src/Pathfinder.java
- 61
--[ 2022.11.07.10.14.19.367.0 ]--
- 57
--[ 2022.11.07.10.14.25.434.0 ]--
- 63
r 63           
--[ 2022.11.07.10.14.25.594.0 ]--
- 63
--[ 2022.11.07.10.15.55.718.0 ]--
- 57
r 57             if(this.prevNode == null) {return 0;
--[ 2022.11.07.10.15.55.982.0 ]--
r 57             if(this.prevNode == null) return 0;
--[ 2022.11.07.10.15.57.388.0 ]--
r 57             if(this.prevNode == null) {return 0;
--[ 2022.11.07.10.15.58.238.0 ]--
r 57             if(this.prevNode == null) { return 0;
--[ 2022.11.07.10.16.00.874.0 ]--
- 57
r 57             if(this.prevNode == null) { return 0;}
--[ 2022.11.07.10.16.01.750.0 ]--
r 57             if(this.prevNode == null) { return 0; }
--[ 2022.11.07.10.16.04.457.0 ]--
+ 57             if(this.prevNode == null) { return 0; 
r 58             }
--[ 2022.11.07.10.16.05.345.0 ]--
r 57             if(this.prevNode == null) { return 0;
--[ 2022.11.07.10.16.06.894.0 ]--
- 57
r 57             if(this.prevNode == null) { return 0;}
--[ 2022.11.07.10.16.08.186.0 ]--
r 57             if(this.prevNode == null) { return 0; }
--[ 2022.11.07.10.16.09.166.0 ]--
+ 58             
--[ 2022.11.07.10.16.40.167.0 ]--
r 58 
--[ 2022.11.07.10.16.40.920.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.18.19.070.0 ]--
:/src/Walker.java
+ 17         
--[ 2022.11.07.10.18.20.177.0 ]--
- 17
--[ 2022.11.07.10.18.43.385.0 ]--
:/src/Pathfinder.java
+ 154                     
--[ 2022.11.07.10.18.43.956.0 ]--
r 154                     s
--[ 2022.11.07.10.18.44.051.0 ]--
r 154                     so
--[ 2022.11.07.10.18.44.106.0 ]--
r 154                     sou
--[ 2022.11.07.10.18.44.190.0 ]--
r 154                     sout
--[ 2022.11.07.10.18.44.351.0 ]--
r 154                     System.out.println();
--[ 2022.11.07.10.18.48.126.0 ]--
r 154                     System.out.println(n);
--[ 2022.11.07.10.18.48.227.0 ]--
r 154                     System.out.println(ne);
--[ 2022.11.07.10.18.48.790.0 ]--
r 154                     System.out.println(nextTile);
--[ 2022.11.07.10.18.49.164.0 ]--
r 154                     System.out.println(nextTile.);
--[ 2022.11.07.10.18.49.335.0 ]--
r 154                     System.out.println(nextTile.c);
--[ 2022.11.07.10.18.49.421.0 ]--
r 154                     System.out.println(nextTile.cu);
--[ 2022.11.07.10.18.49.530.0 ]--
r 154                     System.out.println(nextTile.cur);
--[ 2022.11.07.10.18.49.717.0 ]--
r 154                     System.out.println(nextTile.currentTile);
--[ 2022.11.07.10.18.52.152.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.19.15.657.0 ]--
r 153                 for (path = new Stack<C>(); nextTile.prevNode == null; nextTile = nextTile.prevNode) {
--[ 2022.11.07.10.19.15.928.0 ]--
r 153                 for (path = new Stack<Co>(); nextTile.prevNode == null; nextTile = nextTile.prevNode) {
--[ 2022.11.07.10.19.16.059.0 ]--
r 153                 for (path = new Stack<Coo>(); nextTile.prevNode == null; nextTile = nextTile.prevNode) {
--[ 2022.11.07.10.19.16.131.0 ]--
r 153                 for (path = new Stack<Coor>(); nextTile.prevNode == null; nextTile = nextTile.prevNode) {
--[ 2022.11.07.10.19.16.234.0 ]--
r 153                 for (path = new Stack<Coord>(); nextTile.prevNode == null; nextTile = nextTile.prevNode) {
--[ 2022.11.07.10.19.53.088.0 ]--
r 153                 for (path = new Stack<Coord>(); nextTile.prevNode =!= null; nextTile = nextTile.prevNode) {
--[ 2022.11.07.10.19.56.252.0 ]--
r 153                 for (path = new Stack<Coord>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
--[ 2022.11.07.10.20.02.970.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.20.22.929.0 ]--
r 154                     /System.out.println(nextTile.currentTile);
--[ 2022.11.07.10.20.23.052.0 ]--
r 154                     //System.out.println(nextTile.currentTile);
--[ 2022.11.07.10.20.25.553.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.21.00.252.0 ]--
:/src/Walker.java
r 17         
--[ 2022.11.07.10.21.00.395.0 ]--
- 17
--[ 2022.11.07.10.21.02.495.0 ]--
r 18             
--[ 2022.11.07.10.21.02.633.0 ]--
- 18
--[ 2022.11.07.10.21.09.650.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.10.21.10.104.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.07.10.21.10.543.0 ]--
r 46     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2022.11.07.10.21.12.665.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.27.53.741.0 ]--
UpdateTree (AD): 1 0
+ /P04_Pathfinding.zip

--[ 2022.11.07.10.27.53.741.1 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.30.35.502.0 ]--
:/src/Walker.java
r 35         
--[ 2022.11.07.10.30.35.651.0 ]--
- 35
--[ 2022.11.07.10.30.41.826.0 ]--
r 35         while (byTime >= 0. && this.path.hasNext()) {
--[ 2022.11.07.10.30.41.952.0 ]--
r 35         while (byTime >= 0.0 && this.path.hasNext()) {
--[ 2022.11.07.10.30.42.319.0 ]--
r 35         while (byTime >= 0.0f && this.path.hasNext()) {
--[ 2022.11.07.10.30.44.705.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.35.55.896.0 ]--
:/src/Pathfinder.java
r 59             this.cost = this.prevNode.c
--[ 2022.11.07.10.35.56.093.0 ]--
r 59             this.cost = this.prevNode.co
--[ 2022.11.07.10.35.56.195.0 ]--
r 59             this.cost = this.prevNode.cos
--[ 2022.11.07.10.35.56.328.0 ]--
r 59             this.cost = this.prevNode.cost
--[ 2022.11.07.10.37.17.476.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.37.37.564.0 ]--
+ 206         
--[ 2022.11.07.10.37.37.985.0 ]--
r 206         s
--[ 2022.11.07.10.37.38.088.0 ]--
r 206         so
--[ 2022.11.07.10.37.38.172.0 ]--
r 206         sou
--[ 2022.11.07.10.37.38.220.0 ]--
r 206         sout
--[ 2022.11.07.10.37.38.345.0 ]--
r 206         System.out.println();
--[ 2022.11.07.10.37.39.229.0 ]--
r 206         System.out.println("");
--[ 2022.11.07.10.37.39.423.0 ]--
r 206         System.out.println("C");
--[ 2022.11.07.10.37.39.608.0 ]--
r 206         System.out.println("CO");
--[ 2022.11.07.10.37.39.738.0 ]--
r 206         System.out.println("COS");
--[ 2022.11.07.10.37.40.209.0 ]--
r 206         System.out.println("CO");
--[ 2022.11.07.10.37.40.711.0 ]--
r 206         System.out.println("C");
--[ 2022.11.07.10.37.40.846.0 ]--
r 206         System.out.println("Co");
--[ 2022.11.07.10.37.40.892.0 ]--
r 206         System.out.println("Cos");
--[ 2022.11.07.10.37.40.991.0 ]--
r 206         System.out.println("Cost");
--[ 2022.11.07.10.37.41.186.0 ]--
r 206         System.out.println("Cost ");
--[ 2022.11.07.10.37.41.959.0 ]--
r 206         System.out.println("Cost");
--[ 2022.11.07.10.37.42.277.0 ]--
r 206         System.out.println("Cost ");
--[ 2022.11.07.10.37.42.605.0 ]--
r 206         System.out.println("Cost");
--[ 2022.11.07.10.37.42.902.0 ]--
r 206         System.out.println("Cost;");
--[ 2022.11.07.10.37.43.197.0 ]--
r 206         System.out.println("Cost; ");
--[ 2022.11.07.10.37.43.512.0 ]--
r 206         System.out.println("Cost;");
--[ 2022.11.07.10.37.43.639.0 ]--
r 206         System.out.println("Cost");
--[ 2022.11.07.10.37.43.873.0 ]--
r 206         System.out.println("Cost;");
--[ 2022.11.07.10.37.44.090.0 ]--
r 206         System.out.println("Cost; ");
--[ 2022.11.07.10.37.44.589.0 ]--
r 206         System.out.println("Cost; );
--[ 2022.11.07.10.37.44.749.0 ]--
r 206         System.out.println("Cost;);
--[ 2022.11.07.10.37.44.918.0 ]--
r 206         System.out.println("Cost);
--[ 2022.11.07.10.37.45.187.0 ]--
r 206         System.out.println("Cost:);
--[ 2022.11.07.10.37.45.361.0 ]--
r 206         System.out.println("Cost: );
--[ 2022.11.07.10.37.45.563.0 ]--
r 206         System.out.println("Cost: ");
--[ 2022.11.07.10.37.45.723.0 ]--
r 206         System.out.println("Cost: " );
--[ 2022.11.07.10.37.46.622.0 ]--
r 206         System.out.println("Cost: " +);
--[ 2022.11.07.10.37.46.727.0 ]--
r 206         System.out.println("Cost: " + );
--[ 2022.11.07.10.37.47.554.0 ]--
r 206         System.out.println("Cost: " + e);
--[ 2022.11.07.10.37.47.656.0 ]--
r 206         System.out.println("Cost: " + en);
--[ 2022.11.07.10.37.47.744.0 ]--
r 206         System.out.println("Cost: " + end);
--[ 2022.11.07.10.37.47.854.0 ]--
r 206         System.out.println("Cost: " + endn);
--[ 2022.11.07.10.37.47.976.0 ]--
r 206         System.out.println("Cost: " + endno);
--[ 2022.11.07.10.37.48.377.0 ]--
r 206         System.out.println("Cost: " + endNode);
--[ 2022.11.07.10.37.48.718.0 ]--
r 206         System.out.println("Cost: " + endNode.);
--[ 2022.11.07.10.37.48.862.0 ]--
r 206         System.out.println("Cost: " + endNode.c);
--[ 2022.11.07.10.37.48.959.0 ]--
r 206         System.out.println("Cost: " + endNode.co);
--[ 2022.11.07.10.37.49.046.0 ]--
r 206         System.out.println("Cost: " + endNode.cos);
--[ 2022.11.07.10.37.49.226.0 ]--
r 206         System.out.println("Cost: " + endNode.cost);
--[ 2022.11.07.10.37.51.629.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.38.13.073.0 ]--
r 57             /if(this.prevNode == null) { return 0; }
--[ 2022.11.07.10.38.13.205.0 ]--
r 57             //if(this.prevNode == null) { return 0; }
--[ 2022.11.07.10.38.15.502.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.38.32.707.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.07.10.38.32.845.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.10.38.33.451.0 ]--
r 46     private final static String emapFilename = emaps[3];        // change index to load a different elevation map
--[ 2022.11.07.10.38.36.195.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.38.44.992.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.10.38.45.469.0 ]--
r 46     private final static String emapFilename = emaps[2];        // change index to load a different elevation map
--[ 2022.11.07.10.38.47.223.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.39.04.361.0 ]--
:/src/Pathfinder.java
r 153                 for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
--[ 2022.11.07.10.39.17.918.0 ]--
+ 157                 
--[ 2022.11.07.10.39.18.810.0 ]--
r 157                 n
--[ 2022.11.07.10.39.18.861.0 ]--
r 157                 ne
--[ 2022.11.07.10.39.19.041.0 ]--
r 157                 nex
--[ 2022.11.07.10.39.19.147.0 ]--
r 157                 next
--[ 2022.11.07.10.39.19.576.0 ]--
r 157                 nextTile
--[ 2022.11.07.10.39.19.968.0 ]--
r 157                 nextTile.
--[ 2022.11.07.10.39.20.396.0 ]--
r 157                 nextTile.g
--[ 2022.11.07.10.39.20.480.0 ]--
r 157                 nextTile.ge
--[ 2022.11.07.10.39.20.597.0 ]--
r 157                 nextTile.get
--[ 2022.11.07.10.39.21.118.0 ]--
r 157                 nextTile.getCost
--[ 2022.11.07.10.39.21.130.0 ]--
r 157                 nextTile.getCost()
--[ 2022.11.07.10.39.22.292.0 ]--
r 157                 nextTile.getCost(h)
--[ 2022.11.07.10.39.22.674.0 ]--
r 157                 nextTile.getCost(heuristic)
--[ 2022.11.07.10.39.23.819.0 ]--
r 157                 nextTile.getCost(heuristic);
--[ 2022.11.07.10.39.26.189.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.39.38.756.0 ]--
r 57             //\if(this.prevNode == null) { return 0; }
--[ 2022.11.07.10.39.38.899.0 ]--
r 57             //\\if(this.prevNode == null) { return 0; }
--[ 2022.11.07.10.39.39.196.0 ]--
r 57             //\if(this.prevNode == null) { return 0; }
--[ 2022.11.07.10.39.39.342.0 ]--
r 57             //if(this.prevNode == null) { return 0; }
--[ 2022.11.07.10.39.39.512.0 ]--
r 57             /if(this.prevNode == null) { return 0; }
--[ 2022.11.07.10.39.39.665.0 ]--
r 57             if(this.prevNode == null) { return 0; }
--[ 2022.11.07.10.39.41.994.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.40.01.182.0 ]--
r 207         
--[ 2022.11.07.10.40.01.349.0 ]--
- 207
--[ 2022.11.07.10.41.17.120.0 ]--
r 57             if(this.prevNode == null) { ; }
--[ 2022.11.07.10.41.18.356.0 ]--
r 57             if(this.prevNode == null) {  }
--[ 2022.11.07.10.41.20.766.0 ]--
r 57             if(this.prevNode == null) { t }
--[ 2022.11.07.10.41.20.840.0 ]--
r 57             if(this.prevNode == null) { th }
--[ 2022.11.07.10.41.20.905.0 ]--
r 57             if(this.prevNode == null) { thi }
--[ 2022.11.07.10.41.20.992.0 ]--
r 57             if(this.prevNode == null) { this }
--[ 2022.11.07.10.41.21.126.0 ]--
r 57             if(this.prevNode == null) { this. }
--[ 2022.11.07.10.41.21.370.0 ]--
r 57             if(this.prevNode == null) { this.p }
--[ 2022.11.07.10.41.21.444.0 ]--
r 57             if(this.prevNode == null) { this.pr }
--[ 2022.11.07.10.41.21.510.0 ]--
r 57             if(this.prevNode == null) { this.pre }
--[ 2022.11.07.10.41.22.102.0 ]--
r 57             if(this.prevNode == null) { this.prevNode }
--[ 2022.11.07.10.41.22.590.0 ]--
r 57             if(this.prevNode == null) { this.prevNode. }
--[ 2022.11.07.10.41.22.829.0 ]--
r 57             if(this.prevNode == null) { this.prevNode.c }
--[ 2022.11.07.10.41.22.872.0 ]--
r 57             if(this.prevNode == null) { this.prevNode.co }
--[ 2022.11.07.10.41.22.985.0 ]--
r 57             if(this.prevNode == null) { this.prevNode.cos }
--[ 2022.11.07.10.41.23.129.0 ]--
r 57             if(this.prevNode == null) { this.prevNode.cost }
--[ 2022.11.07.10.41.23.432.0 ]--
r 57             if(this.prevNode == null) { this.prevNode.cost  }
--[ 2022.11.07.10.41.23.485.0 ]--
r 57             if(this.prevNode == null) { this.prevNode.cost = }
--[ 2022.11.07.10.41.23.598.0 ]--
r 57             if(this.prevNode == null) { this.prevNode.cost =  }
--[ 2022.11.07.10.41.24.244.0 ]--
r 57             if(this.prevNode == null) { this.prevNode.cost = 0 }
--[ 2022.11.07.10.41.24.683.0 ]--
r 57             if(this.prevNode == null) { this.prevNode.cost = 0; }
--[ 2022.11.07.10.41.32.369.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.41.59.393.0 ]--
r 57             if(this.prevNode == null) { t 0; }
--[ 2022.11.07.10.41.59.575.0 ]--
r 57             if(this.prevNode == null) {  0; }
--[ 2022.11.07.10.41.59.725.0 ]--
r 57             if(this.prevNode == null) { r 0; }
--[ 2022.11.07.10.41.59.823.0 ]--
r 57             if(this.prevNode == null) { re 0; }
--[ 2022.11.07.10.41.59.992.0 ]--
r 57             if(this.prevNode == null) { ret 0; }
--[ 2022.11.07.10.42.00.074.0 ]--
r 57             if(this.prevNode == null) { retu 0; }
--[ 2022.11.07.10.42.00.233.0 ]--
r 57             if(this.prevNode == null) { retur 0; }
--[ 2022.11.07.10.42.00.337.0 ]--
r 57             if(this.prevNode == null) { return 0; }
--[ 2022.11.07.10.42.35.930.0 ]--
r 57             if(this.prevNode = null) { return 0; }
--[ 2022.11.07.10.42.36.629.0 ]--
r 57             if(this.prevNode != null) { return 0; }
--[ 2022.11.07.10.42.42.610.0 ]--
r 57             if(this.prevNode != null) { 
--[ 2022.11.07.10.42.47.881.0 ]--
- 57
r 57             if(this.prevNode != null) {
--[ 2022.11.07.10.42.50.792.0 ]--
r 58                 this.cost = this.prevNode.cost
r 59                         + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
r 60                         + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
r 61                 return this.cost;
--[ 2022.11.07.10.42.53.956.0 ]--
r 62             }
--[ 2022.11.07.10.42.55.249.0 ]--
+ 63             
--[ 2022.11.07.10.42.55.385.0 ]--
r 63             e
--[ 2022.11.07.10.42.55.490.0 ]--
r 63             el
--[ 2022.11.07.10.42.55.576.0 ]--
r 63             els
--[ 2022.11.07.10.42.55.656.0 ]--
r 63             else
--[ 2022.11.07.10.42.57.271.0 ]--
r 63             else 
--[ 2022.11.07.10.42.57.356.0 ]--
r 63             else r
--[ 2022.11.07.10.42.57.441.0 ]--
r 63             else re
--[ 2022.11.07.10.42.57.571.0 ]--
r 63             else ret
--[ 2022.11.07.10.42.57.683.0 ]--
r 63             else retu
--[ 2022.11.07.10.42.57.757.0 ]--
r 63             else retur
--[ 2022.11.07.10.42.57.897.0 ]--
r 63             else return
--[ 2022.11.07.10.42.58.007.0 ]--
r 63             else return 
--[ 2022.11.07.10.42.58.297.0 ]--
r 63             else return 0
--[ 2022.11.07.10.42.58.554.0 ]--
r 63             else return 0;
--[ 2022.11.07.10.43.00.517.0 ]--
UpdateTree (AD): 0 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.00.517.1 ]--
CompilationStatus (AEW): 0 1 0
[Ljava.lang.String;@70e5785b
--[ 2022.11.07.10.43.23.272.0 ]--
+ 64             
--[ 2022.11.07.10.43.23.273.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.23.275.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.23.694.0 ]--
r 64             }
--[ 2022.11.07.10.43.23.694.1 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.23.700.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.23.707.0 ]--
r 57             if (this.prevNode != null) {
--[ 2022.11.07.10.43.23.707.1 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.23.711.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.23.714.0 ]--
- 62
r 62             } else return 0;
--[ 2022.11.07.10.43.23.715.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.23.718.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.23.721.0 ]--
r 63         }
--[ 2022.11.07.10.43.23.721.1 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.23.722.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.27.904.0 ]--
UpdateTree (AD): 2 0
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.43.27.904.1 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.43.45.535.0 ]--
+ 61                 
--[ 2022.11.07.10.43.46.293.0 ]--
r 61                 s
--[ 2022.11.07.10.43.46.362.0 ]--
r 61                 so
--[ 2022.11.07.10.43.46.440.0 ]--
r 61                 sou
--[ 2022.11.07.10.43.46.495.0 ]--
r 61                 sout
--[ 2022.11.07.10.43.46.650.0 ]--
r 61                 System.out.println();
--[ 2022.11.07.10.43.47.235.0 ]--
r 61                 System.out.println(());
--[ 2022.11.07.10.43.47.685.0 ]--
r 61                 System.out.println();
--[ 2022.11.07.10.43.48.391.0 ]--
r 61                 System.out.println("");
--[ 2022.11.07.10.43.48.691.0 ]--
r 61                 System.out.println("C");
--[ 2022.11.07.10.43.48.882.0 ]--
r 61                 System.out.println("CO");
--[ 2022.11.07.10.43.48.979.0 ]--
r 61                 System.out.println("COS");
--[ 2022.11.07.10.43.49.387.0 ]--
r 61                 System.out.println("COST");
--[ 2022.11.07.10.43.49.766.0 ]--
r 61                 System.out.println("COST:");
--[ 2022.11.07.10.43.49.937.0 ]--
r 61                 System.out.println("COST: ");
--[ 2022.11.07.10.43.50.709.0 ]--
r 61                 System.out.println("COST: " );
--[ 2022.11.07.10.43.50.881.0 ]--
r 61                 System.out.println("COST: " _);
--[ 2022.11.07.10.43.50.956.0 ]--
r 61                 System.out.println("COST: " _ );
--[ 2022.11.07.10.43.51.468.0 ]--
r 61                 System.out.println("COST: " _);
--[ 2022.11.07.10.43.51.606.0 ]--
r 61                 System.out.println("COST: " );
--[ 2022.11.07.10.43.51.819.0 ]--
r 61                 System.out.println("COST: " _);
--[ 2022.11.07.10.43.52.439.0 ]--
r 61                 System.out.println("COST: " );
--[ 2022.11.07.10.43.52.669.0 ]--
r 61                 System.out.println("COST: " +);
--[ 2022.11.07.10.43.53.025.0 ]--
r 61                 System.out.println("COST: " +_);
--[ 2022.11.07.10.43.53.468.0 ]--
r 61                 System.out.println("COST: " +);
--[ 2022.11.07.10.43.53.624.0 ]--
r 61                 System.out.println("COST: " + );
--[ 2022.11.07.10.43.53.877.0 ]--
r 61                 System.out.println("COST: " + t);
--[ 2022.11.07.10.43.53.960.0 ]--
r 61                 System.out.println("COST: " + th);
--[ 2022.11.07.10.43.54.046.0 ]--
r 61                 System.out.println("COST: " + thi);
--[ 2022.11.07.10.43.54.091.0 ]--
r 61                 System.out.println("COST: " + this);
--[ 2022.11.07.10.43.54.325.0 ]--
r 61                 System.out.println("COST: " + this.);
--[ 2022.11.07.10.43.54.552.0 ]--
r 61                 System.out.println("COST: " + this.c);
--[ 2022.11.07.10.43.54.675.0 ]--
r 61                 System.out.println("COST: " + this.co);
--[ 2022.11.07.10.43.54.740.0 ]--
r 61                 System.out.println("COST: " + this.cos);
--[ 2022.11.07.10.43.54.853.0 ]--
r 61                 System.out.println("COST: " + this.cost);
--[ 2022.11.07.10.43.58.091.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.44.19.931.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.45.49.155.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.46.11.502.0 ]--
+ 216         
--[ 2022.11.07.10.46.13.402.0 ]--
r 216         f
--[ 2022.11.07.10.46.13.546.0 ]--
r 216         fo
--[ 2022.11.07.10.46.13.600.0 ]--
r 216         for
--[ 2022.11.07.10.46.13.743.0 ]--
r 216         for 
--[ 2022.11.07.10.46.13.987.0 ]--
r 216         for ()
--[ 2022.11.07.10.46.15.401.0 ]--
r 216         for (C)
--[ 2022.11.07.10.46.15.553.0 ]--
r 216         for (CO)
--[ 2022.11.07.10.46.15.888.0 ]--
r 216         for (COO)
--[ 2022.11.07.10.46.16.302.0 ]--
r 216         for (CO)
--[ 2022.11.07.10.46.16.418.0 ]--
r 216         for (C)
--[ 2022.11.07.10.46.16.547.0 ]--
r 216         for (Co)
--[ 2022.11.07.10.46.16.619.0 ]--
r 216         for (Cor)
--[ 2022.11.07.10.46.16.784.0 ]--
r 216         for (Corr)
--[ 2022.11.07.10.46.17.032.0 ]--
r 216         for (Corrd)
--[ 2022.11.07.10.46.17.284.0 ]--
r 216         for (Corr)
--[ 2022.11.07.10.46.17.441.0 ]--
r 216         for (Cor)
--[ 2022.11.07.10.46.17.622.0 ]--
r 216         for (Co)
--[ 2022.11.07.10.46.17.729.0 ]--
r 216         for (Coo)
--[ 2022.11.07.10.46.17.838.0 ]--
r 216         for (Coor)
--[ 2022.11.07.10.46.17.923.0 ]--
r 216         for (Coord)
--[ 2022.11.07.10.46.19.276.0 ]--
r 216         for (Coord )
--[ 2022.11.07.10.46.19.380.0 ]--
r 216         for (Coord c)
--[ 2022.11.07.10.46.19.508.0 ]--
r 216         for (Coord c )
--[ 2022.11.07.10.46.19.737.0 ]--
r 216         for (Coord c :)
--[ 2022.11.07.10.46.19.914.0 ]--
r 216         for (Coord c : )
--[ 2022.11.07.10.46.22.191.0 ]--
r 216         for (Coord c : p)
--[ 2022.11.07.10.46.22.272.0 ]--
r 216         for (Coord c : pa)
--[ 2022.11.07.10.46.22.384.0 ]--
r 216         for (Coord c : pat)
--[ 2022.11.07.10.46.22.475.0 ]--
r 216         for (Coord c : path)
--[ 2022.11.07.10.46.24.551.0 ]--
r 216         for (Coord c : path) 
--[ 2022.11.07.10.46.24.925.0 ]--
r 216         for (Coord c : path) {
--[ 2022.11.07.10.46.25.112.0 ]--
+ 217 
+ 218 }
--[ 2022.11.07.10.46.25.121.0 ]--
r 218         }
--[ 2022.11.07.10.46.25.133.0 ]--
r 217             
--[ 2022.11.07.10.46.25.750.0 ]--
r 217             s
--[ 2022.11.07.10.46.25.883.0 ]--
r 217             so
--[ 2022.11.07.10.46.25.924.0 ]--
r 217             sot
--[ 2022.11.07.10.46.25.971.0 ]--
r 217             sotu
--[ 2022.11.07.10.46.26.176.0 ]--
+ 218             
--[ 2022.11.07.10.46.26.192.0 ]--
r 218                     
--[ 2022.11.07.10.46.26.755.0 ]--
- 218
--[ 2022.11.07.10.46.26.892.0 ]--
r 217             sot
--[ 2022.11.07.10.46.27.055.0 ]--
r 217             so
--[ 2022.11.07.10.46.27.552.0 ]--
r 217             soo
--[ 2022.11.07.10.46.27.646.0 ]--
r 217             soou
--[ 2022.11.07.10.46.27.747.0 ]--
r 217             soout
--[ 2022.11.07.10.46.27.845.0 ]--
+ 218             
--[ 2022.11.07.10.46.27.860.0 ]--
r 218                     
--[ 2022.11.07.10.46.28.299.0 ]--
- 218
--[ 2022.11.07.10.46.28.450.0 ]--
r 217             soou
--[ 2022.11.07.10.46.28.615.0 ]--
r 217             soo
--[ 2022.11.07.10.46.28.777.0 ]--
r 217             so
--[ 2022.11.07.10.46.28.931.0 ]--
r 217             s
--[ 2022.11.07.10.46.29.005.0 ]--
r 217             su
--[ 2022.11.07.10.46.29.094.0 ]--
r 217             sut
--[ 2022.11.07.10.46.29.397.0 ]--
r 217             GSSUtil
--[ 2022.11.07.10.46.29.408.0 ]--
r 217             com.sun.security.jgss.GSSUtil
--[ 2022.11.07.10.46.29.421.0 ]--
r 1 import com.sun.security.jgss.GSSUtil;import java.lang.IndexOutOfBoundsException;
--[ 2022.11.07.10.46.29.426.0 ]--
r 217             GSSUtil
--[ 2022.11.07.10.46.29.436.0 ]--
+ 1 import com.sun.security.jgss.GSSUtil;
+ 2 
r 3 import java.lang.IndexOutOfBoundsException;
--[ 2022.11.07.10.46.30.059.0 ]--
r 219             GSSUti
--[ 2022.11.07.10.46.30.154.0 ]--
r 219             GSSUt
--[ 2022.11.07.10.46.30.320.0 ]--
r 219             GSSU
--[ 2022.11.07.10.46.30.478.0 ]--
r 219             GSS
--[ 2022.11.07.10.46.30.644.0 ]--
r 219             GS
--[ 2022.11.07.10.46.30.819.0 ]--
r 219             G
--[ 2022.11.07.10.46.30.975.0 ]--
r 219             
--[ 2022.11.07.10.46.31.088.0 ]--
r 219             s
--[ 2022.11.07.10.46.31.184.0 ]--
r 219             so
--[ 2022.11.07.10.46.31.289.0 ]--
r 219             sou
--[ 2022.11.07.10.46.31.377.0 ]--
r 219             sout
--[ 2022.11.07.10.46.31.525.0 ]--
r 219             System.out.println();
--[ 2022.11.07.10.46.32.583.0 ]--
r 219             System.out.println("");
--[ 2022.11.07.10.46.33.601.0 ]--
r 219             System.out.println();
--[ 2022.11.07.10.46.35.708.0 ]--
r 219             System.out.println(c);
--[ 2022.11.07.10.46.40.762.0 ]--
r 219             System.out.println();
--[ 2022.11.07.10.46.51.801.0 ]--
r 218         for (P) {
--[ 2022.11.07.10.46.52.144.0 ]--
r 218         for (PF) {
--[ 2022.11.07.10.46.52.610.0 ]--
r 218         for (PFNode) {
--[ 2022.11.07.10.46.54.245.0 ]--
r 218         for (PFNode ) {
--[ 2022.11.07.10.46.54.387.0 ]--
r 218         for (PFNode n) {
--[ 2022.11.07.10.46.54.572.0 ]--
r 218         for (PFNode n ) {
--[ 2022.11.07.10.46.54.806.0 ]--
r 218         for (PFNode n :) {
--[ 2022.11.07.10.46.55.711.0 ]--
r 218         for (PFNode n : ) {
--[ 2022.11.07.10.46.56.722.0 ]--
r 218         for (PFNode n : m) {
--[ 2022.11.07.10.46.56.856.0 ]--
r 218         for (PFNode n : mi) {
--[ 2022.11.07.10.46.56.925.0 ]--
r 218         for (PFNode n : min) {
--[ 2022.11.07.10.46.57.597.0 ]--
r 218         for (PFNode n : mi) {
--[ 2022.11.07.10.46.57.764.0 ]--
r 218         for (PFNode n : m) {
--[ 2022.11.07.10.46.57.917.0 ]--
r 218         for (PFNode n : ) {
--[ 2022.11.07.10.46.58.140.0 ]--
r 218         for (PFNode n : p) {
--[ 2022.11.07.10.46.58.645.0 ]--
r 218         for (PFNode n : pw) {
--[ 2022.11.07.10.46.59.147.0 ]--
r 218         for (PFNode n : p) {
--[ 2022.11.07.10.46.59.511.0 ]--
r 218         for (PFNode n : pq) {
--[ 2022.11.07.10.47.03.666.0 ]--
r 219             System.out.println(n);
--[ 2022.11.07.10.47.03.869.0 ]--
r 219             System.out.println(n.);
--[ 2022.11.07.10.47.04.483.0 ]--
r 219             System.out.println(n.c);
--[ 2022.11.07.10.47.04.528.0 ]--
r 219             System.out.println(n.co);
--[ 2022.11.07.10.47.04.931.0 ]--
r 219             System.out.println(n.cost);
--[ 2022.11.07.10.47.07.132.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.47.35.200.0 ]--
+ 214         
--[ 2022.11.07.10.47.35.990.0 ]--
r 214         /
--[ 2022.11.07.10.47.36.188.0 ]--
r 214         //
--[ 2022.11.07.10.47.36.560.0 ]--
r 214         // 
--[ 2022.11.07.10.47.36.697.0 ]--
r 214         // t
--[ 2022.11.07.10.47.36.760.0 ]--
r 214         // to
--[ 2022.11.07.10.47.36.929.0 ]--
r 214         // tot
--[ 2022.11.07.10.47.37.070.0 ]--
r 214         // tota
--[ 2022.11.07.10.47.37.158.0 ]--
r 214         // total
--[ 2022.11.07.10.47.37.345.0 ]--
r 214         // total 
--[ 2022.11.07.10.47.37.459.0 ]--
r 214         // total n
--[ 2022.11.07.10.47.37.567.0 ]--
r 214         // total no
--[ 2022.11.07.10.47.37.629.0 ]--
r 214         // total nod
--[ 2022.11.07.10.47.37.794.0 ]--
r 214         // total node
--[ 2022.11.07.10.47.38.222.0 ]--
r 214         // total nodes
--[ 2022.11.07.10.47.38.406.0 ]--
r 214         // total nodes 
--[ 2022.11.07.10.47.38.775.0 ]--
r 214         // total nodes c
--[ 2022.11.07.10.47.38.954.0 ]--
r 214         // total nodes cr
--[ 2022.11.07.10.47.39.043.0 ]--
r 214         // total nodes cre
--[ 2022.11.07.10.47.39.117.0 ]--
r 214         // total nodes crea
--[ 2022.11.07.10.47.39.227.0 ]--
r 214         // total nodes creat
--[ 2022.11.07.10.47.39.330.0 ]--
r 214         // total nodes create
--[ 2022.11.07.10.47.39.501.0 ]--
r 214         // total nodes created
--[ 2022.11.07.10.47.39.627.0 ]--
r 214         // total nodes created 
--[ 2022.11.07.10.47.40.519.0 ]--
r 214         // total nodes created d
--[ 2022.11.07.10.47.40.610.0 ]--
r 214         // total nodes created di
--[ 2022.11.07.10.47.40.724.0 ]--
r 214         // total nodes created div
--[ 2022.11.07.10.47.40.843.0 ]--
r 214         // total nodes created divi
--[ 2022.11.07.10.47.40.922.0 ]--
r 214         // total nodes created divid
--[ 2022.11.07.10.47.41.084.0 ]--
r 214         // total nodes created divide
--[ 2022.11.07.10.47.41.231.0 ]--
r 214         // total nodes created divided
--[ 2022.11.07.10.47.41.379.0 ]--
r 214         // total nodes created divided 
--[ 2022.11.07.10.47.41.777.0 ]--
r 214         // total nodes created divided b
--[ 2022.11.07.10.47.41.902.0 ]--
r 214         // total nodes created divided by
--[ 2022.11.07.10.47.42.016.0 ]--
r 214         // total nodes created divided by 
--[ 2022.11.07.10.47.42.562.0 ]--
r 214         // total nodes created divided by N
--[ 2022.11.07.10.47.44.554.0 ]--
r 214         // total nodes created divided by N^
--[ 2022.11.07.10.47.45.232.0 ]--
r 214         // total nodes created divided by N^N
--[ 2022.11.07.10.48.16.270.0 ]--
r 210         return endNode.gcost;
--[ 2022.11.07.10.48.16.396.0 ]--
r 210         return endNode.gecost;
--[ 2022.11.07.10.48.17.009.0 ]--
r 210         return endNode.getCostcost;
--[ 2022.11.07.10.48.17.015.0 ]--
r 210         return endNode.getCost()cost;
--[ 2022.11.07.10.48.19.468.0 ]--
r 210         return endNode.getCost()cos;
--[ 2022.11.07.10.48.19.643.0 ]--
r 210         return endNode.getCost()co;
--[ 2022.11.07.10.48.19.846.0 ]--
r 210         return endNode.getCost()c;
--[ 2022.11.07.10.48.20.101.0 ]--
r 210         return endNode.getCost();
--[ 2022.11.07.10.48.24.135.0 ]--
UpdateTree (AD): 0 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.24.136.0 ]--
CompilationStatus (AEW): 0 1 0
[Ljava.lang.String;@18c8f657
--[ 2022.11.07.10.48.28.202.0 ]--
r 210         return endNode.getCost(h);
--[ 2022.11.07.10.48.28.203.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.28.204.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.28.375.0 ]--
r 210         return endNode.getCost(hr);
--[ 2022.11.07.10.48.28.375.1 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.28.377.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.28.511.0 ]--
+ 210         return endNode.getCost(hr
r 211         );
--[ 2022.11.07.10.48.28.512.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.28.517.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.29.389.0 ]--
- 210
r 210         return endNode.getCost(hr);
--[ 2022.11.07.10.48.29.390.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.29.392.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.29.527.0 ]--
r 210         return endNode.getCost(h);
--[ 2022.11.07.10.48.29.528.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.29.529.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.29.982.0 ]--
r 210         return endNode.getCost(he);
--[ 2022.11.07.10.48.29.982.1 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.29.983.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.30.240.0 ]--
r 210         return endNode.getCost(heuristic);
--[ 2022.11.07.10.48.30.240.1 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.30.246.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.31.093.0 ]--
- 210
--[ 2022.11.07.10.48.31.093.1 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.31.095.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.31.096.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.33.935.0 ]--
+ 210         return endNode.getCost(heuristic);
--[ 2022.11.07.10.48.33.936.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.33.937.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.33.939.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder.class
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.36.870.0 ]--
UpdateTree (AD): 2 0
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2022.11.07.10.48.36.870.1 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.49.30.463.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.50.23.461.0 ]--
r 14     int N,;
--[ 2022.11.07.10.50.24.383.0 ]--
r 14     int N, ;
--[ 2022.11.07.10.50.24.486.0 ]--
r 14     int N, c;
--[ 2022.11.07.10.50.24.567.0 ]--
r 14     int N, co;
--[ 2022.11.07.10.50.24.642.0 ]--
r 14     int N, cou;
--[ 2022.11.07.10.50.24.847.0 ]--
r 14     int N, coun;
--[ 2022.11.07.10.50.24.929.0 ]--
r 14     int N, count;
--[ 2022.11.07.10.50.28.332.0 ]--
r 14     int N, Ncount;
--[ 2022.11.07.10.50.28.463.0 ]--
r 14     int N, Nocount;
--[ 2022.11.07.10.50.28.580.0 ]--
r 14     int N, Nodcount;
--[ 2022.11.07.10.50.28.691.0 ]--
r 14     int N, Nodecount;
--[ 2022.11.07.10.50.30.204.0 ]--
r 14     int N, Nodeount;
--[ 2022.11.07.10.50.30.406.0 ]--
r 14     int N, NodeCount;
--[ 2022.11.07.10.50.39.047.0 ]--
+ 139         
--[ 2022.11.07.10.50.39.646.0 ]--
r 139         c
--[ 2022.11.07.10.50.39.760.0 ]--
r 139         co
--[ 2022.11.07.10.50.39.823.0 ]--
r 139         cou
--[ 2022.11.07.10.50.39.922.0 ]--
r 139         cout
--[ 2022.11.07.10.50.40.043.0 ]--
r 139         coutn
--[ 2022.11.07.10.50.40.658.0 ]--
r 139         cout
--[ 2022.11.07.10.50.40.805.0 ]--
r 139         cou
--[ 2022.11.07.10.50.40.900.0 ]--
r 139         coun
--[ 2022.11.07.10.50.40.961.0 ]--
r 139         count
--[ 2022.11.07.10.50.41.474.0 ]--
r 139         coun
--[ 2022.11.07.10.50.41.611.0 ]--
r 139         cou
--[ 2022.11.07.10.50.41.771.0 ]--
r 139         co
--[ 2022.11.07.10.50.41.933.0 ]--
r 139         c
--[ 2022.11.07.10.50.42.080.0 ]--
r 139         
--[ 2022.11.07.10.50.42.173.0 ]--
r 139         n
--[ 2022.11.07.10.50.42.265.0 ]--
r 139         no
--[ 2022.11.07.10.50.42.309.0 ]--
r 139         nod
--[ 2022.11.07.10.50.42.441.0 ]--
r 139         node
--[ 2022.11.07.10.50.42.874.0 ]--
r 139         endNode
--[ 2022.11.07.10.50.43.320.0 ]--
r 139         endNod
--[ 2022.11.07.10.50.43.483.0 ]--
r 139         endNo
--[ 2022.11.07.10.50.43.650.0 ]--
r 139         endN
--[ 2022.11.07.10.50.43.812.0 ]--
r 139         end
--[ 2022.11.07.10.50.43.984.0 ]--
r 139         en
--[ 2022.11.07.10.50.44.149.0 ]--
r 139         e
--[ 2022.11.07.10.50.44.374.0 ]--
r 139         
--[ 2022.11.07.10.50.45.029.0 ]--
r 139         N
--[ 2022.11.07.10.50.45.504.0 ]--
r 139         
--[ 2022.11.07.10.50.45.900.0 ]--
r 139         N
--[ 2022.11.07.10.50.46.014.0 ]--
r 139         NO
--[ 2022.11.07.10.50.46.149.0 ]--
r 139         NOd
--[ 2022.11.07.10.50.46.405.0 ]--
r 139         NOde
--[ 2022.11.07.10.50.46.565.0 ]--
r 139         NodeCount
--[ 2022.11.07.10.50.47.879.0 ]--
r 139         NodeCount+
--[ 2022.11.07.10.50.48.009.0 ]--
r 139         NodeCount++
--[ 2022.11.07.10.50.48.282.0 ]--
r 139         NodeCount++;
--[ 2022.11.07.10.51.03.493.0 ]--
+ 174                 
--[ 2022.11.07.10.51.04.333.0 ]--
r 174                 c
--[ 2022.11.07.10.51.04.414.0 ]--
r 174                 co
--[ 2022.11.07.10.51.04.489.0 ]--
r 174                 cou
--[ 2022.11.07.10.51.05.225.0 ]--
r 174                 co
--[ 2022.11.07.10.51.05.362.0 ]--
r 174                 c
--[ 2022.11.07.10.51.05.513.0 ]--
r 174                 
--[ 2022.11.07.10.51.05.683.0 ]--
r 174                 N
--[ 2022.11.07.10.51.05.772.0 ]--
r 174                 NO
--[ 2022.11.07.10.51.05.912.0 ]--
r 174                 NOd
--[ 2022.11.07.10.51.06.050.0 ]--
r 174                 NOde
--[ 2022.11.07.10.51.06.680.0 ]--
r 174                 NodeCount
--[ 2022.11.07.10.51.07.350.0 ]--
r 174                 NodeCount+
--[ 2022.11.07.10.51.07.482.0 ]--
r 174                 NodeCount++
--[ 2022.11.07.10.51.07.774.0 ]--
r 174                 NodeCount++;
--[ 2022.11.07.10.51.10.387.0 ]--
+ 184                 
--[ 2022.11.07.10.51.10.875.0 ]--
r 184                 N
--[ 2022.11.07.10.51.10.965.0 ]--
r 184                 No
--[ 2022.11.07.10.51.11.040.0 ]--
r 184                 Nod
--[ 2022.11.07.10.51.11.192.0 ]--
r 184                 Node
--[ 2022.11.07.10.51.12.493.0 ]--
r 184                 NodeC
--[ 2022.11.07.10.51.12.905.0 ]--
r 184                 NodeCount
--[ 2022.11.07.10.51.13.523.0 ]--
r 184                 NodeCount+
--[ 2022.11.07.10.51.13.829.0 ]--
r 184                 NodeCount++
--[ 2022.11.07.10.51.14.292.0 ]--
r 184                 NodeCount++;
--[ 2022.11.07.10.51.16.458.0 ]--
+ 194                 
--[ 2022.11.07.10.51.16.839.0 ]--
r 194                 N
--[ 2022.11.07.10.51.17.009.0 ]--
r 194                 No
--[ 2022.11.07.10.51.17.062.0 ]--
r 194                 Nod
--[ 2022.11.07.10.51.17.196.0 ]--
r 194                 Node
--[ 2022.11.07.10.51.17.446.0 ]--
r 194                 org.w3c.dom.Node
--[ 2022.11.07.10.51.17.459.0 ]--
r 1 import com.sun.security.jgss.GSSUtil;import org.w3c.dom.Node;
--[ 2022.11.07.10.51.17.468.0 ]--
r 194                 Node
--[ 2022.11.07.10.51.17.479.0 ]--
+ 1 import com.sun.security.jgss.GSSUtil;
r 2 import org.w3c.dom.Node;
--[ 2022.11.07.10.51.18.315.0 ]--
r 195                 NodeC
--[ 2022.11.07.10.51.18.532.0 ]--
r 195                 NodeCount
--[ 2022.11.07.10.51.19.360.0 ]--
r 195                 NodeCount+
--[ 2022.11.07.10.51.19.520.0 ]--
r 195                 NodeCount++
--[ 2022.11.07.10.51.19.794.0 ]--
r 195                 NodeCount++;
--[ 2022.11.07.10.51.21.510.0 ]--
+ 206                 
--[ 2022.11.07.10.51.21.933.0 ]--
r 206                 N
--[ 2022.11.07.10.51.22.131.0 ]--
r 206                 Nd
--[ 2022.11.07.10.51.22.542.0 ]--
r 206                 N
--[ 2022.11.07.10.51.22.955.0 ]--
r 206                 Nn
--[ 2022.11.07.10.51.23.015.0 ]--
r 206                 Nno
--[ 2022.11.07.10.51.23.144.0 ]--
r 206                 Nnod
--[ 2022.11.07.10.51.23.747.0 ]--
r 206                 Nno
--[ 2022.11.07.10.51.23.899.0 ]--
r 206                 Nn
--[ 2022.11.07.10.51.24.055.0 ]--
r 206                 N
--[ 2022.11.07.10.51.24.110.0 ]--
r 206                 No
--[ 2022.11.07.10.51.24.160.0 ]--
r 206                 Nod
--[ 2022.11.07.10.51.24.333.0 ]--
r 206                 Node
--[ 2022.11.07.10.51.24.549.0 ]--
r 206                 NodeC
--[ 2022.11.07.10.51.24.824.0 ]--
r 206                 NodeCount
--[ 2022.11.07.10.51.25.883.0 ]--
r 206                 NodeCount+
--[ 2022.11.07.10.51.25.994.0 ]--
r 206                 NodeCount++
--[ 2022.11.07.10.51.26.659.0 ]--
r 206                 NodeCount++;
--[ 2022.11.07.10.51.32.868.0 ]--
r 221         return N;
--[ 2022.11.07.10.51.32.954.0 ]--
r 221         return No;
--[ 2022.11.07.10.51.33.216.0 ]--
r 221         return Noe;
--[ 2022.11.07.10.51.33.583.0 ]--
r 221         return No;
--[ 2022.11.07.10.51.33.645.0 ]--
r 221         return Nod;
--[ 2022.11.07.10.51.33.770.0 ]--
r 221         return Node;
--[ 2022.11.07.10.51.34.019.0 ]--
r 221         return NodeC;
--[ 2022.11.07.10.51.34.343.0 ]--
r 221         return NodeCount;
--[ 2022.11.07.10.51.34.866.0 ]--
r 221         return NodeCount ;
--[ 2022.11.07.10.51.35.067.0 ]--
r 221         return NodeCount /;
--[ 2022.11.07.10.51.35.283.0 ]--
r 221         return NodeCount / ;
--[ 2022.11.07.10.51.38.087.0 ]--
r 221         return NodeCount / ();
--[ 2022.11.07.10.51.38.480.0 ]--
r 221         return NodeCount / (N);
--[ 2022.11.07.10.51.39.649.0 ]--
r 221         return NodeCount / (N*);
--[ 2022.11.07.10.51.40.241.0 ]--
r 221         return NodeCount / (N*N);
--[ 2022.11.07.10.51.47.436.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.53.20.171.0 ]--
r 220         // total nodes created divided by NN
--[ 2022.11.07.10.53.21.168.0 ]--
r 220         // total nodes created divided by N*N
--[ 2022.11.07.10.53.52.922.0 ]--
r 156             
--[ 2022.11.07.10.53.53.317.0 ]--
- 156
--[ 2022.11.07.10.55.21.846.0 ]--
r 41             cost = ;
--[ 2022.11.07.10.55.21.946.0 ]--
r 41             cost = -;
--[ 2022.11.07.10.55.22.493.0 ]--
r 41             cost = -1;
--[ 2022.11.07.10.55.25.898.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.10.55.35.172.0 ]--
r 41             cost = -;
--[ 2022.11.07.10.55.35.413.0 ]--
r 41             cost = ;
--[ 2022.11.07.10.55.36.285.0 ]--
r 41             cost = 0;
--[ 2022.11.07.10.55.57.198.0 ]--
r 37        
--[ 2022.11.07.10.55.57.355.0 ]--
- 37
--[ 2022.11.07.10.57.21.898.0 ]--
+ 133         
--[ 2022.11.07.10.57.22.799.0 ]--
r 133         N
--[ 2022.11.07.10.57.22.889.0 ]--
r 133         No
--[ 2022.11.07.10.57.22.946.0 ]--
r 133         Nod
--[ 2022.11.07.10.57.23.123.0 ]--
r 133         Node
--[ 2022.11.07.10.57.23.353.0 ]--
r 133         NodeC
--[ 2022.11.07.10.57.23.913.0 ]--
r 133         NodeCount
--[ 2022.11.07.10.57.24.430.0 ]--
r 133         NodeCount 
--[ 2022.11.07.10.57.24.493.0 ]--
r 133         NodeCount =
--[ 2022.11.07.10.57.24.608.0 ]--
r 133         NodeCount = 
--[ 2022.11.07.10.57.25.136.0 ]--
r 133         NodeCount = 0
--[ 2022.11.07.10.57.26.030.0 ]--
r 133         NodeCount = 0;
--[ 2022.11.07.10.57.30.179.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.00.07.396.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.01.11.618.0 ]--
r 220         return NodeCount / (N*N;
--[ 2022.11.07.11.01.11.758.0 ]--
r 220         return NodeCount / (N*;
--[ 2022.11.07.11.01.11.923.0 ]--
r 220         return NodeCount / (N;
--[ 2022.11.07.11.01.12.117.0 ]--
r 220         return NodeCount / (;
--[ 2022.11.07.11.01.12.309.0 ]--
r 220         return NodeCount / ;
--[ 2022.11.07.11.01.12.523.0 ]--
r 220         return NodeCount /;
--[ 2022.11.07.11.01.12.737.0 ]--
r 220         return NodeCount ;
--[ 2022.11.07.11.01.13.205.0 ]--
r 220         return NodeCount;
--[ 2022.11.07.11.01.26.364.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.03.40.794.0 ]--
r 60                 this.cost = this.prevNode.g
--[ 2022.11.07.11.03.40.910.0 ]--
r 60                 this.cost = this.prevNode.ge
--[ 2022.11.07.11.03.40.995.0 ]--
r 60                 this.cost = this.prevNode.get
--[ 2022.11.07.11.03.41.649.0 ]--
r 60                 this.cost = this.prevNode.getCost
--[ 2022.11.07.11.03.41.660.0 ]--
r 60                 this.cost = this.prevNode.getCost()
--[ 2022.11.07.11.03.42.503.0 ]--
r 60                 this.cost = this.prevNode.getCost(0)
--[ 2022.11.07.11.03.48.334.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.03.58.254.0 ]--
r 63                 /System.out.println("COST: " + this.cost);
--[ 2022.11.07.11.03.58.366.0 ]--
r 63                 //System.out.println("COST: " + this.cost);
--[ 2022.11.07.11.04.00.392.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.04.44.907.0 ]--
+ 163                 
--[ 2022.11.07.11.04.46.040.0 ]--
r 163                 e
--[ 2022.11.07.11.04.46.127.0 ]--
r 163                 en
--[ 2022.11.07.11.04.46.208.0 ]--
r 163                 end
--[ 2022.11.07.11.04.46.637.0 ]--
r 163                 en
--[ 2022.11.07.11.04.46.766.0 ]--
r 163                 e
--[ 2022.11.07.11.04.46.933.0 ]--
r 163                 
--[ 2022.11.07.11.04.47.050.0 ]--
r 163                 s
--[ 2022.11.07.11.04.47.117.0 ]--
r 163                 so
--[ 2022.11.07.11.04.47.244.0 ]--
r 163                 sou
--[ 2022.11.07.11.04.47.366.0 ]--
r 163                 sout
--[ 2022.11.07.11.04.47.458.0 ]--
r 163                 System.out.println();
--[ 2022.11.07.11.04.48.391.0 ]--
r 163                 System.out.println(C);
--[ 2022.11.07.11.04.48.853.0 ]--
r 163                 System.out.println();
--[ 2022.11.07.11.04.49.114.0 ]--
r 163                 System.out.println("");
--[ 2022.11.07.11.04.49.769.0 ]--
r 163                 System.out.println("e");
--[ 2022.11.07.11.04.49.847.0 ]--
r 163                 System.out.println("en");
--[ 2022.11.07.11.04.49.927.0 ]--
r 163                 System.out.println("end");
--[ 2022.11.07.11.04.50.130.0 ]--
r 163                 System.out.println("endn");
--[ 2022.11.07.11.04.50.239.0 ]--
r 163                 System.out.println("endno");
--[ 2022.11.07.11.04.50.322.0 ]--
r 163                 System.out.println("endnod");
--[ 2022.11.07.11.04.50.477.0 ]--
r 163                 System.out.println("endnode");
--[ 2022.11.07.11.04.51.290.0 ]--
r 163                 System.out.println("endnode ");
--[ 2022.11.07.11.04.51.766.0 ]--
r 163                 System.out.println("endnode c");
--[ 2022.11.07.11.04.51.911.0 ]--
r 163                 System.out.println("endnode co");
--[ 2022.11.07.11.04.51.998.0 ]--
r 163                 System.out.println("endnode cos");
--[ 2022.11.07.11.04.52.180.0 ]--
r 163                 System.out.println("endnode cost");
--[ 2022.11.07.11.04.52.755.0 ]--
r 163                 System.out.println("endnode cost" );
--[ 2022.11.07.11.04.53.067.0 ]--
r 163                 System.out.println("endnode cost" +);
--[ 2022.11.07.11.04.53.204.0 ]--
r 163                 System.out.println("endnode cost" + );
--[ 2022.11.07.11.04.53.831.0 ]--
r 163                 System.out.println("endnode cost" + g);
--[ 2022.11.07.11.04.54.041.0 ]--
r 163                 System.out.println("endnode cost" + ge);
--[ 2022.11.07.11.04.54.380.0 ]--
r 163                 System.out.println("endnode cost" + g);
--[ 2022.11.07.11.04.54.514.0 ]--
r 163                 System.out.println("endnode cost" + );
--[ 2022.11.07.11.04.54.886.0 ]--
r 163                 System.out.println("endnode cost" + e);
--[ 2022.11.07.11.04.54.986.0 ]--
r 163                 System.out.println("endnode cost" + en);
--[ 2022.11.07.11.04.55.080.0 ]--
r 163                 System.out.println("endnode cost" + end);
--[ 2022.11.07.11.04.55.284.0 ]--
r 163                 System.out.println("endnode cost" + endn);
--[ 2022.11.07.11.04.55.859.0 ]--
r 163                 System.out.println("endnode cost" + endn'');
--[ 2022.11.07.11.04.56.569.0 ]--
r 163                 System.out.println("endnode cost" + endn);
--[ 2022.11.07.11.04.57.173.0 ]--
r 163                 System.out.println("endnode cost" + endno);
--[ 2022.11.07.11.04.57.589.0 ]--
r 163                 System.out.println("endnode cost" + endNode);
--[ 2022.11.07.11.04.57.851.0 ]--
r 163                 System.out.println("endnode cost" + endNode.);
--[ 2022.11.07.11.04.58.261.0 ]--
r 163                 System.out.println("endnode cost" + endNode.g);
--[ 2022.11.07.11.04.58.355.0 ]--
r 163                 System.out.println("endnode cost" + endNode.ge);
--[ 2022.11.07.11.04.58.468.0 ]--
r 163                 System.out.println("endnode cost" + endNode.get);
--[ 2022.11.07.11.04.58.624.0 ]--
r 163                 System.out.println("endnode cost" + endNode.getCost);
--[ 2022.11.07.11.04.58.632.0 ]--
r 163                 System.out.println("endnode cost" + endNode.getCost());
--[ 2022.11.07.11.04.59.269.0 ]--
r 163                 System.out.println("endnode cost" + endNode.getCost(h));
--[ 2022.11.07.11.04.59.382.0 ]--
r 163                 System.out.println("endnode cost" + endNode.getCost(he));
--[ 2022.11.07.11.04.59.752.0 ]--
r 163                 System.out.println("endnode cost" + endNode.getCost(heuristic));
--[ 2022.11.07.11.05.02.699.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.05.18.066.0 ]--
- 225
- 225
r 225         
--[ 2022.11.07.11.05.18.965.0 ]--
- 225
--[ 2022.11.07.11.05.24.073.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.06.12.204.0 ]--
r 163                 System.out.println("endnode cost" + endNode..getCost(heuristic));
--[ 2022.11.07.11.06.12.436.0 ]--
r 163                 System.out.println("endnode cost" + endNode.p.getCost(heuristic));
--[ 2022.11.07.11.06.12.523.0 ]--
r 163                 System.out.println("endnode cost" + endNode.pr.getCost(heuristic));
--[ 2022.11.07.11.06.12.575.0 ]--
r 163                 System.out.println("endnode cost" + endNode.pre.getCost(heuristic));
--[ 2022.11.07.11.06.13.219.0 ]--
r 163                 System.out.println("endnode cost" + endNode.prevNode.getCost(heuristic));
--[ 2022.11.07.11.06.18.686.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.07.13.079.0 ]--
r 40             cost = ;
--[ 2022.11.07.11.07.13.741.0 ]--
r 40             cost = n;
--[ 2022.11.07.11.07.13.941.0 ]--
r 40             cost = nu;
--[ 2022.11.07.11.07.14.328.0 ]--
r 40             cost = nul;
--[ 2022.11.07.11.07.14.463.0 ]--
r 40             cost = null;
--[ 2022.11.07.11.07.15.856.0 ]--
r 40             cost = nul;
--[ 2022.11.07.11.07.16.015.0 ]--
r 40             cost = nu;
--[ 2022.11.07.11.07.16.234.0 ]--
r 40             cost = n;
--[ 2022.11.07.11.07.16.426.0 ]--
r 40             cost = ;
--[ 2022.11.07.11.07.18.446.0 ]--
r 40             cost = -;
--[ 2022.11.07.11.07.18.880.0 ]--
r 40             cost = -1`;
--[ 2022.11.07.11.07.19.967.0 ]--
r 40             cost = -1;
--[ 2022.11.07.11.07.27.985.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.07.45.858.0 ]--
r 163                 System.out.println("endnode cost" + n.prevNode.getCost(heuristic));
--[ 2022.11.07.11.07.45.962.0 ]--
r 163                 System.out.println("endnode cost" + ne.prevNode.getCost(heuristic));
--[ 2022.11.07.11.07.46.523.0 ]--
r 163                 System.out.println("endnode cost" + nextTile.prevNode.getCost(heuristic));
--[ 2022.11.07.11.07.51.777.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.08.34.084.0 ]--
r 163                 System.out.println("endnode cost" + nextTile..getCost(heuristic));
--[ 2022.11.07.11.08.34.529.0 ]--
r 163                 System.out.println("endnode cost" + nextTile.getCost(heuristic));
--[ 2022.11.07.11.08.36.697.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.08.46.201.0 ]--
r 60                 this.cost = this.prevNode.c
--[ 2022.11.07.11.08.46.405.0 ]--
r 60                 this.cost = this.prevNode.co
--[ 2022.11.07.11.08.46.574.0 ]--
r 60                 this.cost = this.prevNode.cos
--[ 2022.11.07.11.08.46.917.0 ]--
r 60                 this.cost = this.prevNode.cost
--[ 2022.11.07.11.08.49.834.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.09.28.701.0 ]--
- 157
- 157
- 157
r 157                 
--[ 2022.11.07.11.09.29.807.0 ]--
- 157
--[ 2022.11.07.11.09.34.784.0 ]--
+ 160                 
--[ 2022.11.07.11.09.36.474.0 ]--
+ 160                 for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
+ 161                     //System.out.println(nextTile.currentTile);
+ 162                     path.push(nextTile.currentTile);
r 163                 }
--[ 2022.11.07.11.09.40.209.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.11.34.45.548.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.12.52.37.451.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.12.52.37.552.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.07.12.52.37.706.0 ]--
r 46     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2022.11.07.12.52.40.377.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.12.53.38.932.0 ]--
:/src/Pathfinder.java
r 159                 
--[ 2022.11.07.12.53.39.092.0 ]--
- 159
--[ 2022.11.07.12.54.52.799.0 ]--
r 154             
--[ 2022.11.07.12.54.53.030.0 ]--
- 154
--[ 2022.11.07.12.54.57.397.0 ]--
r 159                     
--[ 2022.11.07.12.54.57.699.0 ]--
- 159
--[ 2022.11.07.12.55.02.880.0 ]--
r 177                 
--[ 2022.11.07.12.55.03.035.0 ]--
- 177
--[ 2022.11.07.12.55.07.450.0 ]--
r 186                 
--[ 2022.11.07.12.55.07.951.0 ]--
- 186
--[ 2022.11.07.12.55.12.739.0 ]--
r 193             
--[ 2022.11.07.12.55.13.222.0 ]--
- 193
--[ 2022.11.07.12.55.17.759.0 ]--
r 195                 
--[ 2022.11.07.12.55.17.915.0 ]--
- 195
--[ 2022.11.07.12.55.22.699.0 ]--
r 213        
--[ 2022.11.07.12.55.22.888.0 ]--
- 213
--[ 2022.11.07.14.57.22.207.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.07.14.57.22.334.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.14.57.22.605.0 ]--
r 46     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2022.11.07.14.57.31.427.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.15.02.15.122.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.15.02.15.184.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.07.15.02.18.029.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.15.03.45.385.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.15.03.45.824.0 ]--
r 46     private final static String emapFilename = emaps[9];        // change index to load a different elevation map
--[ 2022.11.07.15.03.48.430.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.15.07.40.207.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.07.15.07.40.304.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.07.15.07.40.493.0 ]--
r 46     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2022.11.07.15.07.43.024.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.15.08.50.181.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.07.15.08.50.268.0 ]--
r 46     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2022.11.07.15.08.52.380.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.07.15.31.21.992.0 ]--
DisposeComponent
--[ 2022.11.07.15.31.23.613.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.07.15.31.23.616.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml

--[ 2022.11.07.15.31.23.616.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.07.15.31.23.616.2 ]--
InitFile: /.DS_Store
   Bud1            %                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E   %                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       DSDB                             `                                                     @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.11.07.15.31.23.617.0 ]--
InitFile: /src/Pathfinder.java
import com.sun.security.jgss.GSSUtil;
import org.w3c.dom.Node;

import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                //System.out.println("COST: " + this.cost);
                return this.cost;
            } else return 0;
        }

        // returns if this PFNode is still valid
        public boolean isValid() {
            if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(), t.getN()) )) {
                return true;
            }
            return false;
        }

        // invalidates the PFNode
        public void invalidate() {
        }

        // returns if the PFNode has been used
        public boolean isUsed() {
            return true;
        }

        // uses the PFNode
        public void use() {
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() {return start;
    }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.getCost(heuristic);
    }

    public int getSearchSize() {
        return NodeCount;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.11.07.15.31.23.617.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.07.15.31.23.617.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.07.15.31.23.617.3 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.07.15.31.23.617.4 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.07.15.31.23.617.5 ]--
InitFile: /.cos265


--[ 2022.11.07.15.31.23.617.6 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.07.15.31.23.617.7 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.11.08.09.34.14.548.0 ]--
UpdateTree (AD): 1 0
+ /P04_Pathfinding.zip

--[ 2022.11.08.09.34.14.549.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.09.50.24.964.0 ]--
UpdateTree (AD): 1 0
+ /images/pathfindingUSA1024.png

--[ 2022.11.08.09.50.24.964.1 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.09.50.42.008.0 ]--
DisposeComponent
--[ 2022.11.08.10.47.49.422.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.08.10.47.49.488.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/images/pathfindingUSA1024.png
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2022.11.08.10.47.49.489.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.08.10.47.49.489.1 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.11.08.10.47.49.490.0 ]--
InitFile: /src/Pathfinder.java
import com.sun.security.jgss.GSSUtil;
import org.w3c.dom.Node;

import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                //System.out.println("COST: " + this.cost);
                return this.cost;
            } else return 0;
        }

        // returns if this PFNode is still valid
        public boolean isValid() {
            if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(), t.getN()) )) {
                return true;
            }
            return false;
        }

        // invalidates the PFNode
        public void invalidate() {
        }

        // returns if the PFNode has been used
        public boolean isUsed() {
            return true;
        }

        // uses the PFNode
        public void use() {
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() {return start;
    }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.getCost(heuristic);
    }

    public int getSearchSize() {
        return NodeCount;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.11.08.10.47.49.490.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.08.10.47.49.490.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.08.10.47.49.490.3 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.08.10.47.49.510.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.08.10.47.49.511.0 ]--
InitFile: /.cos265


--[ 2022.11.08.10.47.49.511.1 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.08.10.47.49.511.2 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.11.08.10.48.08.061.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.10.49.13.128.0 ]--
:/src/Pathfinder.java
+ 138         
--[ 2022.11.08.10.49.15.102.0 ]--
r 138         /
--[ 2022.11.08.10.49.15.170.0 ]--
r 138         //
--[ 2022.11.08.10.49.15.599.0 ]--
r 138         //s
--[ 2022.11.08.10.49.15.730.0 ]--
r 138         //se
--[ 2022.11.08.10.49.15.861.0 ]--
r 138         //set
--[ 2022.11.08.10.49.16.156.0 ]--
r 138         //se
--[ 2022.11.08.10.49.16.317.0 ]--
r 138         //s
--[ 2022.11.08.10.49.16.490.0 ]--
r 138         //
--[ 2022.11.08.10.49.16.582.0 ]--
r 138         //s
--[ 2022.11.08.10.49.16.650.0 ]--
r 138         //se
--[ 2022.11.08.10.49.17.059.0 ]--
r 138         //s
--[ 2022.11.08.10.49.17.224.0 ]--
r 138         //
--[ 2022.11.08.10.49.17.279.0 ]--
r 138         // 
--[ 2022.11.08.10.49.17.409.0 ]--
r 138         // s
--[ 2022.11.08.10.49.17.523.0 ]--
r 138         // se
--[ 2022.11.08.10.49.17.638.0 ]--
r 138         // set
--[ 2022.11.08.10.49.17.751.0 ]--
r 138         // sets
--[ 2022.11.08.10.49.17.860.0 ]--
r 138         // sets 
--[ 2022.11.08.10.49.18.003.0 ]--
r 138         // sets s
--[ 2022.11.08.10.49.18.110.0 ]--
r 138         // sets st
--[ 2022.11.08.10.49.18.228.0 ]--
r 138         // sets sta
--[ 2022.11.08.10.49.18.366.0 ]--
r 138         // sets star
--[ 2022.11.08.10.49.18.578.0 ]--
r 138         // sets start
--[ 2022.11.08.10.49.18.654.0 ]--
r 138         // sets start 
--[ 2022.11.08.10.49.18.798.0 ]--
r 138         // sets start s
--[ 2022.11.08.10.49.19.356.0 ]--
r 138         // sets start 
--[ 2022.11.08.10.49.22.590.0 ]--
r 138         // sets start n
--[ 2022.11.08.10.49.22.693.0 ]--
r 138         // sets start no
--[ 2022.11.08.10.49.22.728.0 ]--
r 138         // sets start nod
--[ 2022.11.08.10.49.22.871.0 ]--
r 138         // sets start node
--[ 2022.11.08.10.49.22.982.0 ]--
r 138         // sets start node 
--[ 2022.11.08.10.49.23.063.0 ]--
r 138         // sets start node a
--[ 2022.11.08.10.49.23.146.0 ]--
r 138         // sets start node an
--[ 2022.11.08.10.49.23.210.0 ]--
r 138         // sets start node and
--[ 2022.11.08.10.49.23.354.0 ]--
r 138         // sets start node and 
--[ 2022.11.08.10.49.23.634.0 ]--
r 138         // sets start node and a
--[ 2022.11.08.10.49.23.786.0 ]--
r 138         // sets start node and ad
--[ 2022.11.08.10.49.23.931.0 ]--
r 138         // sets start node and add
--[ 2022.11.08.10.49.24.043.0 ]--
r 138         // sets start node and adds
--[ 2022.11.08.10.49.24.140.0 ]--
r 138         // sets start node and adds 
--[ 2022.11.08.10.49.24.224.0 ]--
r 138         // sets start node and adds t
--[ 2022.11.08.10.49.24.320.0 ]--
r 138         // sets start node and adds to
--[ 2022.11.08.10.49.24.413.0 ]--
r 138         // sets start node and adds to 
--[ 2022.11.08.10.49.24.799.0 ]--
r 138         // sets start node and adds to q
--[ 2022.11.08.10.49.24.897.0 ]--
r 138         // sets start node and adds to qu
--[ 2022.11.08.10.49.24.985.0 ]--
r 138         // sets start node and adds to quq
--[ 2022.11.08.10.49.25.081.0 ]--
r 138         // sets start node and adds to ququ
--[ 2022.11.08.10.49.25.221.0 ]--
r 138         // sets start node and adds to quque
--[ 2022.11.08.10.49.25.501.0 ]--
r 138         // sets start node and adds to ququ
--[ 2022.11.08.10.49.25.685.0 ]--
r 138         // sets start node and adds to quq
--[ 2022.11.08.10.49.25.949.0 ]--
r 138         // sets start node and adds to quqe
--[ 2022.11.08.10.49.26.064.0 ]--
r 138         // sets start node and adds to quqeu
--[ 2022.11.08.10.49.26.290.0 ]--
r 138         // sets start node and adds to quqe
--[ 2022.11.08.10.49.26.564.0 ]--
r 138         // sets start node and adds to quq
--[ 2022.11.08.10.49.26.784.0 ]--
r 138         // sets start node and adds to qu
--[ 2022.11.08.10.49.26.956.0 ]--
r 138         // sets start node and adds to que
--[ 2022.11.08.10.49.27.075.0 ]--
r 138         // sets start node and adds to queu
--[ 2022.11.08.10.49.27.123.0 ]--
r 138         // sets start node and adds to queue
--[ 2022.11.08.10.49.48.555.0 ]--
- 110
r 110     public Coord getPathStart() {return start;}
--[ 2022.11.08.10.49.49.283.0 ]--
r 110     public Coord getPathStart() {return start; }
--[ 2022.11.08.10.49.51.708.0 ]--
r 110     public Coord getPathStart() { return start; }
--[ 2022.11.08.10.50.39.772.0 ]--
- 77
- 77
- 77
- 77
- 77
- 77
- 77
- 77
- 77
- 77
r 77        
--[ 2022.11.08.10.50.46.307.0 ]--
- 75
- 75
- 75
- 76
- 76
- 76
- 76
- 76
r 76         
--[ 2022.11.08.10.50.46.946.0 ]--
- 75
--[ 2022.11.08.10.50.47.496.0 ]--
- 75
--[ 2022.11.08.10.51.12.930.0 ]--
- 1
- 1
- 2
--[ 2022.11.08.10.53.27.673.0 ]--
r 186         return endNode.c;
--[ 2022.11.08.10.53.27.794.0 ]--
r 186         return endNode.co;
--[ 2022.11.08.10.53.27.897.0 ]--
r 186         return endNode.cos;
--[ 2022.11.08.10.53.28.158.0 ]--
r 186         return endNode.cost;
--[ 2022.11.08.10.53.35.574.0 ]--
- 189
r 189     public int getSearchSize() {return NodeCount;
--[ 2022.11.08.10.53.36.803.0 ]--
r 189     public int getSearchSize() { return NodeCount;
--[ 2022.11.08.10.53.38.565.0 ]--
- 189
r 189     public int getSearchSize() { return NodeCount;}
--[ 2022.11.08.10.53.39.071.0 ]--
r 189     public int getSearchSize() { return NodeCount; }
--[ 2022.11.08.10.54.17.674.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.08.10.54.17.970.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.08.10.54.19.116.0 ]--
r 46     private final static String emapFilename = emaps[8];        // change index to load a different elevation map
--[ 2022.11.08.10.54.21.316.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.10.54.41.234.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.10.55.36.069.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.08.10.55.36.621.0 ]--
r 46     private final static String emapFilename = emaps[7];        // change index to load a different elevation map
--[ 2022.11.08.10.55.38.534.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.10.56.03.404.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.08.10.56.03.957.0 ]--
r 46     private final static String emapFilename = emaps[5];        // change index to load a different elevation map
--[ 2022.11.08.10.56.05.916.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.11.01.31.673.0 ]--
DisposeComponent
--[ 2022.11.08.11.22.17.077.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.08.11.22.17.108.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/images/pathfindingUSA1024.png
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2022.11.08.11.22.17.108.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.08.11.22.17.108.2 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.11.08.11.22.17.109.0 ]--
InitFile: /src/Pathfinder.java

import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                //System.out.println("COST: " + this.cost);
                return this.cost;
            } else return 0;
        }

        // returns if this PFNode is still valid
        public boolean isValid() {
            if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(), t.getN()) )) {
                return true;
            }
            return false;
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() { return start; }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        // sets start node and adds to queue
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.cost;
    }

    public int getSearchSize() { return NodeCount; }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.11.08.11.22.17.109.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.08.11.22.17.110.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[5];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.08.11.22.17.110.1 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.08.11.22.17.110.2 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.08.11.22.17.110.3 ]--
InitFile: /.cos265


--[ 2022.11.08.11.22.17.110.4 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.08.11.22.17.110.5 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.11.08.11.23.00.086.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2022.11.08.11.23.00.567.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2022.11.08.11.23.00.719.0 ]--
r 46     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2022.11.08.11.23.05.204.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.11.28.57.830.0 ]--
DisposeComponent
--[ 2022.11.08.12.09.03.118.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.08.12.09.03.141.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/images/pathfindingUSA1024.png
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2022.11.08.12.09.03.141.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.08.12.09.03.141.2 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.11.08.12.09.03.141.3 ]--
InitFile: /src/Pathfinder.java

import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                //System.out.println("COST: " + this.cost);
                return this.cost;
            } else return 0;
        }

        // returns if this PFNode is still valid
        public boolean isValid() {
            if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(), t.getN()) )) {
                return true;
            }
            return false;
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() { return start; }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        // sets start node and adds to queue
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.cost;
    }

    public int getSearchSize() { return NodeCount; }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.11.08.12.09.03.142.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.08.12.09.03.142.1 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.08.12.09.03.142.2 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.08.12.09.03.142.3 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.08.12.09.03.143.0 ]--
InitFile: /.cos265


--[ 2022.11.08.12.09.03.143.1 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.08.12.09.03.143.2 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.11.08.12.09.11.300.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.12.24.17.660.0 ]--
:/src/Walker.java
r 37             byTime = this.terrain.computeTravelCost(this.location, next);
--[ 2022.11.08.12.24.17.949.0 ]--
r 37             byTime += this.terrain.computeTravelCost(this.location, next);
--[ 2022.11.08.12.24.20.597.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.12.24.33.179.0 ]--
r 37             byTime = this.terrain.computeTravelCost(this.location, next);
--[ 2022.11.08.12.24.33.545.0 ]--
r 37             byTime _= this.terrain.computeTravelCost(this.location, next);
--[ 2022.11.08.12.24.34.614.0 ]--
r 37             byTime = this.terrain.computeTravelCost(this.location, next);
--[ 2022.11.08.12.24.34.864.0 ]--
r 37             byTime -= this.terrain.computeTravelCost(this.location, next);
--[ 2022.11.08.12.24.40.604.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.12.29.19.367.0 ]--
DisposeComponent
--[ 2022.11.08.12.35.56.131.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.08.12.35.56.181.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/images/pathfindingUSA1024.png
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2022.11.08.12.35.56.182.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.08.12.35.56.182.1 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.11.08.12.35.56.183.0 ]--
InitFile: /src/Pathfinder.java

import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                //System.out.println("COST: " + this.cost);
                return this.cost;
            } else return 0;
        }

        // returns if this PFNode is still valid
        public boolean isValid() {
            if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(), t.getN()) )) {
                return true;
            }
            return false;
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() { return start; }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        // sets start node and adds to queue
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.cost;
    }

    public int getSearchSize() { return NodeCount; }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.11.08.12.35.56.184.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.08.12.35.56.184.1 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.08.12.35.56.184.2 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.08.12.35.56.184.3 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.08.12.35.56.184.4 ]--
InitFile: /.cos265


--[ 2022.11.08.12.35.56.185.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.08.12.35.56.185.1 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.11.08.12.37.35.930.0 ]--
DisposeComponent
--[ 2022.11.08.14.10.01.359.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.08.14.10.01.378.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/images/pathfindingUSA1024.png
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2022.11.08.14.10.01.378.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.08.14.10.01.379.0 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.11.08.14.10.01.379.1 ]--
InitFile: /src/Pathfinder.java

import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                //System.out.println("COST: " + this.cost);
                return this.cost;
            } else return 0;
        }

        // returns if this PFNode is still valid
        public boolean isValid() {
            if(this.currentTile.isInBounds(new Coord(0,0),new Coord(t.getN(), t.getN()) )) {
                return true;
            }
            return false;
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() { return start; }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        // sets start node and adds to queue
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.cost;
    }

    public int getSearchSize() { return NodeCount; }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.11.08.14.10.01.379.2 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.08.14.10.01.379.3 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.08.14.10.01.380.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.08.14.10.01.380.1 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.08.14.10.01.380.2 ]--
InitFile: /.cos265


--[ 2022.11.08.14.10.01.380.3 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.08.14.10.01.381.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.11.08.14.10.33.208.0 ]--
:/src/Pathfinder.java
r 42             if (this.cost >= that.cost) {
--[ 2022.11.08.14.10.38.592.0 ]--
r 42             if (this.cost > that.cost) {
--[ 2022.11.08.14.10.54.275.0 ]--
r 60                
--[ 2022.11.08.14.10.54.651.0 ]--
- 60
--[ 2022.11.08.14.11.51.657.0 ]--
+ 60                 
--[ 2022.11.08.14.11.53.270.0 ]--
r 60                 s
--[ 2022.11.08.14.11.53.346.0 ]--
r 60                 so
--[ 2022.11.08.14.11.53.383.0 ]--
r 60                 sou
--[ 2022.11.08.14.11.53.495.0 ]--
r 60                 sout
--[ 2022.11.08.14.11.53.631.0 ]--
r 60                 System.out.println();
--[ 2022.11.08.14.11.54.556.0 ]--
r 60                 System.out.println("");
--[ 2022.11.08.14.11.55.681.0 ]--
r 60                 System.out.println("t");
--[ 2022.11.08.14.11.55.750.0 ]--
r 60                 System.out.println("th");
--[ 2022.11.08.14.11.55.839.0 ]--
r 60                 System.out.println("thi");
--[ 2022.11.08.14.11.55.903.0 ]--
r 60                 System.out.println("this");
--[ 2022.11.08.14.11.56.204.0 ]--
r 60                 System.out.println("this.");
--[ 2022.11.08.14.11.56.402.0 ]--
r 60                 System.out.println("this.c");
--[ 2022.11.08.14.11.56.514.0 ]--
r 60                 System.out.println("this.co");
--[ 2022.11.08.14.11.56.582.0 ]--
r 60                 System.out.println("this.cos");
--[ 2022.11.08.14.11.56.748.0 ]--
r 60                 System.out.println("this.cost");
--[ 2022.11.08.14.11.58.074.0 ]--
r 60                 System.out.println("this.cost:");
--[ 2022.11.08.14.11.58.258.0 ]--
r 60                 System.out.println("this.cost: ");
--[ 2022.11.08.14.11.59.412.0 ]--
r 60                 System.out.println("this.cost: " );
--[ 2022.11.08.14.11.59.549.0 ]--
r 60                 System.out.println("this.cost: " +);
--[ 2022.11.08.14.11.59.673.0 ]--
r 60                 System.out.println("this.cost: " + );
--[ 2022.11.08.14.12.00.320.0 ]--
r 60                 System.out.println("this.cost: " + t);
--[ 2022.11.08.14.12.00.356.0 ]--
r 60                 System.out.println("this.cost: " + th);
--[ 2022.11.08.14.12.00.541.0 ]--
r 60                 System.out.println("this.cost: " + this);
--[ 2022.11.08.14.12.00.697.0 ]--
r 60                 System.out.println("this.cost: " + this.);
--[ 2022.11.08.14.12.00.929.0 ]--
r 60                 System.out.println("this.cost: " + this.c);
--[ 2022.11.08.14.12.01.022.0 ]--
r 60                 System.out.println("this.cost: " + this.co);
--[ 2022.11.08.14.12.01.099.0 ]--
r 60                 System.out.println("this.cost: " + this.cos);
--[ 2022.11.08.14.12.01.241.0 ]--
r 60                 System.out.println("this.cost: " + this.cost);
--[ 2022.11.08.14.12.10.054.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.14.12.59.383.0 ]--
r 60                
--[ 2022.11.08.14.12.59.556.0 ]--
- 60
--[ 2022.11.08.14.13.47.501.0 ]--
r 61             } else return ;
--[ 2022.11.08.14.13.55.387.0 ]--
r 61             } else {return ;
--[ 2022.11.08.14.13.55.605.0 ]--
+ 61             } else {
+ 62 return ;
r 63 }
--[ 2022.11.08.14.13.55.619.0 ]--
r 62                 return ;
r 63             }
--[ 2022.11.08.14.13.59.651.0 ]--
+ 62                 
--[ 2022.11.08.14.14.00.019.0 ]--
r 62                 t
--[ 2022.11.08.14.14.00.111.0 ]--
r 62                 th
--[ 2022.11.08.14.14.00.161.0 ]--
r 62                 thi
--[ 2022.11.08.14.14.00.232.0 ]--
r 62                 this
--[ 2022.11.08.14.14.00.356.0 ]--
r 62                 this.
--[ 2022.11.08.14.14.00.539.0 ]--
r 62                 this.s
--[ 2022.11.08.14.14.00.931.0 ]--
r 62                 this.
--[ 2022.11.08.14.14.00.983.0 ]--
r 62                 this.c
--[ 2022.11.08.14.14.01.101.0 ]--
r 62                 this.co
--[ 2022.11.08.14.14.01.144.0 ]--
r 62                 this.cos
--[ 2022.11.08.14.14.01.261.0 ]--
r 62                 this.cost
--[ 2022.11.08.14.14.01.420.0 ]--
r 62                 this.cost 
--[ 2022.11.08.14.14.01.506.0 ]--
r 62                 this.cost =
--[ 2022.11.08.14.14.01.630.0 ]--
r 62                 this.cost = 
--[ 2022.11.08.14.14.02.144.0 ]--
+ 62                 this.cost = t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
r 63                         + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
--[ 2022.11.08.14.14.05.906.0 ]--
r 64                 return t;
--[ 2022.11.08.14.14.05.980.0 ]--
r 64                 return th;
--[ 2022.11.08.14.14.06.049.0 ]--
r 64                 return thi;
--[ 2022.11.08.14.14.06.135.0 ]--
r 64                 return this;
--[ 2022.11.08.14.14.06.358.0 ]--
r 64                 return this.;
--[ 2022.11.08.14.14.06.732.0 ]--
r 64                 return this.o;
--[ 2022.11.08.14.14.06.820.0 ]--
r 64                 return this.os;
--[ 2022.11.08.14.14.07.335.0 ]--
r 64                 return this.o;
--[ 2022.11.08.14.14.07.514.0 ]--
r 64                 return this.;
--[ 2022.11.08.14.14.07.626.0 ]--
r 64                 return this.c;
--[ 2022.11.08.14.14.07.800.0 ]--
r 64                 return this.co;
--[ 2022.11.08.14.14.07.836.0 ]--
r 64                 return this.cos;
--[ 2022.11.08.14.14.07.955.0 ]--
r 64                 return this.cost;
--[ 2022.11.08.14.14.11.737.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.14.14.43.013.0 ]--
- 62
r 62                 
--[ 2022.11.08.14.14.43.182.0 ]--
- 62
--[ 2022.11.08.14.14.45.792.0 ]--
r 62                 return tt;
--[ 2022.11.08.14.14.45.949.0 ]--
r 62                 return t;
--[ 2022.11.08.14.14.46.443.0 ]--
r 62                 return ;
--[ 2022.11.08.14.14.47.005.0 ]--
r 62                 return 0;
--[ 2022.11.08.14.14.53.040.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.14.16.31.170.0 ]--
r 53         public void getCost(float heuristic) {
--[ 2022.11.08.14.16.31.191.0 ]--
r 62                 return ;
--[ 2022.11.08.14.16.31.196.0 ]--
r 62                 
--[ 2022.11.08.14.16.31.202.0 ]--
- 62
r 62                 }
--[ 2022.11.08.14.16.31.205.0 ]--
r 60                 return ;
--[ 2022.11.08.14.16.31.209.0 ]--
r 60                 
--[ 2022.11.08.14.16.31.214.0 ]--
- 60
r 60                 } else {
--[ 2022.11.08.14.16.31.226.0 ]--
r 60             } else {
r 61             }
--[ 2022.11.08.14.16.34.119.0 ]--
r 53         public float getCost(float heuristic) {
+ 60                 return this.cost;
+ 62                 return 0;
--[ 2022.11.08.14.16.55.859.0 ]--
+ 60                 
--[ 2022.11.08.14.16.57.799.0 ]--
r 60                 s
--[ 2022.11.08.14.16.57.853.0 ]--
r 60                 so
--[ 2022.11.08.14.16.57.937.0 ]--
r 60                 sou
--[ 2022.11.08.14.16.58.043.0 ]--
r 60                 sout
--[ 2022.11.08.14.16.58.135.0 ]--
r 60                 System.out.println();
--[ 2022.11.08.14.16.58.978.0 ]--
r 60                 System.out.println("");
--[ 2022.11.08.14.16.59.378.0 ]--
r 60                 System.out.println("D");
--[ 2022.11.08.14.16.59.529.0 ]--
r 60                 System.out.println("Di");
--[ 2022.11.08.14.17.00.088.0 ]--
r 60                 System.out.println("Dik");
--[ 2022.11.08.14.17.00.404.0 ]--
r 60                 System.out.println("Diks");
--[ 2022.11.08.14.17.00.519.0 ]--
r 60                 System.out.println("Dikst");
--[ 2022.11.08.14.17.00.734.0 ]--
r 60                 System.out.println("Dikstr");
--[ 2022.11.08.14.17.01.013.0 ]--
r 60                 System.out.println("Dikstra");
--[ 2022.11.08.14.17.03.374.0 ]--
+ 63                 
--[ 2022.11.08.14.17.04.142.0 ]--
r 63                 s
--[ 2022.11.08.14.17.04.237.0 ]--
r 63                 so
--[ 2022.11.08.14.17.04.352.0 ]--
r 63                 sou
--[ 2022.11.08.14.17.04.407.0 ]--
r 63                 sout
--[ 2022.11.08.14.17.04.539.0 ]--
r 63                 System.out.println();
--[ 2022.11.08.14.17.05.162.0 ]--
r 63                 System.out.println("");
--[ 2022.11.08.14.17.06.960.0 ]--
r 63                 System.out.println("N");
--[ 2022.11.08.14.17.07.545.0 ]--
r 63                 System.out.println("");
--[ 2022.11.08.14.17.07.712.0 ]--
r 63                 System.out.println("E");
--[ 2022.11.08.14.17.07.825.0 ]--
r 63                 System.out.println("El");
--[ 2022.11.08.14.17.07.956.0 ]--
r 63                 System.out.println("Els");
--[ 2022.11.08.14.17.08.065.0 ]--
r 63                 System.out.println("Else");
--[ 2022.11.08.14.17.10.899.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.14.18.42.938.0 ]--
+ 120         
--[ 2022.11.08.14.18.44.857.0 ]--
r 120         s
--[ 2022.11.08.14.18.44.948.0 ]--
r 120         s.
--[ 2022.11.08.14.18.45.135.0 ]--
r 120         s.g
--[ 2022.11.08.14.18.45.256.0 ]--
r 120         s.ge
--[ 2022.11.08.14.18.45.404.0 ]--
r 120         s.get
--[ 2022.11.08.14.18.45.930.0 ]--
r 120         s.getCost
--[ 2022.11.08.14.18.45.945.0 ]--
r 120         s.getCost()
--[ 2022.11.08.14.18.47.425.0 ]--
r 120         s.getCost(h)
--[ 2022.11.08.14.18.47.498.0 ]--
r 120         s.getCost(he)
--[ 2022.11.08.14.18.47.856.0 ]--
r 120         s.getCost(heuristic)
--[ 2022.11.08.14.18.49.123.0 ]--
r 120         s.getCost(heuristic);
--[ 2022.11.08.14.18.51.761.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.08.14.19.08.686.0 ]--
r 120         
--[ 2022.11.08.14.19.09.143.0 ]--
- 120
--[ 2022.11.08.14.19.22.038.0 ]--
r 63                 
--[ 2022.11.08.14.19.22.248.0 ]--
- 63
--[ 2022.11.08.14.19.26.785.0 ]--
r 60                 
--[ 2022.11.08.14.19.26.952.0 ]--
- 60
--[ 2022.11.08.14.19.46.196.0 ]--
r 37             cost = -;
--[ 2022.11.08.14.19.46.335.0 ]--
r 37             cost = ;
--[ 2022.11.08.14.19.48.505.0 ]--
r 37             cost = N;
--[ 2022.11.08.14.19.48.690.0 ]--
r 37             cost = Na;
--[ 2022.11.08.14.19.48.865.0 ]--
r 37             cost = Nan;
--[ 2022.11.08.14.19.49.500.0 ]--
r 37             cost = Na;
--[ 2022.11.08.14.19.49.655.0 ]--
r 37             cost = NaN;
--[ 2022.11.08.14.19.50.651.0 ]--
r 37             cost = Na;
--[ 2022.11.08.14.19.50.863.0 ]--
r 37             cost = N;
--[ 2022.11.08.14.19.51.022.0 ]--
r 37             cost = ;
--[ 2022.11.08.14.19.52.226.0 ]--
r 37             cost = n;
--[ 2022.11.08.14.19.52.413.0 ]--
r 37             cost = nu;
--[ 2022.11.08.14.19.52.525.0 ]--
r 37             cost = nul;
--[ 2022.11.08.14.19.52.703.0 ]--
r 37             cost = null;
--[ 2022.11.08.14.19.54.009.0 ]--
r 37             cost = nul;
--[ 2022.11.08.14.19.54.171.0 ]--
r 37             cost = nu;
--[ 2022.11.08.14.19.54.343.0 ]--
r 37             cost = n;
--[ 2022.11.08.14.19.54.513.0 ]--
r 37             cost = ;
--[ 2022.11.08.14.19.56.131.0 ]--
r 37             cost = -;
--[ 2022.11.08.14.19.56.181.0 ]--
r 37             cost = -1;
--[ 2022.11.08.14.20.23.656.0 ]--
- 66
- 66
- 66
- 66
- 66
- 66
- 66
--[ 2022.11.08.14.20.24.403.0 ]--
- 65
--[ 2022.11.08.14.20.48.322.0 ]--
r 37             cost = -1.;
--[ 2022.11.08.14.20.48.393.0 ]--
r 37             cost = -1.0;
--[ 2022.11.08.14.20.49.362.0 ]--
r 37             cost = -1.;
--[ 2022.11.08.14.20.49.926.0 ]--
r 37             cost = -1;
--[ 2022.11.08.14.20.50.890.0 ]--
r 37             cost = -1f;
--[ 2022.11.08.14.20.52.085.0 ]--
r 37             cost = -1;
--[ 2022.11.08.14.30.38.072.0 ]--
DisposeComponent
--[ 2022.11.08.14.31.23.054.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.08.14.31.23.319.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/images/pathfindingUSA1024.png
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2022.11.08.14.31.23.320.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.08.14.31.23.320.1 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.11.08.14.31.23.323.0 ]--
InitFile: /src/Pathfinder.java

import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                return this.cost;
            } else {
                return 0;
            }
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() { return start; }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        // sets start node and adds to queue
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.cost;
    }

    public int getSearchSize() { return NodeCount; }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.11.08.14.31.23.323.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.08.14.31.23.323.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.08.14.31.23.324.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.08.14.31.23.324.1 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.08.14.31.23.324.2 ]--
InitFile: /.cos265


--[ 2022.11.08.14.31.23.324.3 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.08.14.31.23.324.4 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.11.08.14.47.48.290.0 ]--
DisposeComponent
--[ 2022.11.08.14.47.51.358.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.08.14.47.51.378.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/images/pathfindingUSA1024.png
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2022.11.08.14.47.51.379.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.08.14.47.51.379.1 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.11.08.14.47.51.380.0 ]--
InitFile: /src/Pathfinder.java

import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                return this.cost;
            } else {
                return 0;
            }
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() { return start; }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        // sets start node and adds to queue
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.cost;
    }

    public int getSearchSize() { return NodeCount; }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.11.08.14.47.51.380.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.08.14.47.51.380.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.08.14.47.51.380.3 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.08.14.47.51.381.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.08.14.47.51.381.1 ]--
InitFile: /.cos265


--[ 2022.11.08.14.47.51.381.2 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.08.14.47.51.381.3 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.11.08.14.49.21.403.0 ]--
:/src/Pathfinder.java
+ 48             
--[ 2022.11.08.14.49.22.659.0 ]--
r 48             t
--[ 2022.11.08.14.49.22.785.0 ]--
r 48             th
--[ 2022.11.08.14.49.22.962.0 ]--
r 48             thi
--[ 2022.11.08.14.49.23.571.0 ]--
r 48             th
--[ 2022.11.08.14.49.23.759.0 ]--
r 48             t
--[ 2022.11.08.14.49.24.040.0 ]--
r 48             
--[ 2022.11.08.14.49.37.351.0 ]--
- 48
--[ 2022.11.08.14.49.37.610.0 ]--
+ 48             
--[ 2022.11.08.14.49.49.766.0 ]--
+ 45             
--[ 2022.11.08.14.49.58.373.0 ]--
- 45
--[ 2022.11.08.14.50.01.161.0 ]--
- 48
--[ 2022.11.08.14.50.11.592.0 ]--
+ 125             
--[ 2022.11.08.14.50.25.916.0 ]--
- 125
--[ 2022.11.08.14.50.31.432.0 ]--
DisposeComponent
--[ 2022.11.09.09.08.26.959.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.09.09.08.27.005.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/images/pathfindingUSA1024.png
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2022.11.09.09.08.27.005.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.09.09.08.27.006.0 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.11.09.09.08.27.007.0 ]--
InitFile: /src/Pathfinder.java

import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                return this.cost;
            } else {
                return 0;
            }
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() { return start; }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        // sets start node and adds to queue
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.cost;
    }

    public int getSearchSize() { return NodeCount; }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.11.09.09.08.27.007.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.09.09.08.27.007.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.09.09.08.27.008.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.09.09.08.27.008.1 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.09.09.08.27.009.0 ]--
InitFile: /.cos265


--[ 2022.11.09.09.08.27.016.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.09.09.08.27.016.1 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.11.09.09.08.31.863.0 ]--
:/src/Pathfinder.java
r 112         array[getPathStart().getI()][getPathStart().getJ()] = true;]
--[ 2022.11.09.09.08.32.616.0 ]--
r 112         array[getPathStart().getI()][getPathStart().getJ()] = true;
--[ 2022.11.09.09.08.32.922.0 ]--
+ 113         
--[ 2022.11.09.09.08.33.219.0 ]--
r 113         s
--[ 2022.11.09.09.08.33.338.0 ]--
r 113         so
--[ 2022.11.09.09.08.33.395.0 ]--
r 113         sou
--[ 2022.11.09.09.08.33.542.0 ]--
r 113         sout
--[ 2022.11.09.09.08.34.599.0 ]--
r 113         System.out.println();
--[ 2022.11.09.09.08.35.297.0 ]--
r 113         System.out.println(H);
--[ 2022.11.09.09.08.35.777.0 ]--
r 113         System.out.println();
--[ 2022.11.09.09.08.36.005.0 ]--
r 113         System.out.println("");
--[ 2022.11.09.09.08.36.490.0 ]--
r 113         System.out.println("H");
--[ 2022.11.09.09.08.36.604.0 ]--
r 113         System.out.println("He");
--[ 2022.11.09.09.08.36.722.0 ]--
r 113         System.out.println("Hel");
--[ 2022.11.09.09.08.36.873.0 ]--
r 113         System.out.println("Hell");
--[ 2022.11.09.09.08.37.054.0 ]--
r 113         System.out.println("Hello");
--[ 2022.11.09.09.08.37.613.0 ]--
r 113         System.out.println("Hello ");
--[ 2022.11.09.09.08.37.949.0 ]--
r 113         System.out.println("Hello O");
--[ 2022.11.09.09.08.38.297.0 ]--
r 113         System.out.println("Hello ");
--[ 2022.11.09.09.08.38.379.0 ]--
r 113         System.out.println("Hello W");
--[ 2022.11.09.09.08.38.539.0 ]--
r 113         System.out.println("Hello Wo");
--[ 2022.11.09.09.08.38.700.0 ]--
r 113         System.out.println("Hello Wor");
--[ 2022.11.09.09.08.38.806.0 ]--
r 113         System.out.println("Hello Worl");
--[ 2022.11.09.09.08.38.981.0 ]--
r 113         System.out.println("Hello World");
--[ 2022.11.09.09.08.46.567.0 ]--
r 113        
--[ 2022.11.09.09.08.47.175.0 ]--
- 113
--[ 2022.11.09.09.08.51.561.0 ]--
DisposeComponent
--[ 2022.11.15.14.04.05.916.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.11.15.14.04.05.982.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/images/pathfindingUSA1024.png
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2022.11.15.14.04.05.990.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.11.15.14.04.05.990.1 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.11.15.14.04.05.992.0 ]--
InitFile: /src/Pathfinder.java

import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                return this.cost;
            } else {
                return 0;
            }
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() { return start; }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        // sets start node and adds to queue
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.cost;
    }

    public int getSearchSize() { return NodeCount; }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.11.15.14.04.05.992.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.11.15.14.04.05.993.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.11.15.14.04.05.993.1 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.15.14.04.05.994.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.11.15.14.04.05.994.1 ]--
InitFile: /.cos265


--[ 2022.11.15.14.04.05.994.2 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.11.15.14.04.05.995.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.11.15.14.04.36.705.0 ]--
DisposeComponent
--[ 2022.12.14.12.05.33.884.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.12.14.12.05.33.895.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/images/pathfindingUSA1024.png
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2022.12.14.12.05.33.895.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.12.14.12.05.33.895.2 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.12.14.12.05.33.895.3 ]--
InitFile: /src/Pathfinder.java

import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                return this.cost;
            } else {
                return 0;
            }
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() { return start; }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        // sets start node and adds to queue
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.cost;
    }

    public int getSearchSize() { return NodeCount; }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.12.14.12.05.33.895.4 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.12.14.12.05.33.895.5 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.12.14.12.05.33.895.6 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.12.14.12.05.33.895.7 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.12.14.12.05.33.896.0 ]--
InitFile: /.cos265


--[ 2022.12.14.12.05.33.896.1 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.12.14.12.05.33.896.2 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.12.14.12.06.41.991.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.12.14.12.27.44.310.0 ]--
NewLogger: P04_Pathfinding
Version: 1.5
--[ 2022.12.14.12.27.44.313.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/png2emap.py
/tests/ramp.png.emap
/tests/ramp2.png.emap
/tests/ramp3.png.emap
/tests/mazeAB.png.emap
/tests/usa128.png.emap
/tests/usa256.png.emap
/tests/usa1024.png.emap
/tests/maze32_0.png.emap
/tests/maze32_1.png.emap
/tests/maze232_0.png.emap
/tests/maze320_0.png.emap
/tests/mazeBrain.png.emap
/images/pathfindingUSA1024.png
/.cos265
/.DS_Store
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2022.12.14.12.27.44.314.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.12.14.12.27.44.314.1 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.12.14.12.27.44.314.2 ]--
InitFile: /src/Pathfinder.java

import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                return this.cost;
            } else {
                return 0;
            }
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() { return start; }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        // sets start node and adds to queue
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.cost;
    }

    public int getSearchSize() { return NodeCount; }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.12.14.12.27.44.314.3 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.12.14.12.27.44.314.4 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.12.14.12.27.44.314.5 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.12.14.12.27.44.314.6 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.12.14.12.27.44.315.0 ]--
InitFile: /.cos265


--[ 2022.12.14.12.27.44.315.1 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.12.14.12.27.44.315.2 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.12.14.12.27.46.128.0 ]--
UpdateTree (AD): 65 0
+ /out/production/P04_Pathfinding/.donotlog
+ /out/production/P04_Pathfinding/algs4.jar
+ /out/production/P04_Pathfinding/stdlib.jar
+ /out/production/P04_Pathfinding/Coord.class
+ /out/production/P04_Pathfinding/png2emap.py
+ /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/ramp.png.emap
+ /out/production/P04_Pathfinding/Terrain.class
+ /out/production/P04_Pathfinding/ramp2.png.emap
+ /out/production/P04_Pathfinding/ramp3.png.emap
+ /out/production/P04_Pathfinding/mazeAB.png.emap
+ /out/production/P04_Pathfinding/usa128.png.emap
+ /out/production/P04_Pathfinding/usa256.png.emap
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/usa1024.png.emap
+ /out/production/P04_Pathfinding/maze32_0.png.emap
+ /out/production/P04_Pathfinding/maze32_1.png.emap
+ /out/production/P04_Pathfinding/maze232_0.png.emap
+ /out/production/P04_Pathfinding/maze320_0.png.emap
+ /out/production/P04_Pathfinding/mazeBrain.png.emap
+ /out/production/P04_Pathfinding/TerrainEditor.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/PathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /src/algs4.jar
+ /src/Coord.java
+ /src/stdlib.jar
+ /src/Walker.java
+ /src/Terrain.java
+ /src/Pathfinder.java
+ /src/TerrainEditor.java
+ /src/PathfinderVisualizer.java
+ /src/InteractivePathfinderVisualizer.java
+ /.log/history.log
+ /.idea/copyright/profiles_settings.xml
+ /.idea/libraries/algs4.xml
+ /.idea/libraries/stdlib.xml
+ /.idea/.name
+ /.idea/vcs.xml
+ /.idea/misc.xml
+ /.idea/.gitignore
+ /.idea/modules.xml
+ /.idea/compiler.xml
+ /.idea/workspace.xml
+ /.idea/uiDesigner.xml
+ /tests/.donotlog
+ /tests/png2emap.py
+ /tests/ramp.png.emap
+ /tests/ramp2.png.emap
+ /tests/ramp3.png.emap
+ /tests/mazeAB.png.emap
+ /tests/usa128.png.emap
+ /tests/usa256.png.emap
+ /tests/usa1024.png.emap
+ /tests/maze32_0.png.emap
+ /tests/maze32_1.png.emap
+ /tests/maze232_0.png.emap
+ /tests/maze320_0.png.emap
+ /tests/mazeBrain.png.emap
+ /images/pathfindingUSA1024.png
+ /.cos265
+ /.DS_Store
+ /readme.html
+ /P04_Pathfinding.iml
+ /P04_Pathfinding.zip

--[ 2022.12.14.12.27.46.129.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i-1 && j >= min.j && j <= max.j-1;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2022.12.14.12.27.46.129.1 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Coord location;
    private Terrain terrain;
    private Iterator<Coord> path;
    private boolean doneWalking = false;
    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path.iterator();
        if (this.path.hasNext()) {
            this.location = this.path.next();
        }
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.location;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return doneWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        while (byTime >= 0.0f && this.path.hasNext()) {
            Coord next = this.path.next();
            byTime -= this.terrain.computeTravelCost(this.location, next);
            this.location = next;
            doneWalking = !this.path.hasNext();
        }
    }
}

--[ 2022.12.14.12.27.46.129.2 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2022.12.14.12.27.46.129.3 ]--
InitFile: /src/Pathfinder.java

import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    MinPQ<PFNode> pq;
    Stack<Coord> path;
    int N, NodeCount;
    Coord max, min;
    Coord start, end = null;
    float heuristic;
    boolean[][] array;
    Terrain t;
    boolean found = false;
    PFNode endNode;
    /**
     * PFNode will be the key for MinPQ (used in computePath())
     *
     * 1. identify possible paths
     * 2. Determine cost to move
     * 3. add them to the PriorityQ
     * 4. dequeue top and go back to step 1
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        Coord currentTile;
        PFNode prevNode;
        float cost;
        public PFNode(Coord loc, PFNode fromNode) {
            currentTile = loc;
            prevNode = fromNode;
            cost = -1;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if (this.cost > that.cost) {
                return 1;
            }
            else if (this.cost < that.cost) {
                return -1;
            }
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            // cost(start, neighbor) + travelCost(neighbor, this) + (heuristic * computeDistance(this, end))
            // recursive all the way back to start
            if (this.prevNode != null) {
                this.cost = this.prevNode.cost
                        + t.computeTravelCost(this.prevNode.currentTile, this.currentTile)
                        + (heuristic * t.computeDistance(this.currentTile, getPathEnd()));
                return this.cost;
            } else {
                return 0;
            }
        }
    }

    public Pathfinder(Terrain terrain) {
        t = terrain;
        N = t.getN();
        max = new Coord(N,N);
        min = new Coord(0,0);
        // secondary data structure to keep track of where I have already checked.
        array = new boolean[N][N];
    }

    public void setPathStart(Coord loc) {
        start = loc;
    }

    public Coord getPathStart() { return start; }

    public void setPathEnd(Coord loc) {
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        heuristic = v;
    }

    public float getHeuristic() {
        return heuristic;
    }

    public void resetPath() {
        //System.out.println("Reset path");
        array = new boolean[N][N];
        found = false;
        NodeCount = 0;

    }

    public void computePath() {
        // sets start node and adds to queue
        pq = new MinPQ<>();
        PFNode s = new PFNode(getPathStart(), null);
        NodeCount++;
        pq.insert(s);
        array[getPathStart().getI()][getPathStart().getJ()] = true;

        if (start == null) {
            throw new IllegalArgumentException("Error: Start has not been set.");
        }
        else if (end == null) {
            throw new IllegalArgumentException("Error: End has not been set.");
        }
        // while priority Q is not empty, dequeue the first item and process it.
        while(!foundPath()) {
            // logic for checking surrounding tiles and then using getCost() to determine which direction to make a
            // new PFNode for.
            PFNode nextTile = pq.delMin();
            if (nextTile.currentTile.equals(end)) {
                nextTile.getCost(heuristic);
                endNode = nextTile;
                for (path = new Stack<>(); nextTile.prevNode != null; nextTile = nextTile.prevNode) {
                    path.push(nextTile.currentTile);
                }
                found = true;
                continue;
            }
            // above of current tile
            if (new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min, max)
                    && !array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()]) {
                //System.out.println("Above created");
                PFNode above = new PFNode(new Coord(nextTile.currentTile.add(-1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                above.getCost(heuristic);
                array[nextTile.currentTile.add(-1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(above);
                NodeCount++;
            }
            // below of current tile
            if (new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()]) {
                PFNode below = new PFNode(new Coord(nextTile.currentTile.add(1,0).getI(), nextTile.currentTile.getJ()), nextTile);
                below.getCost(heuristic);
                array[nextTile.currentTile.add(1,0).getI()][nextTile.currentTile.getJ()] = true;
                pq.insert(below);
                NodeCount++;
            }
            // left current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()]) {
                PFNode left = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,-1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,-1).getJ()] = true;
                left.getCost(heuristic);
                pq.insert(left);
                NodeCount++;
            }
            // right current tile
            if (new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()).isInBounds(min,max)
                    && !array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()]) {
                PFNode right = new PFNode(new Coord(nextTile.currentTile.getI(), nextTile.currentTile.add(0,1).getJ()), nextTile);
                array[nextTile.currentTile.getI()][nextTile.currentTile.add(0,1).getJ()] = true;
                right.getCost(heuristic);
                pq.insert(right);
                NodeCount++;
            }
        }
    }

    public boolean foundPath() {
        return found;
    }

    public float getPathCost() {
        return endNode.cost;
    }

    public int getSearchSize() { return NodeCount; }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {return array[loc.getI()][loc.getJ()];
    }
}

--[ 2022.12.14.12.27.46.129.4 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2022.12.14.12.27.46.129.5 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2022.12.14.12.27.46.130.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.resetPath();
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2022.12.14.12.27.46.130.1 ]--
InitFile: /.cos265


--[ 2022.12.14.12.27.46.130.2 ]--
InitFile: /.DS_Store
   Bud1                                                                      e slg1Scomp                                                                                                                                                                           i m a g e slg1Scomp            i m a g e smoDDblob   dPA    i m a g e smodDblob   dPA    i m a g e sph1Scomp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                 `                                                   @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

--[ 2022.12.14.12.27.46.130.3 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.12.14.12.28.17.076.0 ]--
DisposeComponent
